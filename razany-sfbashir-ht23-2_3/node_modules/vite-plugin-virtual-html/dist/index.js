"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  DEFAULT_INJECTCODE_ALL: () => DEFAULT_INJECTCODE_ALL,
  POS: () => POS,
  VIRTUAL_HTML_CONTENT: () => VIRTUAL_HTML_CONTENT,
  addTrailingSlash: () => addTrailingSlash,
  buildHistoryApiFallback: () => buildHistoryApiFallback,
  cwd: () => cwd,
  default: () => src_default,
  defaultRender: () => defaultRender,
  extractHtmlPath: () => extractHtmlPath,
  findAllHtmlInProject: () => findAllHtmlInProject,
  generateInjectCode: () => generateInjectCode,
  generatePageOptions: () => generatePageOptions,
  generateUrl: () => generateUrl,
  generateVirtualPage: () => generateVirtualPage,
  getHtmlName: () => getHtmlName,
  historyApiFallbackPlugin: () => historyApiFallbackPlugin,
  logger: () => logger,
  normalizePath: () => normalizePath,
  readHtml: () => readHtml,
  readTemplate: () => readTemplate,
  renderTemplate: () => renderTemplate,
  slash: () => slash
});
module.exports = __toCommonJS(src_exports);

// src/types.ts
var import_fast_glob = __toESM(require("fast-glob"));
var import_debug = __toESM(require("debug"));
var import_node_path = __toESM(require("path"));
var import_node_os = __toESM(require("os"));
var POS = /* @__PURE__ */ ((POS2) => {
  POS2[POS2["before"] = 0] = "before";
  POS2[POS2["after"] = 1] = "after";
  return POS2;
})(POS || {});
var DEFAULT_INJECTCODE_ALL = "*";
var alreadyShowEjsError = false;
function defaultRender(template, data) {
  try {
    const resolved = require.resolve("ejs");
    return require(resolved).render(template, data, {
      delimiter: "%",
      root: process.cwd()
    });
  } catch (e) {
    if (e.code === "MODULE_NOT_FOUND") {
      if (!alreadyShowEjsError) {
        logger(`[vite-plugin-virtual-html]: Module 'ejs' is not found! If you want to use it, please install it. Otherwise please ignore this error!`);
        alreadyShowEjsError = true;
      }
    }
  }
  return template;
}
var cwd = normalizePath(process.cwd());
var VIRTUAL_HTML_CONTENT = `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>#TITLE#</title>
    <script src="#ENTRY#" type="module"><\/script>
</head>
<body>
#BODY#
</body>
</html>
`;
var DEFAULT_GLOB_PATTERN = [
  "**/*.html",
  "!node_modules/**/*.html",
  "!.**/*.html"
];
var logger = (0, import_debug.default)("vite-plugin-virtual-html");
function findAllHtmlInProject(extraGlobPattern = []) {
  const pages = {};
  let realPattern = extraGlobPattern;
  if (extraGlobPattern.length === 0) {
    realPattern = DEFAULT_GLOB_PATTERN;
  }
  const files = import_fast_glob.default.sync(realPattern);
  files.forEach((file) => {
    const filePathArr = file.split("/");
    pages[filePathArr[filePathArr.length - 1].replace(".html", "")] = `/${file}`;
  });
  return pages;
}
function generateInjectCode({ pos, find, replacement }, code) {
  if (pos === 1 /* after */) {
    return code.replace(find, `${find}
${replacement}`);
  }
  if (pos === 0 /* before */) {
    return code.replace(find, `
${replacement}
${find}`);
  }
  return code;
}
async function generateVirtualPage(vPages) {
  const {
    entry,
    title = "",
    body = '<div id="app"></div>'
  } = vPages;
  return VIRTUAL_HTML_CONTENT.replace("#ENTRY#", entry).replace("#TITLE#", title).replace("#BODY#", body);
}
function slash(p) {
  return p.replace(/\\/g, "/");
}
function normalizePath(id) {
  return import_node_path.default.posix.normalize(import_node_os.default.platform() === "win32" ? slash(id) : id);
}

// src/devUtils.ts
var path2 = __toESM(require("path"));
var fs = __toESM(require("fs"));
var fsp = fs.promises;
function generateUrl(url) {
  if (!url) {
    return "/";
  }
  if (url.indexOf("?") > 0) {
    return url.split("?")[0];
  }
  return url;
}
async function readHtml({ template = "", data = {}, render = defaultRender }) {
  const templatePath = path2.resolve(cwd, `.${template}`);
  if (!fs.existsSync(templatePath)) {
    logger("[vite-plugin-virtual-html]: template file must exist!");
    return "";
  }
  const htmlCode = await renderTemplate(templatePath, render, data);
  return htmlCode;
}
async function renderTemplate(templatePath, render, data) {
  return await readTemplate(templatePath).then((code) => {
    const result = render(code, data);
    return result;
  });
}
async function readTemplate(templatePath) {
  const result = await fsp.readFile(templatePath);
  return result.toString();
}
async function generatePageOptions(page, globalData, globalRender) {
  var _a;
  if (typeof page === "string") {
    return {
      template: page,
      data: {
        ...globalData
      },
      render: globalRender
    };
  }
  const { data = {}, render, template } = page;
  return {
    template,
    data: {
      ...globalData,
      ...data
    },
    render: (_a = render != null ? render : globalRender) != null ? _a : defaultRender
  };
}

// src/buildUtils.ts
function extractHtmlPath(pages) {
  const newPages = {};
  Object.keys(pages).forEach((key) => {
    newPages[key] = `/${key}.html`;
  });
  return newPages;
}
function getHtmlName(id, root) {
  const _root = (root != null ? root : "").replace(cwd, "");
  const _id = id.replace(cwd, "");
  const result = _id.substring(0, _id.length - ".html".length).replace(_root !== "" ? addTrailingSlash(_root) : "", "");
  return result.startsWith("/") ? result.substring(1) : result;
}
function addTrailingSlash(path4) {
  const _path = normalizePath(path4.replace(cwd, ""));
  return _path.endsWith("/") ? _path : `${_path}/`;
}

// src/plugin.ts
var import_path = __toESM(require("path"));
var import_fs = __toESM(require("fs"));
var import_connect_history_api_fallback = __toESM(require("connect-history-api-fallback"));
var plugin_default = (virtualHtmlOptions) => {
  const {
    pages: pagesObj,
    indexPage = "index",
    render: globalRender = defaultRender,
    data: globalData = {},
    extraGlobPattern = [],
    injectCode = {},
    rewrites
  } = virtualHtmlOptions;
  let pages;
  if (pagesObj === true || pagesObj === void 0) {
    pages = findAllHtmlInProject(extraGlobPattern);
  } else {
    pages = pagesObj;
  }
  let _config;
  let distDir;
  const needRemove = [];
  const plugin = {
    name: "vite-plugin-virtual-html",
    configureServer(server) {
      if (rewrites) {
        buildHistoryApiFallback(server, rewrites);
      }
      return () => {
        server.middlewares.use("/", async (req, res, next) => {
          var _a, _b;
          let url = decodeURI(generateUrl(req.url));
          if (!url.endsWith(".html") && url !== "/") {
            return next();
          }
          let htmlCode;
          if (url === "/" || url.indexOf("index.html") >= 0) {
            url = `/${indexPage}.html`;
            htmlCode = (_a = await plugin.load(normalizePath(url))) != null ? _a : "";
          } else {
            htmlCode = (_b = await plugin.load(url)) != null ? _b : "";
          }
          const transformResult = await plugin.transform(htmlCode, url);
          if (transformResult === null) {
            return next();
          }
          res.end(await server.transformIndexHtml(url, transformResult));
          next();
        });
      };
    },
    async transform(code, id) {
      if (id.indexOf(".html") >= 0) {
        const ids = id.split("/");
        const key = ids[ids.length - 1];
        if (key in injectCode) {
          return generateInjectCode(injectCode[key], code);
        }
        if (DEFAULT_INJECTCODE_ALL in injectCode) {
          return generateInjectCode(injectCode[DEFAULT_INJECTCODE_ALL], code);
        }
        return code;
      }
      return null;
    },
    async config(config, { command }) {
      var _a, _b, _c, _d, _e;
      _config = config;
      if (command === "build") {
        for (let i = 0; i < Object.keys(pages).length; i++) {
          const key = Object.keys(pages)[i];
          const pageOption = pages[key];
          const vHtml = normalizePath(import_path.default.resolve(cwd, `./${config.root ? addTrailingSlash(config.root) : ""}${key}.html`));
          if (!import_fs.default.existsSync(vHtml)) {
            needRemove.push(vHtml);
            await checkVirtualPath(vHtml, needRemove);
            if (typeof pageOption === "string" || "template" in pageOption) {
              const genPageOption = await generatePageOptions(pageOption, globalData, globalRender);
              await import_fs.promises.copyFile(import_path.default.resolve(cwd, `.${genPageOption.template}`), vHtml);
            }
            if (typeof pageOption !== "string" && "entry" in pageOption) {
              await import_fs.promises.writeFile(import_path.default.resolve(cwd, vHtml), await generateVirtualPage(pageOption));
            }
          }
        }
        logger("[vite-plugin-virtual-html]: This plugin cannot use in library mode!");
        distDir = (_b = (_a = config.build) == null ? void 0 : _a.outDir) != null ? _b : "dist";
        config.build = {
          ...config.build,
          rollupOptions: {
            ...(_c = config.build) == null ? void 0 : _c.rollupOptions,
            input: {
              ...(_e = (_d = config.build) == null ? void 0 : _d.rollupOptions) == null ? void 0 : _e.input,
              ...extractHtmlPath(pages)
            }
          }
        };
      }
    },
    async load(id) {
      if (id.endsWith("html")) {
        const newId = getHtmlName(id, _config == null ? void 0 : _config.root);
        const pageOption = pages[newId];
        if (pageOption !== void 0) {
          if (typeof pageOption === "string") {
            const page = await generatePageOptions(pageOption, globalData, globalRender);
            return await readHtml(page);
          }
          if ("template" in pageOption) {
            const page = await generatePageOptions(pageOption, globalData, globalRender);
            return await readHtml(page);
          }
          if ("entry" in pageOption) {
            return await generateVirtualPage(pageOption);
          }
        }
      }
      return null;
    },
    async closeBundle() {
      for (let vHtml of needRemove) {
        if (import_fs.default.existsSync(vHtml)) {
          await import_fs.promises.rm(vHtml, {
            recursive: true
          }).catch(() => {
          });
        }
      }
    }
  };
  return plugin;
};
var historyApiFallbackPlugin = (virtualHtmlOptions) => {
  const { rewrites } = virtualHtmlOptions;
  return {
    name: "vite-plugin-virtual-html:history",
    configureServer(server) {
      if (rewrites) {
        buildHistoryApiFallback(server, rewrites);
      }
    }
  };
};
function buildHistoryApiFallback(server, rewrites) {
  server.middlewares.use((0, import_connect_history_api_fallback.default)({
    disableDotRule: void 0,
    htmlAcceptHeaders: [
      "text/html",
      "application/xhtml+xml"
    ],
    rewrites
  }));
}
async function checkVirtualPath(html, needRemove) {
  const pathArr = html.split("/");
  const fileName = pathArr[pathArr.length - 1];
  const middlePath = html.replace(fileName, "").replace(cwd, "");
  const firstPath = middlePath.split("/")[1];
  if (!import_fs.default.existsSync(middlePath)) {
    needRemove.push(normalizePath(import_path.default.resolve(cwd, `./${firstPath}`)));
    await import_fs.promises.mkdir(import_path.default.resolve(cwd, `./${middlePath}`), {
      recursive: true
    });
  }
}

// src/index.ts
var src_default = plugin_default;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  DEFAULT_INJECTCODE_ALL,
  POS,
  VIRTUAL_HTML_CONTENT,
  addTrailingSlash,
  buildHistoryApiFallback,
  cwd,
  defaultRender,
  extractHtmlPath,
  findAllHtmlInProject,
  generateInjectCode,
  generatePageOptions,
  generateUrl,
  generateVirtualPage,
  getHtmlName,
  historyApiFallbackPlugin,
  logger,
  normalizePath,
  readHtml,
  readTemplate,
  renderTemplate,
  slash
});
//# sourceMappingURL=index.js.map