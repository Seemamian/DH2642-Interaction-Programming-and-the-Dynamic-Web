var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x + '" is not supported');
});

// src/types.ts
import glob from "fast-glob";
import debug from "debug";
import path from "path";
import os from "os";
var POS = /* @__PURE__ */ ((POS2) => {
  POS2[POS2["before"] = 0] = "before";
  POS2[POS2["after"] = 1] = "after";
  return POS2;
})(POS || {});
var DEFAULT_INJECTCODE_ALL = "*";
var alreadyShowEjsError = false;
function defaultRender(template, data) {
  try {
    const resolved = __require.resolve("ejs");
    return __require(resolved).render(template, data, {
      delimiter: "%",
      root: process.cwd()
    });
  } catch (e) {
    if (e.code === "MODULE_NOT_FOUND") {
      if (!alreadyShowEjsError) {
        logger(`[vite-plugin-virtual-html]: Module 'ejs' is not found! If you want to use it, please install it. Otherwise please ignore this error!`);
        alreadyShowEjsError = true;
      }
    }
  }
  return template;
}
var cwd = normalizePath(process.cwd());
var VIRTUAL_HTML_CONTENT = `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>#TITLE#</title>
    <script src="#ENTRY#" type="module"><\/script>
</head>
<body>
#BODY#
</body>
</html>
`;
var DEFAULT_GLOB_PATTERN = [
  "**/*.html",
  "!node_modules/**/*.html",
  "!.**/*.html"
];
var logger = debug("vite-plugin-virtual-html");
function findAllHtmlInProject(extraGlobPattern = []) {
  const pages = {};
  let realPattern = extraGlobPattern;
  if (extraGlobPattern.length === 0) {
    realPattern = DEFAULT_GLOB_PATTERN;
  }
  const files = glob.sync(realPattern);
  files.forEach((file) => {
    const filePathArr = file.split("/");
    pages[filePathArr[filePathArr.length - 1].replace(".html", "")] = `/${file}`;
  });
  return pages;
}
function generateInjectCode({ pos, find, replacement }, code) {
  if (pos === 1 /* after */) {
    return code.replace(find, `${find}
${replacement}`);
  }
  if (pos === 0 /* before */) {
    return code.replace(find, `
${replacement}
${find}`);
  }
  return code;
}
async function generateVirtualPage(vPages) {
  const {
    entry,
    title = "",
    body = '<div id="app"></div>'
  } = vPages;
  return VIRTUAL_HTML_CONTENT.replace("#ENTRY#", entry).replace("#TITLE#", title).replace("#BODY#", body);
}
function slash(p) {
  return p.replace(/\\/g, "/");
}
function normalizePath(id) {
  return path.posix.normalize(os.platform() === "win32" ? slash(id) : id);
}

// src/devUtils.ts
import * as path2 from "path";
import * as fs from "fs";
var fsp = fs.promises;
function generateUrl(url) {
  if (!url) {
    return "/";
  }
  if (url.indexOf("?") > 0) {
    return url.split("?")[0];
  }
  return url;
}
async function readHtml({ template = "", data = {}, render = defaultRender }) {
  const templatePath = path2.resolve(cwd, `.${template}`);
  if (!fs.existsSync(templatePath)) {
    logger("[vite-plugin-virtual-html]: template file must exist!");
    return "";
  }
  const htmlCode = await renderTemplate(templatePath, render, data);
  return htmlCode;
}
async function renderTemplate(templatePath, render, data) {
  return await readTemplate(templatePath).then((code) => {
    const result = render(code, data);
    return result;
  });
}
async function readTemplate(templatePath) {
  const result = await fsp.readFile(templatePath);
  return result.toString();
}
async function generatePageOptions(page, globalData, globalRender) {
  var _a;
  if (typeof page === "string") {
    return {
      template: page,
      data: {
        ...globalData
      },
      render: globalRender
    };
  }
  const { data = {}, render, template } = page;
  return {
    template,
    data: {
      ...globalData,
      ...data
    },
    render: (_a = render != null ? render : globalRender) != null ? _a : defaultRender
  };
}

// src/buildUtils.ts
function extractHtmlPath(pages) {
  const newPages = {};
  Object.keys(pages).forEach((key) => {
    newPages[key] = `/${key}.html`;
  });
  return newPages;
}
function getHtmlName(id, root) {
  const _root = (root != null ? root : "").replace(cwd, "");
  const _id = id.replace(cwd, "");
  const result = _id.substring(0, _id.length - ".html".length).replace(_root !== "" ? addTrailingSlash(_root) : "", "");
  return result.startsWith("/") ? result.substring(1) : result;
}
function addTrailingSlash(path4) {
  const _path = normalizePath(path4.replace(cwd, ""));
  return _path.endsWith("/") ? _path : `${_path}/`;
}

// src/plugin.ts
import path3 from "path";
import fs2, { promises as fsp2 } from "fs";
import history from "connect-history-api-fallback";
var plugin_default = (virtualHtmlOptions) => {
  const {
    pages: pagesObj,
    indexPage = "index",
    render: globalRender = defaultRender,
    data: globalData = {},
    extraGlobPattern = [],
    injectCode = {},
    rewrites
  } = virtualHtmlOptions;
  let pages;
  if (pagesObj === true || pagesObj === void 0) {
    pages = findAllHtmlInProject(extraGlobPattern);
  } else {
    pages = pagesObj;
  }
  let _config;
  let distDir;
  const needRemove = [];
  const plugin = {
    name: "vite-plugin-virtual-html",
    configureServer(server) {
      if (rewrites) {
        buildHistoryApiFallback(server, rewrites);
      }
      return () => {
        server.middlewares.use("/", async (req, res, next) => {
          var _a, _b;
          let url = decodeURI(generateUrl(req.url));
          if (!url.endsWith(".html") && url !== "/") {
            return next();
          }
          let htmlCode;
          if (url === "/" || url.indexOf("index.html") >= 0) {
            url = `/${indexPage}.html`;
            htmlCode = (_a = await plugin.load(normalizePath(url))) != null ? _a : "";
          } else {
            htmlCode = (_b = await plugin.load(url)) != null ? _b : "";
          }
          const transformResult = await plugin.transform(htmlCode, url);
          if (transformResult === null) {
            return next();
          }
          res.end(await server.transformIndexHtml(url, transformResult));
          next();
        });
      };
    },
    async transform(code, id) {
      if (id.indexOf(".html") >= 0) {
        const ids = id.split("/");
        const key = ids[ids.length - 1];
        if (key in injectCode) {
          return generateInjectCode(injectCode[key], code);
        }
        if (DEFAULT_INJECTCODE_ALL in injectCode) {
          return generateInjectCode(injectCode[DEFAULT_INJECTCODE_ALL], code);
        }
        return code;
      }
      return null;
    },
    async config(config, { command }) {
      var _a, _b, _c, _d, _e;
      _config = config;
      if (command === "build") {
        for (let i = 0; i < Object.keys(pages).length; i++) {
          const key = Object.keys(pages)[i];
          const pageOption = pages[key];
          const vHtml = normalizePath(path3.resolve(cwd, `./${config.root ? addTrailingSlash(config.root) : ""}${key}.html`));
          if (!fs2.existsSync(vHtml)) {
            needRemove.push(vHtml);
            await checkVirtualPath(vHtml, needRemove);
            if (typeof pageOption === "string" || "template" in pageOption) {
              const genPageOption = await generatePageOptions(pageOption, globalData, globalRender);
              await fsp2.copyFile(path3.resolve(cwd, `.${genPageOption.template}`), vHtml);
            }
            if (typeof pageOption !== "string" && "entry" in pageOption) {
              await fsp2.writeFile(path3.resolve(cwd, vHtml), await generateVirtualPage(pageOption));
            }
          }
        }
        logger("[vite-plugin-virtual-html]: This plugin cannot use in library mode!");
        distDir = (_b = (_a = config.build) == null ? void 0 : _a.outDir) != null ? _b : "dist";
        config.build = {
          ...config.build,
          rollupOptions: {
            ...(_c = config.build) == null ? void 0 : _c.rollupOptions,
            input: {
              ...(_e = (_d = config.build) == null ? void 0 : _d.rollupOptions) == null ? void 0 : _e.input,
              ...extractHtmlPath(pages)
            }
          }
        };
      }
    },
    async load(id) {
      if (id.endsWith("html")) {
        const newId = getHtmlName(id, _config == null ? void 0 : _config.root);
        const pageOption = pages[newId];
        if (pageOption !== void 0) {
          if (typeof pageOption === "string") {
            const page = await generatePageOptions(pageOption, globalData, globalRender);
            return await readHtml(page);
          }
          if ("template" in pageOption) {
            const page = await generatePageOptions(pageOption, globalData, globalRender);
            return await readHtml(page);
          }
          if ("entry" in pageOption) {
            return await generateVirtualPage(pageOption);
          }
        }
      }
      return null;
    },
    async closeBundle() {
      for (let vHtml of needRemove) {
        if (fs2.existsSync(vHtml)) {
          await fsp2.rm(vHtml, {
            recursive: true
          }).catch(() => {
          });
        }
      }
    }
  };
  return plugin;
};
var historyApiFallbackPlugin = (virtualHtmlOptions) => {
  const { rewrites } = virtualHtmlOptions;
  return {
    name: "vite-plugin-virtual-html:history",
    configureServer(server) {
      if (rewrites) {
        buildHistoryApiFallback(server, rewrites);
      }
    }
  };
};
function buildHistoryApiFallback(server, rewrites) {
  server.middlewares.use(history({
    disableDotRule: void 0,
    htmlAcceptHeaders: [
      "text/html",
      "application/xhtml+xml"
    ],
    rewrites
  }));
}
async function checkVirtualPath(html, needRemove) {
  const pathArr = html.split("/");
  const fileName = pathArr[pathArr.length - 1];
  const middlePath = html.replace(fileName, "").replace(cwd, "");
  const firstPath = middlePath.split("/")[1];
  if (!fs2.existsSync(middlePath)) {
    needRemove.push(normalizePath(path3.resolve(cwd, `./${firstPath}`)));
    await fsp2.mkdir(path3.resolve(cwd, `./${middlePath}`), {
      recursive: true
    });
  }
}

// src/index.ts
var src_default = plugin_default;
export {
  DEFAULT_INJECTCODE_ALL,
  POS,
  VIRTUAL_HTML_CONTENT,
  addTrailingSlash,
  buildHistoryApiFallback,
  cwd,
  src_default as default,
  defaultRender,
  extractHtmlPath,
  findAllHtmlInProject,
  generateInjectCode,
  generatePageOptions,
  generateUrl,
  generateVirtualPage,
  getHtmlName,
  historyApiFallbackPlugin,
  logger,
  normalizePath,
  readHtml,
  readTemplate,
  renderTemplate,
  slash
};
//# sourceMappingURL=index.mjs.map