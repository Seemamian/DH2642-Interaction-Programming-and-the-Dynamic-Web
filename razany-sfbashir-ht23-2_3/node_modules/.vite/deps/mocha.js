import {
  require_inherits_browser,
  require_util
} from "./chunk-TF4JMVY6.js";
import "./chunk-T33LG35T.js";
import {
  __commonJS,
  __esm,
  __export,
  __require,
  __toCommonJS,
  _global,
  import_buffer,
  import_process,
  init_shim,
  require_buffer
} from "./chunk-ERV56XPB.js";

// node_modules/events/events.js
var require_events = __commonJS({
  "node_modules/events/events.js"(exports, module) {
    "use strict";
    init_shim();
    var R = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R && typeof R.ownKeys === "function") {
      ReflectOwnKeys = R.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn)
        console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter() {
      EventEmitter.init.call(this);
    }
    module.exports = EventEmitter;
    module.exports.once = once;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._eventsCount = 0;
    EventEmitter.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
      }
      this._maxListeners = n;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter.prototype.emit = function emit(type) {
      var args = [];
      for (var i = 1; i < arguments.length; i++)
        args.push(arguments[i]);
      var doError = type === "error";
      var events = this._events;
      if (events !== void 0)
        doError = doError && events.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          ReflectApply(listeners[i], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m;
      var events;
      var existing;
      checkListener(listener);
      events = target._events;
      if (events === void 0) {
        events = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events = target._events;
        }
        existing = events[type];
      }
      if (existing === void 0) {
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          ProcessEmitWarning(w);
        }
      }
      return target;
    }
    EventEmitter.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.removeListener = function removeListener(type, listener) {
      var list, events, position, i, originalListener;
      checkListener(listener);
      events = this._events;
      if (events === void 0)
        return this;
      list = events[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events[type] = list[0];
        if (events.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events, i;
      events = this._events;
      if (events === void 0)
        return this;
      if (events.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === "removeListener")
            continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap) {
      var events = target._events;
      if (events === void 0)
        return [];
      var evlistener = events[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;
      if (events !== void 0) {
        var evlistener = events[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n) {
      var copy = new Array(n);
      for (var i = 0; i < n; ++i)
        copy[i] = arr[i];
      return copy;
    }
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }
    function once(emitter, name) {
      return new Promise(function(resolve, reject) {
        function errorListener(err) {
          emitter.removeListener(name, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
        if (name !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name, listener);
        } else {
          emitter.on(name, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/stream-browser.js
var require_stream_browser = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports, module) {
    init_shim();
    module.exports = require_events().EventEmitter;
  }
});

// node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module) {
    "use strict";
    init_shim();
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var _require = require_buffer();
    var Buffer2 = _require.Buffer;
    var _require2 = require_util();
    var inspect = _require2.inspect;
    var custom = inspect && inspect.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer2.prototype.copy.call(src, target, offset);
    }
    module.exports = function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList, [{
        key: "push",
        value: function push(v) {
          var entry = {
            data: v,
            next: null
          };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v) {
          var entry = {
            data: v,
            next: this.head
          };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0)
            return;
          var ret = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join(s) {
          if (this.length === 0)
            return "";
          var p = this.head;
          var ret = "" + p.data;
          while (p = p.next)
            ret += s + p.data;
          return ret;
        }
      }, {
        key: "concat",
        value: function concat(n) {
          if (this.length === 0)
            return Buffer2.alloc(0);
          var ret = Buffer2.allocUnsafe(n >>> 0);
          var p = this.head;
          var i = 0;
          while (p) {
            copyBuffer(p.data, ret, i);
            i += p.data.length;
            p = p.next;
          }
          return ret;
        }
        // Consumes a specified amount of bytes or characters from the buffered data.
      }, {
        key: "consume",
        value: function consume(n, hasStrings) {
          var ret;
          if (n < this.head.data.length) {
            ret = this.head.data.slice(0, n);
            this.head.data = this.head.data.slice(n);
          } else if (n === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n) : this._getBuffer(n);
          }
          return ret;
        }
      }, {
        key: "first",
        value: function first() {
          return this.head.data;
        }
        // Consumes a specified amount of characters from the buffered data.
      }, {
        key: "_getString",
        value: function _getString(n) {
          var p = this.head;
          var c = 1;
          var ret = p.data;
          n -= ret.length;
          while (p = p.next) {
            var str = p.data;
            var nb = n > str.length ? str.length : n;
            if (nb === str.length)
              ret += str;
            else
              ret += str.slice(0, n);
            n -= nb;
            if (n === 0) {
              if (nb === str.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = str.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        // Consumes a specified amount of bytes from the buffered data.
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n) {
          var ret = Buffer2.allocUnsafe(n);
          var p = this.head;
          var c = 1;
          p.data.copy(ret);
          n -= p.data.length;
          while (p = p.next) {
            var buf = p.data;
            var nb = n > buf.length ? buf.length : n;
            buf.copy(ret, ret.length - n, 0, nb);
            n -= nb;
            if (n === 0) {
              if (nb === buf.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = buf.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        // Make sure the linked list only shows the minimal necessary information.
      }, {
        key: custom,
        value: function value(_, options) {
          return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        }
      }]);
      return BufferList;
    }();
  }
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
    "use strict";
    init_shim();
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            import_process.default.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            import_process.default.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            import_process.default.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            import_process.default.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            import_process.default.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          import_process.default.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          import_process.default.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose)
        return;
      if (self2._readableState && !self2._readableState.emitClose)
        return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy)
        stream.destroy(err);
      else
        stream.emit("error", err);
    }
    module.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// node_modules/readable-stream/errors-browser.js
var require_errors_browser = __commonJS({
  "node_modules/readable-stream/errors-browser.js"(exports, module) {
    "use strict";
    init_shim();
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    var codes = {};
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      var NodeError = function(_Base) {
        _inheritsLoose(NodeError2, _Base);
        function NodeError2(arg1, arg2, arg3) {
          return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
        }
        return NodeError2;
      }(Base);
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        var len = expected.length;
        expected = expected.map(function(i) {
          return String(i);
        });
        if (len > 2) {
          return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
        } else if (len === 2) {
          return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        } else {
          return "of ".concat(thing, " ").concat(expected[0]);
        }
      } else {
        return "of ".concat(thing, " ").concat(String(expected));
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      var determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      var msg;
      if (endsWith(name, " argument")) {
        msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      } else {
        var type = includes(name, ".") ? "property" : "argument";
        msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      }
      msg += ". Received type ".concat(typeof actual);
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
      return "The " + name + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name) {
      return "Cannot call " + name + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module.exports.codes = codes;
  }
});

// node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/state.js"(exports, module) {
    "use strict";
    init_shim();
    var ERR_INVALID_OPT_VALUE = require_errors_browser().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module.exports = {
      getHighWaterMark
    };
  }
});

// node_modules/util-deprecate/browser.js
var require_browser = __commonJS({
  "node_modules/util-deprecate/browser.js"(exports, module) {
    init_shim();
    module.exports = deprecate;
    function deprecate(fn, msg) {
      if (config("noDeprecation")) {
        return fn;
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (config("throwDeprecation")) {
            throw new Error(msg);
          } else if (config("traceDeprecation")) {
            console.trace(msg);
          } else {
            console.warn(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    }
    function config(name) {
      try {
        if (!_global.localStorage)
          return false;
      } catch (_) {
        return false;
      }
      var val = _global.localStorage[name];
      if (null == val)
        return false;
      return String(val).toLowerCase() === "true";
    }
  }
});

// node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/readable-stream/lib/_stream_writable.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex;
    Writable.WritableState = WritableState;
    var internalUtil = {
      deprecate: require_browser()
    };
    var Stream = require_stream_browser();
    var Buffer2 = require_buffer().Buffer;
    var OurUint8Array = (typeof _global !== "undefined" ? _global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits_browser()(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex();
      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this))
        return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er);
      import_process.default.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream, er);
        import_process.default.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ending)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        import_process.default.nextTick(cb, er);
        import_process.default.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function")
        throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          import_process.default.nextTick(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          import_process.default.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
          if (state.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          import_process.default.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/readable-stream/lib/_stream_duplex.js"(exports, module) {
    "use strict";
    init_shim();
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj)
        keys2.push(key);
      return keys2;
    };
    module.exports = Duplex;
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    require_inherits_browser()(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false)
          this.readable = false;
        if (options.writable === false)
          this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended)
        return;
      import_process.default.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports, module) {
    init_shim();
    var buffer = require_buffer();
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "node_modules/string_decoder/lib/string_decoder.js"(exports) {
    "use strict";
    init_shim();
    var Buffer2 = require_safe_buffer().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0)
          return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length)
        return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "�";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "�";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "�";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed)
        return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "�";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0)
        return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module) {
    "use strict";
    init_shim();
    var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once(callback || noop);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable)
          onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable)
          callback.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable)
          callback.call(stream);
      };
      var onerror = function onerror2(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    module.exports = eos;
  }
});

// node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports, module) {
    "use strict";
    init_shim();
    var _Object$setPrototypeO;
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var finished = require_end_of_stream();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done) {
      return {
        value,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve = iter[kLastResolve];
      if (resolve !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve(createIterResult(data, false));
        }
      }
    }
    function onReadable(iter) {
      import_process.default.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve, reject) {
            import_process.default.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve, reject) {
          var data = iterator[kStream].read();
          if (data) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(data, false));
          } else {
            iterator[kLastResolve] = resolve;
            iterator[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator[kLastReject];
          if (reject !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject(err);
          }
          iterator[kError] = err;
          return;
        }
        var resolve = iterator[kLastResolve];
        if (resolve !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator));
      return iterator;
    };
    module.exports = createReadableStreamAsyncIterator;
  }
});

// node_modules/readable-stream/lib/internal/streams/from-browser.js
var require_from_browser = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports, module) {
    init_shim();
    module.exports = function() {
      throw new Error("Readable.from is not available in the browser");
    };
  }
});

// node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/readable-stream/lib/_stream_readable.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = Readable;
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require_events().EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream_browser();
    var Buffer2 = require_buffer().Buffer;
    var OurUint8Array = (typeof _global !== "undefined" ? _global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = require_util();
    var debug;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function debug2() {
      };
    }
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from;
    require_inherits_browser()(Readable, Stream);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable))
        return new Readable(options);
      var isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          errorOrDestroy(stream, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p = this._readableState.buffer.head;
      var content = "";
      while (p !== null) {
        content += decoder.write(p.data);
        p = p.next;
      }
      this._readableState.buffer.clear();
      if (content !== "")
        this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        import_process.default.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      var state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        import_process.default.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== import_process.default.stdout && dest !== import_process.default.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        import_process.default.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        var ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          errorOrDestroy(dest, er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++)
          dests[i].emit("unpipe", this, {
            hasUnpiped: false
          });
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            import_process.default.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn) {
      var res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        import_process.default.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.removeAllListeners = function(ev) {
      var res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        import_process.default.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        import_process.default.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null)
        ;
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.flowing;
      },
      set: function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable._fromList = fromList;
    Object.defineProperty(Readable.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.length;
      }
    });
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.first();
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        import_process.default.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable.from = function(iterable, opts) {
        if (from === void 0) {
          from = require_from_browser();
        }
        return from(Readable, iterable, opts);
      };
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/readable-stream/lib/_stream_transform.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = Transform;
    var _require$codes = require_errors_browser().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex = require_stream_duplex();
    require_inherits_browser()(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming)
        throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
  }
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = PassThrough;
    var Transform = require_stream_transform();
    require_inherits_browser()(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module) {
    "use strict";
    init_shim();
    var eos;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = require_errors_browser().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop(err) {
      if (err)
        throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos === void 0)
        eos = require_end_of_stream();
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isRequest(stream))
          return stream.abort();
        if (typeof stream.destroy === "function")
          return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn) {
      fn();
    }
    function pipe(from, to) {
      return from.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length)
        return noop;
      if (typeof streams[streams.length - 1] !== "function")
        return noop;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error)
            error = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    }
    module.exports = pipeline;
  }
});

// node_modules/stream-browserify/index.js
var require_stream_browserify = __commonJS({
  "node_modules/stream-browserify/index.js"(exports, module) {
    init_shim();
    module.exports = Stream;
    var EE = require_events().EventEmitter;
    var inherits = require_inherits_browser();
    inherits(Stream, EE);
    Stream.Readable = require_stream_readable();
    Stream.Writable = require_stream_writable();
    Stream.Duplex = require_stream_duplex();
    Stream.Transform = require_stream_transform();
    Stream.PassThrough = require_stream_passthrough();
    Stream.finished = require_end_of_stream();
    Stream.pipeline = require_pipeline();
    Stream.Stream = Stream;
    function Stream() {
      EE.call(this);
    }
    Stream.prototype.pipe = function(dest, options) {
      var source = this;
      function ondata(chunk) {
        if (dest.writable) {
          if (false === dest.write(chunk) && source.pause) {
            source.pause();
          }
        }
      }
      source.on("data", ondata);
      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }
      dest.on("drain", ondrain);
      if (!dest._isStdio && (!options || options.end !== false)) {
        source.on("end", onend);
        source.on("close", onclose);
      }
      var didOnEnd = false;
      function onend() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        dest.end();
      }
      function onclose() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        if (typeof dest.destroy === "function")
          dest.destroy();
      }
      function onerror(er) {
        cleanup();
        if (EE.listenerCount(this, "error") === 0) {
          throw er;
        }
      }
      source.on("error", onerror);
      dest.on("error", onerror);
      function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
      }
      source.on("end", cleanup);
      source.on("close", cleanup);
      dest.on("close", cleanup);
      dest.emit("pipe", source);
      return dest;
    };
  }
});

// node_modules/browser-stdout/index.js
var require_browser_stdout = __commonJS({
  "node_modules/browser-stdout/index.js"(exports, module) {
    init_shim();
    var WritableStream = require_stream_browserify().Writable;
    var inherits = require_util().inherits;
    module.exports = BrowserStdout;
    inherits(BrowserStdout, WritableStream);
    function BrowserStdout(opts) {
      if (!(this instanceof BrowserStdout))
        return new BrowserStdout(opts);
      opts = opts || {};
      WritableStream.call(this, opts);
      this.label = opts.label !== void 0 ? opts.label : "stdout";
    }
    BrowserStdout.prototype._write = function(chunks, encoding, cb) {
      var output = chunks.toString ? chunks.toString() : chunks;
      if (this.label === false) {
        console.log(output);
      } else {
        console.log(this.label + ":", output);
      }
      import_process.default.nextTick(cb);
    };
  }
});

// node_modules/mocha/lib/browser/parse-query.js
var require_parse_query = __commonJS({
  "node_modules/mocha/lib/browser/parse-query.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = function parseQuery(qs) {
      return qs.replace("?", "").split("&").reduce(function(obj, pair) {
        var i = pair.indexOf("=");
        var key = pair.slice(0, i);
        var val = pair.slice(++i);
        obj[key] = decodeURIComponent(val.replace(/\+/g, "%20"));
        return obj;
      }, {});
    };
  }
});

// node_modules/mocha/lib/browser/highlight-tags.js
var require_highlight_tags = __commonJS({
  "node_modules/mocha/lib/browser/highlight-tags.js"(exports, module) {
    "use strict";
    init_shim();
    function highlight(js) {
      return js.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\/\/(.*)/gm, '<span class="comment">//$1</span>').replace(/('.*?')/gm, '<span class="string">$1</span>').replace(/(\d+\.\d+)/gm, '<span class="number">$1</span>').replace(/(\d+)/gm, '<span class="number">$1</span>').replace(
        /\bnew[ \t]+(\w+)/gm,
        '<span class="keyword">new</span> <span class="init">$1</span>'
      ).replace(
        /\b(function|new|throw|return|var|if|else)\b/gm,
        '<span class="keyword">$1</span>'
      );
    }
    module.exports = function highlightTags(name) {
      var code = document.getElementById("mocha").getElementsByTagName(name);
      for (var i = 0, len = code.length; i < len; ++i) {
        code[i].innerHTML = highlight(code[i].innerHTML);
      }
    };
  }
});

// node_modules/mocha/node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS({
  "node_modules/mocha/node_modules/escape-string-regexp/index.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = (string) => {
      if (typeof string !== "string") {
        throw new TypeError("Expected a string");
      }
      return string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
    };
  }
});

// node_modules/path-browserify/index.js
var require_path_browserify = __commonJS({
  "node_modules/path-browserify/index.js"(exports, module) {
    "use strict";
    init_shim();
    function assertPath(path) {
      if (typeof path !== "string") {
        throw new TypeError("Path must be a string. Received " + JSON.stringify(path));
      }
    }
    function normalizeStringPosix(path, allowAboveRoot) {
      var res = "";
      var lastSegmentLength = 0;
      var lastSlash = -1;
      var dots = 0;
      var code;
      for (var i = 0; i <= path.length; ++i) {
        if (i < path.length)
          code = path.charCodeAt(i);
        else if (code === 47)
          break;
        else
          code = 47;
        if (code === 47) {
          if (lastSlash === i - 1 || dots === 1) {
          } else if (lastSlash !== i - 1 && dots === 2) {
            if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
              if (res.length > 2) {
                var lastSlashIndex = res.lastIndexOf("/");
                if (lastSlashIndex !== res.length - 1) {
                  if (lastSlashIndex === -1) {
                    res = "";
                    lastSegmentLength = 0;
                  } else {
                    res = res.slice(0, lastSlashIndex);
                    lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                  }
                  lastSlash = i;
                  dots = 0;
                  continue;
                }
              } else if (res.length === 2 || res.length === 1) {
                res = "";
                lastSegmentLength = 0;
                lastSlash = i;
                dots = 0;
                continue;
              }
            }
            if (allowAboveRoot) {
              if (res.length > 0)
                res += "/..";
              else
                res = "..";
              lastSegmentLength = 2;
            }
          } else {
            if (res.length > 0)
              res += "/" + path.slice(lastSlash + 1, i);
            else
              res = path.slice(lastSlash + 1, i);
            lastSegmentLength = i - lastSlash - 1;
          }
          lastSlash = i;
          dots = 0;
        } else if (code === 46 && dots !== -1) {
          ++dots;
        } else {
          dots = -1;
        }
      }
      return res;
    }
    function _format(sep, pathObject) {
      var dir = pathObject.dir || pathObject.root;
      var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
      if (!dir) {
        return base;
      }
      if (dir === pathObject.root) {
        return dir + base;
      }
      return dir + sep + base;
    }
    var posix = {
      // path.resolve([from ...], to)
      resolve: function resolve() {
        var resolvedPath = "";
        var resolvedAbsolute = false;
        var cwd;
        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path;
          if (i >= 0)
            path = arguments[i];
          else {
            if (cwd === void 0)
              cwd = import_process.default.cwd();
            path = cwd;
          }
          assertPath(path);
          if (path.length === 0) {
            continue;
          }
          resolvedPath = path + "/" + resolvedPath;
          resolvedAbsolute = path.charCodeAt(0) === 47;
        }
        resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
        if (resolvedAbsolute) {
          if (resolvedPath.length > 0)
            return "/" + resolvedPath;
          else
            return "/";
        } else if (resolvedPath.length > 0) {
          return resolvedPath;
        } else {
          return ".";
        }
      },
      normalize: function normalize(path) {
        assertPath(path);
        if (path.length === 0)
          return ".";
        var isAbsolute = path.charCodeAt(0) === 47;
        var trailingSeparator = path.charCodeAt(path.length - 1) === 47;
        path = normalizeStringPosix(path, !isAbsolute);
        if (path.length === 0 && !isAbsolute)
          path = ".";
        if (path.length > 0 && trailingSeparator)
          path += "/";
        if (isAbsolute)
          return "/" + path;
        return path;
      },
      isAbsolute: function isAbsolute(path) {
        assertPath(path);
        return path.length > 0 && path.charCodeAt(0) === 47;
      },
      join: function join() {
        if (arguments.length === 0)
          return ".";
        var joined;
        for (var i = 0; i < arguments.length; ++i) {
          var arg = arguments[i];
          assertPath(arg);
          if (arg.length > 0) {
            if (joined === void 0)
              joined = arg;
            else
              joined += "/" + arg;
          }
        }
        if (joined === void 0)
          return ".";
        return posix.normalize(joined);
      },
      relative: function relative(from, to) {
        assertPath(from);
        assertPath(to);
        if (from === to)
          return "";
        from = posix.resolve(from);
        to = posix.resolve(to);
        if (from === to)
          return "";
        var fromStart = 1;
        for (; fromStart < from.length; ++fromStart) {
          if (from.charCodeAt(fromStart) !== 47)
            break;
        }
        var fromEnd = from.length;
        var fromLen = fromEnd - fromStart;
        var toStart = 1;
        for (; toStart < to.length; ++toStart) {
          if (to.charCodeAt(toStart) !== 47)
            break;
        }
        var toEnd = to.length;
        var toLen = toEnd - toStart;
        var length = fromLen < toLen ? fromLen : toLen;
        var lastCommonSep = -1;
        var i = 0;
        for (; i <= length; ++i) {
          if (i === length) {
            if (toLen > length) {
              if (to.charCodeAt(toStart + i) === 47) {
                return to.slice(toStart + i + 1);
              } else if (i === 0) {
                return to.slice(toStart + i);
              }
            } else if (fromLen > length) {
              if (from.charCodeAt(fromStart + i) === 47) {
                lastCommonSep = i;
              } else if (i === 0) {
                lastCommonSep = 0;
              }
            }
            break;
          }
          var fromCode = from.charCodeAt(fromStart + i);
          var toCode = to.charCodeAt(toStart + i);
          if (fromCode !== toCode)
            break;
          else if (fromCode === 47)
            lastCommonSep = i;
        }
        var out = "";
        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
          if (i === fromEnd || from.charCodeAt(i) === 47) {
            if (out.length === 0)
              out += "..";
            else
              out += "/..";
          }
        }
        if (out.length > 0)
          return out + to.slice(toStart + lastCommonSep);
        else {
          toStart += lastCommonSep;
          if (to.charCodeAt(toStart) === 47)
            ++toStart;
          return to.slice(toStart);
        }
      },
      _makeLong: function _makeLong(path) {
        return path;
      },
      dirname: function dirname(path) {
        assertPath(path);
        if (path.length === 0)
          return ".";
        var code = path.charCodeAt(0);
        var hasRoot = code === 47;
        var end = -1;
        var matchedSlash = true;
        for (var i = path.length - 1; i >= 1; --i) {
          code = path.charCodeAt(i);
          if (code === 47) {
            if (!matchedSlash) {
              end = i;
              break;
            }
          } else {
            matchedSlash = false;
          }
        }
        if (end === -1)
          return hasRoot ? "/" : ".";
        if (hasRoot && end === 1)
          return "//";
        return path.slice(0, end);
      },
      basename: function basename(path, ext) {
        if (ext !== void 0 && typeof ext !== "string")
          throw new TypeError('"ext" argument must be a string');
        assertPath(path);
        var start = 0;
        var end = -1;
        var matchedSlash = true;
        var i;
        if (ext !== void 0 && ext.length > 0 && ext.length <= path.length) {
          if (ext.length === path.length && ext === path)
            return "";
          var extIdx = ext.length - 1;
          var firstNonSlashEnd = -1;
          for (i = path.length - 1; i >= 0; --i) {
            var code = path.charCodeAt(i);
            if (code === 47) {
              if (!matchedSlash) {
                start = i + 1;
                break;
              }
            } else {
              if (firstNonSlashEnd === -1) {
                matchedSlash = false;
                firstNonSlashEnd = i + 1;
              }
              if (extIdx >= 0) {
                if (code === ext.charCodeAt(extIdx)) {
                  if (--extIdx === -1) {
                    end = i;
                  }
                } else {
                  extIdx = -1;
                  end = firstNonSlashEnd;
                }
              }
            }
          }
          if (start === end)
            end = firstNonSlashEnd;
          else if (end === -1)
            end = path.length;
          return path.slice(start, end);
        } else {
          for (i = path.length - 1; i >= 0; --i) {
            if (path.charCodeAt(i) === 47) {
              if (!matchedSlash) {
                start = i + 1;
                break;
              }
            } else if (end === -1) {
              matchedSlash = false;
              end = i + 1;
            }
          }
          if (end === -1)
            return "";
          return path.slice(start, end);
        }
      },
      extname: function extname(path) {
        assertPath(path);
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var preDotState = 0;
        for (var i = path.length - 1; i >= 0; --i) {
          var code = path.charCodeAt(i);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          return "";
        }
        return path.slice(startDot, end);
      },
      format: function format(pathObject) {
        if (pathObject === null || typeof pathObject !== "object") {
          throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
        }
        return _format("/", pathObject);
      },
      parse: function parse(path) {
        assertPath(path);
        var ret = { root: "", dir: "", base: "", ext: "", name: "" };
        if (path.length === 0)
          return ret;
        var code = path.charCodeAt(0);
        var isAbsolute = code === 47;
        var start;
        if (isAbsolute) {
          ret.root = "/";
          start = 1;
        } else {
          start = 0;
        }
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var i = path.length - 1;
        var preDotState = 0;
        for (; i >= start; --i) {
          code = path.charCodeAt(i);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          if (end !== -1) {
            if (startPart === 0 && isAbsolute)
              ret.base = ret.name = path.slice(1, end);
            else
              ret.base = ret.name = path.slice(startPart, end);
          }
        } else {
          if (startPart === 0 && isAbsolute) {
            ret.name = path.slice(1, startDot);
            ret.base = path.slice(1, end);
          } else {
            ret.name = path.slice(startPart, startDot);
            ret.base = path.slice(startPart, end);
          }
          ret.ext = path.slice(startDot, end);
        }
        if (startPart > 0)
          ret.dir = path.slice(0, startPart - 1);
        else if (isAbsolute)
          ret.dir = "/";
        return ret;
      },
      sep: "/",
      delimiter: ":",
      win32: null,
      posix: null
    };
    posix.posix = posix;
    module.exports = posix;
  }
});

// node_modules/diff/lib/diff/base.js
var require_base = __commonJS({
  "node_modules/diff/lib/diff/base.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = Diff;
    function Diff() {
    }
    Diff.prototype = {
      /*istanbul ignore start*/
      /*istanbul ignore end*/
      diff: function diff(oldString, newString) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var callback = options.callback;
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        this.options = options;
        var self2 = this;
        function done(value) {
          if (callback) {
            setTimeout(function() {
              callback(void 0, value);
            }, 0);
            return true;
          } else {
            return value;
          }
        }
        oldString = this.castInput(oldString);
        newString = this.castInput(newString);
        oldString = this.removeEmpty(this.tokenize(oldString));
        newString = this.removeEmpty(this.tokenize(newString));
        var newLen = newString.length, oldLen = oldString.length;
        var editLength = 1;
        var maxEditLength = newLen + oldLen;
        var bestPath = [{
          newPos: -1,
          components: []
        }];
        var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);
        if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
          return done([{
            value: this.join(newString),
            count: newString.length
          }]);
        }
        function execEditLength() {
          for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
            var basePath = (
              /*istanbul ignore start*/
              void 0
            );
            var addPath = bestPath[diagonalPath - 1], removePath = bestPath[diagonalPath + 1], _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;
            if (addPath) {
              bestPath[diagonalPath - 1] = void 0;
            }
            var canAdd = addPath && addPath.newPos + 1 < newLen, canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;
            if (!canAdd && !canRemove) {
              bestPath[diagonalPath] = void 0;
              continue;
            }
            if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {
              basePath = clonePath(removePath);
              self2.pushComponent(basePath.components, void 0, true);
            } else {
              basePath = addPath;
              basePath.newPos++;
              self2.pushComponent(basePath.components, true, void 0);
            }
            _oldPos = self2.extractCommon(basePath, newString, oldString, diagonalPath);
            if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {
              return done(buildValues(self2, basePath.components, newString, oldString, self2.useLongestToken));
            } else {
              bestPath[diagonalPath] = basePath;
            }
          }
          editLength++;
        }
        if (callback) {
          (function exec() {
            setTimeout(function() {
              if (editLength > maxEditLength) {
                return callback();
              }
              if (!execEditLength()) {
                exec();
              }
            }, 0);
          })();
        } else {
          while (editLength <= maxEditLength) {
            var ret = execEditLength();
            if (ret) {
              return ret;
            }
          }
        }
      },
      /*istanbul ignore start*/
      /*istanbul ignore end*/
      pushComponent: function pushComponent(components, added, removed) {
        var last = components[components.length - 1];
        if (last && last.added === added && last.removed === removed) {
          components[components.length - 1] = {
            count: last.count + 1,
            added,
            removed
          };
        } else {
          components.push({
            count: 1,
            added,
            removed
          });
        }
      },
      /*istanbul ignore start*/
      /*istanbul ignore end*/
      extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {
        var newLen = newString.length, oldLen = oldString.length, newPos = basePath.newPos, oldPos = newPos - diagonalPath, commonCount = 0;
        while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
          newPos++;
          oldPos++;
          commonCount++;
        }
        if (commonCount) {
          basePath.components.push({
            count: commonCount
          });
        }
        basePath.newPos = newPos;
        return oldPos;
      },
      /*istanbul ignore start*/
      /*istanbul ignore end*/
      equals: function equals(left, right) {
        if (this.options.comparator) {
          return this.options.comparator(left, right);
        } else {
          return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();
        }
      },
      /*istanbul ignore start*/
      /*istanbul ignore end*/
      removeEmpty: function removeEmpty(array) {
        var ret = [];
        for (var i = 0; i < array.length; i++) {
          if (array[i]) {
            ret.push(array[i]);
          }
        }
        return ret;
      },
      /*istanbul ignore start*/
      /*istanbul ignore end*/
      castInput: function castInput(value) {
        return value;
      },
      /*istanbul ignore start*/
      /*istanbul ignore end*/
      tokenize: function tokenize(value) {
        return value.split("");
      },
      /*istanbul ignore start*/
      /*istanbul ignore end*/
      join: function join(chars) {
        return chars.join("");
      }
    };
    function buildValues(diff, components, newString, oldString, useLongestToken) {
      var componentPos = 0, componentLen = components.length, newPos = 0, oldPos = 0;
      for (; componentPos < componentLen; componentPos++) {
        var component = components[componentPos];
        if (!component.removed) {
          if (!component.added && useLongestToken) {
            var value = newString.slice(newPos, newPos + component.count);
            value = value.map(function(value2, i) {
              var oldValue = oldString[oldPos + i];
              return oldValue.length > value2.length ? oldValue : value2;
            });
            component.value = diff.join(value);
          } else {
            component.value = diff.join(newString.slice(newPos, newPos + component.count));
          }
          newPos += component.count;
          if (!component.added) {
            oldPos += component.count;
          }
        } else {
          component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));
          oldPos += component.count;
          if (componentPos && components[componentPos - 1].added) {
            var tmp = components[componentPos - 1];
            components[componentPos - 1] = components[componentPos];
            components[componentPos] = tmp;
          }
        }
      }
      var lastComponent = components[componentLen - 1];
      if (componentLen > 1 && typeof lastComponent.value === "string" && (lastComponent.added || lastComponent.removed) && diff.equals("", lastComponent.value)) {
        components[componentLen - 2].value += lastComponent.value;
        components.pop();
      }
      return components;
    }
    function clonePath(path) {
      return {
        newPos: path.newPos,
        components: path.components.slice(0)
      };
    }
  }
});

// node_modules/diff/lib/diff/character.js
var require_character = __commonJS({
  "node_modules/diff/lib/diff/character.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.diffChars = diffChars;
    exports.characterDiff = void 0;
    var _base = _interopRequireDefault(require_base());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var characterDiff = new /*istanbul ignore start*/
    _base[
      /*istanbul ignore start*/
      "default"
      /*istanbul ignore end*/
    ]();
    exports.characterDiff = characterDiff;
    function diffChars(oldStr, newStr, options) {
      return characterDiff.diff(oldStr, newStr, options);
    }
  }
});

// node_modules/diff/lib/util/params.js
var require_params = __commonJS({
  "node_modules/diff/lib/util/params.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.generateOptions = generateOptions;
    function generateOptions(options, defaults) {
      if (typeof options === "function") {
        defaults.callback = options;
      } else if (options) {
        for (var name in options) {
          if (options.hasOwnProperty(name)) {
            defaults[name] = options[name];
          }
        }
      }
      return defaults;
    }
  }
});

// node_modules/diff/lib/diff/word.js
var require_word = __commonJS({
  "node_modules/diff/lib/diff/word.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.diffWords = diffWords;
    exports.diffWordsWithSpace = diffWordsWithSpace;
    exports.wordDiff = void 0;
    var _base = _interopRequireDefault(require_base());
    var _params = require_params();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var extendedWordChars = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/;
    var reWhitespace = /\S/;
    var wordDiff = new /*istanbul ignore start*/
    _base[
      /*istanbul ignore start*/
      "default"
      /*istanbul ignore end*/
    ]();
    exports.wordDiff = wordDiff;
    wordDiff.equals = function(left, right) {
      if (this.options.ignoreCase) {
        left = left.toLowerCase();
        right = right.toLowerCase();
      }
      return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);
    };
    wordDiff.tokenize = function(value) {
      var tokens = value.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/);
      for (var i = 0; i < tokens.length - 1; i++) {
        if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {
          tokens[i] += tokens[i + 2];
          tokens.splice(i + 1, 2);
          i--;
        }
      }
      return tokens;
    };
    function diffWords(oldStr, newStr, options) {
      options = /*istanbul ignore start*/
      (0, /*istanbul ignore end*/
      /*istanbul ignore start*/
      _params.generateOptions)(options, {
        ignoreWhitespace: true
      });
      return wordDiff.diff(oldStr, newStr, options);
    }
    function diffWordsWithSpace(oldStr, newStr, options) {
      return wordDiff.diff(oldStr, newStr, options);
    }
  }
});

// node_modules/diff/lib/diff/line.js
var require_line = __commonJS({
  "node_modules/diff/lib/diff/line.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.diffLines = diffLines;
    exports.diffTrimmedLines = diffTrimmedLines;
    exports.lineDiff = void 0;
    var _base = _interopRequireDefault(require_base());
    var _params = require_params();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var lineDiff = new /*istanbul ignore start*/
    _base[
      /*istanbul ignore start*/
      "default"
      /*istanbul ignore end*/
    ]();
    exports.lineDiff = lineDiff;
    lineDiff.tokenize = function(value) {
      var retLines = [], linesAndNewlines = value.split(/(\n|\r\n)/);
      if (!linesAndNewlines[linesAndNewlines.length - 1]) {
        linesAndNewlines.pop();
      }
      for (var i = 0; i < linesAndNewlines.length; i++) {
        var line = linesAndNewlines[i];
        if (i % 2 && !this.options.newlineIsToken) {
          retLines[retLines.length - 1] += line;
        } else {
          if (this.options.ignoreWhitespace) {
            line = line.trim();
          }
          retLines.push(line);
        }
      }
      return retLines;
    };
    function diffLines(oldStr, newStr, callback) {
      return lineDiff.diff(oldStr, newStr, callback);
    }
    function diffTrimmedLines(oldStr, newStr, callback) {
      var options = (
        /*istanbul ignore start*/
        (0, /*istanbul ignore end*/
        /*istanbul ignore start*/
        _params.generateOptions)(callback, {
          ignoreWhitespace: true
        })
      );
      return lineDiff.diff(oldStr, newStr, options);
    }
  }
});

// node_modules/diff/lib/diff/sentence.js
var require_sentence = __commonJS({
  "node_modules/diff/lib/diff/sentence.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.diffSentences = diffSentences;
    exports.sentenceDiff = void 0;
    var _base = _interopRequireDefault(require_base());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var sentenceDiff = new /*istanbul ignore start*/
    _base[
      /*istanbul ignore start*/
      "default"
      /*istanbul ignore end*/
    ]();
    exports.sentenceDiff = sentenceDiff;
    sentenceDiff.tokenize = function(value) {
      return value.split(/(\S.+?[.!?])(?=\s+|$)/);
    };
    function diffSentences(oldStr, newStr, callback) {
      return sentenceDiff.diff(oldStr, newStr, callback);
    }
  }
});

// node_modules/diff/lib/diff/css.js
var require_css = __commonJS({
  "node_modules/diff/lib/diff/css.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.diffCss = diffCss;
    exports.cssDiff = void 0;
    var _base = _interopRequireDefault(require_base());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var cssDiff = new /*istanbul ignore start*/
    _base[
      /*istanbul ignore start*/
      "default"
      /*istanbul ignore end*/
    ]();
    exports.cssDiff = cssDiff;
    cssDiff.tokenize = function(value) {
      return value.split(/([{}:;,]|\s+)/);
    };
    function diffCss(oldStr, newStr, callback) {
      return cssDiff.diff(oldStr, newStr, callback);
    }
  }
});

// node_modules/diff/lib/diff/json.js
var require_json = __commonJS({
  "node_modules/diff/lib/diff/json.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.diffJson = diffJson;
    exports.canonicalize = canonicalize;
    exports.jsonDiff = void 0;
    var _base = _interopRequireDefault(require_base());
    var _line = require_line();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    var objectPrototypeToString = Object.prototype.toString;
    var jsonDiff = new /*istanbul ignore start*/
    _base[
      /*istanbul ignore start*/
      "default"
      /*istanbul ignore end*/
    ]();
    exports.jsonDiff = jsonDiff;
    jsonDiff.useLongestToken = true;
    jsonDiff.tokenize = /*istanbul ignore start*/
    _line.lineDiff.tokenize;
    jsonDiff.castInput = function(value) {
      var _this$options = (
        /*istanbul ignore end*/
        this.options
      ), undefinedReplacement = _this$options.undefinedReplacement, _this$options$stringi = _this$options.stringifyReplacer, stringifyReplacer = _this$options$stringi === void 0 ? function(k, v) {
        return (
          /*istanbul ignore end*/
          typeof v === "undefined" ? undefinedReplacement : v
        );
      } : _this$options$stringi;
      return typeof value === "string" ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, "  ");
    };
    jsonDiff.equals = function(left, right) {
      return (
        /*istanbul ignore start*/
        _base[
          /*istanbul ignore start*/
          "default"
          /*istanbul ignore end*/
        ].prototype.equals.call(jsonDiff, left.replace(/,([\r\n])/g, "$1"), right.replace(/,([\r\n])/g, "$1"))
      );
    };
    function diffJson(oldObj, newObj, options) {
      return jsonDiff.diff(oldObj, newObj, options);
    }
    function canonicalize(obj, stack, replacementStack, replacer, key) {
      stack = stack || [];
      replacementStack = replacementStack || [];
      if (replacer) {
        obj = replacer(key, obj);
      }
      var i;
      for (i = 0; i < stack.length; i += 1) {
        if (stack[i] === obj) {
          return replacementStack[i];
        }
      }
      var canonicalizedObj;
      if ("[object Array]" === objectPrototypeToString.call(obj)) {
        stack.push(obj);
        canonicalizedObj = new Array(obj.length);
        replacementStack.push(canonicalizedObj);
        for (i = 0; i < obj.length; i += 1) {
          canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);
        }
        stack.pop();
        replacementStack.pop();
        return canonicalizedObj;
      }
      if (obj && obj.toJSON) {
        obj = obj.toJSON();
      }
      if (
        /*istanbul ignore start*/
        _typeof(
          /*istanbul ignore end*/
          obj
        ) === "object" && obj !== null
      ) {
        stack.push(obj);
        canonicalizedObj = {};
        replacementStack.push(canonicalizedObj);
        var sortedKeys = [], _key;
        for (_key in obj) {
          if (obj.hasOwnProperty(_key)) {
            sortedKeys.push(_key);
          }
        }
        sortedKeys.sort();
        for (i = 0; i < sortedKeys.length; i += 1) {
          _key = sortedKeys[i];
          canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);
        }
        stack.pop();
        replacementStack.pop();
      } else {
        canonicalizedObj = obj;
      }
      return canonicalizedObj;
    }
  }
});

// node_modules/diff/lib/diff/array.js
var require_array = __commonJS({
  "node_modules/diff/lib/diff/array.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.diffArrays = diffArrays;
    exports.arrayDiff = void 0;
    var _base = _interopRequireDefault(require_base());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var arrayDiff = new /*istanbul ignore start*/
    _base[
      /*istanbul ignore start*/
      "default"
      /*istanbul ignore end*/
    ]();
    exports.arrayDiff = arrayDiff;
    arrayDiff.tokenize = function(value) {
      return value.slice();
    };
    arrayDiff.join = arrayDiff.removeEmpty = function(value) {
      return value;
    };
    function diffArrays(oldArr, newArr, callback) {
      return arrayDiff.diff(oldArr, newArr, callback);
    }
  }
});

// node_modules/diff/lib/patch/parse.js
var require_parse = __commonJS({
  "node_modules/diff/lib/patch/parse.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.parsePatch = parsePatch;
    function parsePatch(uniDiff) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var diffstr = uniDiff.split(/\r\n|[\n\v\f\r\x85]/), delimiters = uniDiff.match(/\r\n|[\n\v\f\r\x85]/g) || [], list = [], i = 0;
      function parseIndex() {
        var index = {};
        list.push(index);
        while (i < diffstr.length) {
          var line = diffstr[i];
          if (/^(\-\-\-|\+\+\+|@@)\s/.test(line)) {
            break;
          }
          var header = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(line);
          if (header) {
            index.index = header[1];
          }
          i++;
        }
        parseFileHeader(index);
        parseFileHeader(index);
        index.hunks = [];
        while (i < diffstr.length) {
          var _line = diffstr[i];
          if (/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(_line)) {
            break;
          } else if (/^@@/.test(_line)) {
            index.hunks.push(parseHunk());
          } else if (_line && options.strict) {
            throw new Error("Unknown line " + (i + 1) + " " + JSON.stringify(_line));
          } else {
            i++;
          }
        }
      }
      function parseFileHeader(index) {
        var fileHeader = /^(---|\+\+\+)\s+(.*)$/.exec(diffstr[i]);
        if (fileHeader) {
          var keyPrefix = fileHeader[1] === "---" ? "old" : "new";
          var data = fileHeader[2].split("	", 2);
          var fileName = data[0].replace(/\\\\/g, "\\");
          if (/^".*"$/.test(fileName)) {
            fileName = fileName.substr(1, fileName.length - 2);
          }
          index[keyPrefix + "FileName"] = fileName;
          index[keyPrefix + "Header"] = (data[1] || "").trim();
          i++;
        }
      }
      function parseHunk() {
        var chunkHeaderIndex = i, chunkHeaderLine = diffstr[i++], chunkHeader = chunkHeaderLine.split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/);
        var hunk = {
          oldStart: +chunkHeader[1],
          oldLines: typeof chunkHeader[2] === "undefined" ? 1 : +chunkHeader[2],
          newStart: +chunkHeader[3],
          newLines: typeof chunkHeader[4] === "undefined" ? 1 : +chunkHeader[4],
          lines: [],
          linedelimiters: []
        };
        if (hunk.oldLines === 0) {
          hunk.oldStart += 1;
        }
        if (hunk.newLines === 0) {
          hunk.newStart += 1;
        }
        var addCount = 0, removeCount = 0;
        for (; i < diffstr.length; i++) {
          if (diffstr[i].indexOf("--- ") === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf("+++ ") === 0 && diffstr[i + 2].indexOf("@@") === 0) {
            break;
          }
          var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? " " : diffstr[i][0];
          if (operation === "+" || operation === "-" || operation === " " || operation === "\\") {
            hunk.lines.push(diffstr[i]);
            hunk.linedelimiters.push(delimiters[i] || "\n");
            if (operation === "+") {
              addCount++;
            } else if (operation === "-") {
              removeCount++;
            } else if (operation === " ") {
              addCount++;
              removeCount++;
            }
          } else {
            break;
          }
        }
        if (!addCount && hunk.newLines === 1) {
          hunk.newLines = 0;
        }
        if (!removeCount && hunk.oldLines === 1) {
          hunk.oldLines = 0;
        }
        if (options.strict) {
          if (addCount !== hunk.newLines) {
            throw new Error("Added line count did not match for hunk at line " + (chunkHeaderIndex + 1));
          }
          if (removeCount !== hunk.oldLines) {
            throw new Error("Removed line count did not match for hunk at line " + (chunkHeaderIndex + 1));
          }
        }
        return hunk;
      }
      while (i < diffstr.length) {
        parseIndex();
      }
      return list;
    }
  }
});

// node_modules/diff/lib/util/distance-iterator.js
var require_distance_iterator = __commonJS({
  "node_modules/diff/lib/util/distance-iterator.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = _default;
    function _default(start, minLine, maxLine) {
      var wantForward = true, backwardExhausted = false, forwardExhausted = false, localOffset = 1;
      return function iterator() {
        if (wantForward && !forwardExhausted) {
          if (backwardExhausted) {
            localOffset++;
          } else {
            wantForward = false;
          }
          if (start + localOffset <= maxLine) {
            return localOffset;
          }
          forwardExhausted = true;
        }
        if (!backwardExhausted) {
          if (!forwardExhausted) {
            wantForward = true;
          }
          if (minLine <= start - localOffset) {
            return -localOffset++;
          }
          backwardExhausted = true;
          return iterator();
        }
      };
    }
  }
});

// node_modules/diff/lib/patch/apply.js
var require_apply = __commonJS({
  "node_modules/diff/lib/patch/apply.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.applyPatch = applyPatch;
    exports.applyPatches = applyPatches;
    var _parse = require_parse();
    var _distanceIterator = _interopRequireDefault(require_distance_iterator());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function applyPatch(source, uniDiff) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      if (typeof uniDiff === "string") {
        uniDiff = /*istanbul ignore start*/
        (0, /*istanbul ignore end*/
        /*istanbul ignore start*/
        _parse.parsePatch)(uniDiff);
      }
      if (Array.isArray(uniDiff)) {
        if (uniDiff.length > 1) {
          throw new Error("applyPatch only works with a single input.");
        }
        uniDiff = uniDiff[0];
      }
      var lines = source.split(/\r\n|[\n\v\f\r\x85]/), delimiters = source.match(/\r\n|[\n\v\f\r\x85]/g) || [], hunks = uniDiff.hunks, compareLine = options.compareLine || function(lineNumber, line2, operation2, patchContent) {
        return (
          /*istanbul ignore end*/
          line2 === patchContent
        );
      }, errorCount = 0, fuzzFactor = options.fuzzFactor || 0, minLine = 0, offset = 0, removeEOFNL, addEOFNL;
      function hunkFits(hunk2, toPos2) {
        for (var j2 = 0; j2 < hunk2.lines.length; j2++) {
          var line2 = hunk2.lines[j2], operation2 = line2.length > 0 ? line2[0] : " ", content2 = line2.length > 0 ? line2.substr(1) : line2;
          if (operation2 === " " || operation2 === "-") {
            if (!compareLine(toPos2 + 1, lines[toPos2], operation2, content2)) {
              errorCount++;
              if (errorCount > fuzzFactor) {
                return false;
              }
            }
            toPos2++;
          }
        }
        return true;
      }
      for (var i = 0; i < hunks.length; i++) {
        var hunk = hunks[i], maxLine = lines.length - hunk.oldLines, localOffset = 0, toPos = offset + hunk.oldStart - 1;
        var iterator = (
          /*istanbul ignore start*/
          (0, /*istanbul ignore end*/
          /*istanbul ignore start*/
          _distanceIterator[
            /*istanbul ignore start*/
            "default"
            /*istanbul ignore end*/
          ])(toPos, minLine, maxLine)
        );
        for (; localOffset !== void 0; localOffset = iterator()) {
          if (hunkFits(hunk, toPos + localOffset)) {
            hunk.offset = offset += localOffset;
            break;
          }
        }
        if (localOffset === void 0) {
          return false;
        }
        minLine = hunk.offset + hunk.oldStart + hunk.oldLines;
      }
      var diffOffset = 0;
      for (var _i = 0; _i < hunks.length; _i++) {
        var _hunk = hunks[_i], _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;
        diffOffset += _hunk.newLines - _hunk.oldLines;
        for (var j = 0; j < _hunk.lines.length; j++) {
          var line = _hunk.lines[j], operation = line.length > 0 ? line[0] : " ", content = line.length > 0 ? line.substr(1) : line, delimiter = _hunk.linedelimiters[j];
          if (operation === " ") {
            _toPos++;
          } else if (operation === "-") {
            lines.splice(_toPos, 1);
            delimiters.splice(_toPos, 1);
          } else if (operation === "+") {
            lines.splice(_toPos, 0, content);
            delimiters.splice(_toPos, 0, delimiter);
            _toPos++;
          } else if (operation === "\\") {
            var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;
            if (previousOperation === "+") {
              removeEOFNL = true;
            } else if (previousOperation === "-") {
              addEOFNL = true;
            }
          }
        }
      }
      if (removeEOFNL) {
        while (!lines[lines.length - 1]) {
          lines.pop();
          delimiters.pop();
        }
      } else if (addEOFNL) {
        lines.push("");
        delimiters.push("\n");
      }
      for (var _k = 0; _k < lines.length - 1; _k++) {
        lines[_k] = lines[_k] + delimiters[_k];
      }
      return lines.join("");
    }
    function applyPatches(uniDiff, options) {
      if (typeof uniDiff === "string") {
        uniDiff = /*istanbul ignore start*/
        (0, /*istanbul ignore end*/
        /*istanbul ignore start*/
        _parse.parsePatch)(uniDiff);
      }
      var currentIndex = 0;
      function processIndex() {
        var index = uniDiff[currentIndex++];
        if (!index) {
          return options.complete();
        }
        options.loadFile(index, function(err, data) {
          if (err) {
            return options.complete(err);
          }
          var updatedContent = applyPatch(data, index, options);
          options.patched(index, updatedContent, function(err2) {
            if (err2) {
              return options.complete(err2);
            }
            processIndex();
          });
        });
      }
      processIndex();
    }
  }
});

// node_modules/diff/lib/patch/create.js
var require_create = __commonJS({
  "node_modules/diff/lib/patch/create.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.structuredPatch = structuredPatch;
    exports.formatPatch = formatPatch;
    exports.createTwoFilesPatch = createTwoFilesPatch;
    exports.createPatch = createPatch;
    var _line = require_line();
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
        return Array.from(iter);
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
      if (!options) {
        options = {};
      }
      if (typeof options.context === "undefined") {
        options.context = 4;
      }
      var diff = (
        /*istanbul ignore start*/
        (0, /*istanbul ignore end*/
        /*istanbul ignore start*/
        _line.diffLines)(oldStr, newStr, options)
      );
      diff.push({
        value: "",
        lines: []
      });
      function contextLines(lines) {
        return lines.map(function(entry) {
          return " " + entry;
        });
      }
      var hunks = [];
      var oldRangeStart = 0, newRangeStart = 0, curRange = [], oldLine = 1, newLine = 1;
      var _loop = function _loop2(i2) {
        var current = diff[i2], lines = current.lines || current.value.replace(/\n$/, "").split("\n");
        current.lines = lines;
        if (current.added || current.removed) {
          var _curRange;
          if (!oldRangeStart) {
            var prev = diff[i2 - 1];
            oldRangeStart = oldLine;
            newRangeStart = newLine;
            if (prev) {
              curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];
              oldRangeStart -= curRange.length;
              newRangeStart -= curRange.length;
            }
          }
          (_curRange = /*istanbul ignore end*/
          curRange).push.apply(
            /*istanbul ignore start*/
            _curRange,
            /*istanbul ignore start*/
            _toConsumableArray(
              /*istanbul ignore end*/
              lines.map(function(entry) {
                return (current.added ? "+" : "-") + entry;
              })
            )
          );
          if (current.added) {
            newLine += lines.length;
          } else {
            oldLine += lines.length;
          }
        } else {
          if (oldRangeStart) {
            if (lines.length <= options.context * 2 && i2 < diff.length - 2) {
              var _curRange2;
              (_curRange2 = /*istanbul ignore end*/
              curRange).push.apply(
                /*istanbul ignore start*/
                _curRange2,
                /*istanbul ignore start*/
                _toConsumableArray(
                  /*istanbul ignore end*/
                  contextLines(lines)
                )
              );
            } else {
              var _curRange3;
              var contextSize = Math.min(lines.length, options.context);
              (_curRange3 = /*istanbul ignore end*/
              curRange).push.apply(
                /*istanbul ignore start*/
                _curRange3,
                /*istanbul ignore start*/
                _toConsumableArray(
                  /*istanbul ignore end*/
                  contextLines(lines.slice(0, contextSize))
                )
              );
              var hunk = {
                oldStart: oldRangeStart,
                oldLines: oldLine - oldRangeStart + contextSize,
                newStart: newRangeStart,
                newLines: newLine - newRangeStart + contextSize,
                lines: curRange
              };
              if (i2 >= diff.length - 2 && lines.length <= options.context) {
                var oldEOFNewline = /\n$/.test(oldStr);
                var newEOFNewline = /\n$/.test(newStr);
                var noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;
                if (!oldEOFNewline && noNlBeforeAdds && oldStr.length > 0) {
                  curRange.splice(hunk.oldLines, 0, "\\ No newline at end of file");
                }
                if (!oldEOFNewline && !noNlBeforeAdds || !newEOFNewline) {
                  curRange.push("\\ No newline at end of file");
                }
              }
              hunks.push(hunk);
              oldRangeStart = 0;
              newRangeStart = 0;
              curRange = [];
            }
          }
          oldLine += lines.length;
          newLine += lines.length;
        }
      };
      for (var i = 0; i < diff.length; i++) {
        _loop(
          /*istanbul ignore end*/
          i
        );
      }
      return {
        oldFileName,
        newFileName,
        oldHeader,
        newHeader,
        hunks
      };
    }
    function formatPatch(diff) {
      var ret = [];
      if (diff.oldFileName == diff.newFileName) {
        ret.push("Index: " + diff.oldFileName);
      }
      ret.push("===================================================================");
      ret.push("--- " + diff.oldFileName + (typeof diff.oldHeader === "undefined" ? "" : "	" + diff.oldHeader));
      ret.push("+++ " + diff.newFileName + (typeof diff.newHeader === "undefined" ? "" : "	" + diff.newHeader));
      for (var i = 0; i < diff.hunks.length; i++) {
        var hunk = diff.hunks[i];
        if (hunk.oldLines === 0) {
          hunk.oldStart -= 1;
        }
        if (hunk.newLines === 0) {
          hunk.newStart -= 1;
        }
        ret.push("@@ -" + hunk.oldStart + "," + hunk.oldLines + " +" + hunk.newStart + "," + hunk.newLines + " @@");
        ret.push.apply(ret, hunk.lines);
      }
      return ret.join("\n") + "\n";
    }
    function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
      return formatPatch(structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options));
    }
    function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {
      return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);
    }
  }
});

// node_modules/diff/lib/util/array.js
var require_array2 = __commonJS({
  "node_modules/diff/lib/util/array.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.arrayEqual = arrayEqual;
    exports.arrayStartsWith = arrayStartsWith;
    function arrayEqual(a, b) {
      if (a.length !== b.length) {
        return false;
      }
      return arrayStartsWith(a, b);
    }
    function arrayStartsWith(array, start) {
      if (start.length > array.length) {
        return false;
      }
      for (var i = 0; i < start.length; i++) {
        if (start[i] !== array[i]) {
          return false;
        }
      }
      return true;
    }
  }
});

// node_modules/diff/lib/patch/merge.js
var require_merge = __commonJS({
  "node_modules/diff/lib/patch/merge.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.calcLineCount = calcLineCount;
    exports.merge = merge;
    var _create = require_create();
    var _parse = require_parse();
    var _array = require_array2();
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
        return Array.from(iter);
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function calcLineCount(hunk) {
      var _calcOldNewLineCount = (
        /*istanbul ignore end*/
        calcOldNewLineCount(hunk.lines)
      ), oldLines = _calcOldNewLineCount.oldLines, newLines = _calcOldNewLineCount.newLines;
      if (oldLines !== void 0) {
        hunk.oldLines = oldLines;
      } else {
        delete hunk.oldLines;
      }
      if (newLines !== void 0) {
        hunk.newLines = newLines;
      } else {
        delete hunk.newLines;
      }
    }
    function merge(mine, theirs, base) {
      mine = loadPatch(mine, base);
      theirs = loadPatch(theirs, base);
      var ret = {};
      if (mine.index || theirs.index) {
        ret.index = mine.index || theirs.index;
      }
      if (mine.newFileName || theirs.newFileName) {
        if (!fileNameChanged(mine)) {
          ret.oldFileName = theirs.oldFileName || mine.oldFileName;
          ret.newFileName = theirs.newFileName || mine.newFileName;
          ret.oldHeader = theirs.oldHeader || mine.oldHeader;
          ret.newHeader = theirs.newHeader || mine.newHeader;
        } else if (!fileNameChanged(theirs)) {
          ret.oldFileName = mine.oldFileName;
          ret.newFileName = mine.newFileName;
          ret.oldHeader = mine.oldHeader;
          ret.newHeader = mine.newHeader;
        } else {
          ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);
          ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);
          ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);
          ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);
        }
      }
      ret.hunks = [];
      var mineIndex = 0, theirsIndex = 0, mineOffset = 0, theirsOffset = 0;
      while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {
        var mineCurrent = mine.hunks[mineIndex] || {
          oldStart: Infinity
        }, theirsCurrent = theirs.hunks[theirsIndex] || {
          oldStart: Infinity
        };
        if (hunkBefore(mineCurrent, theirsCurrent)) {
          ret.hunks.push(cloneHunk(mineCurrent, mineOffset));
          mineIndex++;
          theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;
        } else if (hunkBefore(theirsCurrent, mineCurrent)) {
          ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));
          theirsIndex++;
          mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;
        } else {
          var mergedHunk = {
            oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),
            oldLines: 0,
            newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),
            newLines: 0,
            lines: []
          };
          mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);
          theirsIndex++;
          mineIndex++;
          ret.hunks.push(mergedHunk);
        }
      }
      return ret;
    }
    function loadPatch(param, base) {
      if (typeof param === "string") {
        if (/^@@/m.test(param) || /^Index:/m.test(param)) {
          return (
            /*istanbul ignore start*/
            (0, /*istanbul ignore end*/
            /*istanbul ignore start*/
            _parse.parsePatch)(param)[0]
          );
        }
        if (!base) {
          throw new Error("Must provide a base reference or pass in a patch");
        }
        return (
          /*istanbul ignore start*/
          (0, /*istanbul ignore end*/
          /*istanbul ignore start*/
          _create.structuredPatch)(void 0, void 0, base, param)
        );
      }
      return param;
    }
    function fileNameChanged(patch) {
      return patch.newFileName && patch.newFileName !== patch.oldFileName;
    }
    function selectField(index, mine, theirs) {
      if (mine === theirs) {
        return mine;
      } else {
        index.conflict = true;
        return {
          mine,
          theirs
        };
      }
    }
    function hunkBefore(test, check) {
      return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;
    }
    function cloneHunk(hunk, offset) {
      return {
        oldStart: hunk.oldStart,
        oldLines: hunk.oldLines,
        newStart: hunk.newStart + offset,
        newLines: hunk.newLines,
        lines: hunk.lines
      };
    }
    function mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {
      var mine = {
        offset: mineOffset,
        lines: mineLines,
        index: 0
      }, their = {
        offset: theirOffset,
        lines: theirLines,
        index: 0
      };
      insertLeading(hunk, mine, their);
      insertLeading(hunk, their, mine);
      while (mine.index < mine.lines.length && their.index < their.lines.length) {
        var mineCurrent = mine.lines[mine.index], theirCurrent = their.lines[their.index];
        if ((mineCurrent[0] === "-" || mineCurrent[0] === "+") && (theirCurrent[0] === "-" || theirCurrent[0] === "+")) {
          mutualChange(hunk, mine, their);
        } else if (mineCurrent[0] === "+" && theirCurrent[0] === " ") {
          var _hunk$lines;
          (_hunk$lines = /*istanbul ignore end*/
          hunk.lines).push.apply(
            /*istanbul ignore start*/
            _hunk$lines,
            /*istanbul ignore start*/
            _toConsumableArray(
              /*istanbul ignore end*/
              collectChange(mine)
            )
          );
        } else if (theirCurrent[0] === "+" && mineCurrent[0] === " ") {
          var _hunk$lines2;
          (_hunk$lines2 = /*istanbul ignore end*/
          hunk.lines).push.apply(
            /*istanbul ignore start*/
            _hunk$lines2,
            /*istanbul ignore start*/
            _toConsumableArray(
              /*istanbul ignore end*/
              collectChange(their)
            )
          );
        } else if (mineCurrent[0] === "-" && theirCurrent[0] === " ") {
          removal(hunk, mine, their);
        } else if (theirCurrent[0] === "-" && mineCurrent[0] === " ") {
          removal(hunk, their, mine, true);
        } else if (mineCurrent === theirCurrent) {
          hunk.lines.push(mineCurrent);
          mine.index++;
          their.index++;
        } else {
          conflict(hunk, collectChange(mine), collectChange(their));
        }
      }
      insertTrailing(hunk, mine);
      insertTrailing(hunk, their);
      calcLineCount(hunk);
    }
    function mutualChange(hunk, mine, their) {
      var myChanges = collectChange(mine), theirChanges = collectChange(their);
      if (allRemoves(myChanges) && allRemoves(theirChanges)) {
        if (
          /*istanbul ignore start*/
          (0, /*istanbul ignore end*/
          /*istanbul ignore start*/
          _array.arrayStartsWith)(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)
        ) {
          var _hunk$lines3;
          (_hunk$lines3 = /*istanbul ignore end*/
          hunk.lines).push.apply(
            /*istanbul ignore start*/
            _hunk$lines3,
            /*istanbul ignore start*/
            _toConsumableArray(
              /*istanbul ignore end*/
              myChanges
            )
          );
          return;
        } else if (
          /*istanbul ignore start*/
          (0, /*istanbul ignore end*/
          /*istanbul ignore start*/
          _array.arrayStartsWith)(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)
        ) {
          var _hunk$lines4;
          (_hunk$lines4 = /*istanbul ignore end*/
          hunk.lines).push.apply(
            /*istanbul ignore start*/
            _hunk$lines4,
            /*istanbul ignore start*/
            _toConsumableArray(
              /*istanbul ignore end*/
              theirChanges
            )
          );
          return;
        }
      } else if (
        /*istanbul ignore start*/
        (0, /*istanbul ignore end*/
        /*istanbul ignore start*/
        _array.arrayEqual)(myChanges, theirChanges)
      ) {
        var _hunk$lines5;
        (_hunk$lines5 = /*istanbul ignore end*/
        hunk.lines).push.apply(
          /*istanbul ignore start*/
          _hunk$lines5,
          /*istanbul ignore start*/
          _toConsumableArray(
            /*istanbul ignore end*/
            myChanges
          )
        );
        return;
      }
      conflict(hunk, myChanges, theirChanges);
    }
    function removal(hunk, mine, their, swap) {
      var myChanges = collectChange(mine), theirChanges = collectContext(their, myChanges);
      if (theirChanges.merged) {
        var _hunk$lines6;
        (_hunk$lines6 = /*istanbul ignore end*/
        hunk.lines).push.apply(
          /*istanbul ignore start*/
          _hunk$lines6,
          /*istanbul ignore start*/
          _toConsumableArray(
            /*istanbul ignore end*/
            theirChanges.merged
          )
        );
      } else {
        conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);
      }
    }
    function conflict(hunk, mine, their) {
      hunk.conflict = true;
      hunk.lines.push({
        conflict: true,
        mine,
        theirs: their
      });
    }
    function insertLeading(hunk, insert, their) {
      while (insert.offset < their.offset && insert.index < insert.lines.length) {
        var line = insert.lines[insert.index++];
        hunk.lines.push(line);
        insert.offset++;
      }
    }
    function insertTrailing(hunk, insert) {
      while (insert.index < insert.lines.length) {
        var line = insert.lines[insert.index++];
        hunk.lines.push(line);
      }
    }
    function collectChange(state) {
      var ret = [], operation = state.lines[state.index][0];
      while (state.index < state.lines.length) {
        var line = state.lines[state.index];
        if (operation === "-" && line[0] === "+") {
          operation = "+";
        }
        if (operation === line[0]) {
          ret.push(line);
          state.index++;
        } else {
          break;
        }
      }
      return ret;
    }
    function collectContext(state, matchChanges) {
      var changes = [], merged = [], matchIndex = 0, contextChanges = false, conflicted = false;
      while (matchIndex < matchChanges.length && state.index < state.lines.length) {
        var change = state.lines[state.index], match = matchChanges[matchIndex];
        if (match[0] === "+") {
          break;
        }
        contextChanges = contextChanges || change[0] !== " ";
        merged.push(match);
        matchIndex++;
        if (change[0] === "+") {
          conflicted = true;
          while (change[0] === "+") {
            changes.push(change);
            change = state.lines[++state.index];
          }
        }
        if (match.substr(1) === change.substr(1)) {
          changes.push(change);
          state.index++;
        } else {
          conflicted = true;
        }
      }
      if ((matchChanges[matchIndex] || "")[0] === "+" && contextChanges) {
        conflicted = true;
      }
      if (conflicted) {
        return changes;
      }
      while (matchIndex < matchChanges.length) {
        merged.push(matchChanges[matchIndex++]);
      }
      return {
        merged,
        changes
      };
    }
    function allRemoves(changes) {
      return changes.reduce(function(prev, change) {
        return prev && change[0] === "-";
      }, true);
    }
    function skipRemoveSuperset(state, removeChanges, delta) {
      for (var i = 0; i < delta; i++) {
        var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);
        if (state.lines[state.index + i] !== " " + changeContent) {
          return false;
        }
      }
      state.index += delta;
      return true;
    }
    function calcOldNewLineCount(lines) {
      var oldLines = 0;
      var newLines = 0;
      lines.forEach(function(line) {
        if (typeof line !== "string") {
          var myCount = calcOldNewLineCount(line.mine);
          var theirCount = calcOldNewLineCount(line.theirs);
          if (oldLines !== void 0) {
            if (myCount.oldLines === theirCount.oldLines) {
              oldLines += myCount.oldLines;
            } else {
              oldLines = void 0;
            }
          }
          if (newLines !== void 0) {
            if (myCount.newLines === theirCount.newLines) {
              newLines += myCount.newLines;
            } else {
              newLines = void 0;
            }
          }
        } else {
          if (newLines !== void 0 && (line[0] === "+" || line[0] === " ")) {
            newLines++;
          }
          if (oldLines !== void 0 && (line[0] === "-" || line[0] === " ")) {
            oldLines++;
          }
        }
      });
      return {
        oldLines,
        newLines
      };
    }
  }
});

// node_modules/diff/lib/convert/dmp.js
var require_dmp = __commonJS({
  "node_modules/diff/lib/convert/dmp.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.convertChangesToDMP = convertChangesToDMP;
    function convertChangesToDMP(changes) {
      var ret = [], change, operation;
      for (var i = 0; i < changes.length; i++) {
        change = changes[i];
        if (change.added) {
          operation = 1;
        } else if (change.removed) {
          operation = -1;
        } else {
          operation = 0;
        }
        ret.push([operation, change.value]);
      }
      return ret;
    }
  }
});

// node_modules/diff/lib/convert/xml.js
var require_xml = __commonJS({
  "node_modules/diff/lib/convert/xml.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.convertChangesToXML = convertChangesToXML;
    function convertChangesToXML(changes) {
      var ret = [];
      for (var i = 0; i < changes.length; i++) {
        var change = changes[i];
        if (change.added) {
          ret.push("<ins>");
        } else if (change.removed) {
          ret.push("<del>");
        }
        ret.push(escapeHTML(change.value));
        if (change.added) {
          ret.push("</ins>");
        } else if (change.removed) {
          ret.push("</del>");
        }
      }
      return ret.join("");
    }
    function escapeHTML(s) {
      var n = s;
      n = n.replace(/&/g, "&amp;");
      n = n.replace(/</g, "&lt;");
      n = n.replace(/>/g, "&gt;");
      n = n.replace(/"/g, "&quot;");
      return n;
    }
  }
});

// node_modules/diff/lib/index.js
var require_lib = __commonJS({
  "node_modules/diff/lib/index.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "Diff", {
      enumerable: true,
      get: function get() {
        return _base["default"];
      }
    });
    Object.defineProperty(exports, "diffChars", {
      enumerable: true,
      get: function get() {
        return _character.diffChars;
      }
    });
    Object.defineProperty(exports, "diffWords", {
      enumerable: true,
      get: function get() {
        return _word.diffWords;
      }
    });
    Object.defineProperty(exports, "diffWordsWithSpace", {
      enumerable: true,
      get: function get() {
        return _word.diffWordsWithSpace;
      }
    });
    Object.defineProperty(exports, "diffLines", {
      enumerable: true,
      get: function get() {
        return _line.diffLines;
      }
    });
    Object.defineProperty(exports, "diffTrimmedLines", {
      enumerable: true,
      get: function get() {
        return _line.diffTrimmedLines;
      }
    });
    Object.defineProperty(exports, "diffSentences", {
      enumerable: true,
      get: function get() {
        return _sentence.diffSentences;
      }
    });
    Object.defineProperty(exports, "diffCss", {
      enumerable: true,
      get: function get() {
        return _css.diffCss;
      }
    });
    Object.defineProperty(exports, "diffJson", {
      enumerable: true,
      get: function get() {
        return _json.diffJson;
      }
    });
    Object.defineProperty(exports, "canonicalize", {
      enumerable: true,
      get: function get() {
        return _json.canonicalize;
      }
    });
    Object.defineProperty(exports, "diffArrays", {
      enumerable: true,
      get: function get() {
        return _array.diffArrays;
      }
    });
    Object.defineProperty(exports, "applyPatch", {
      enumerable: true,
      get: function get() {
        return _apply.applyPatch;
      }
    });
    Object.defineProperty(exports, "applyPatches", {
      enumerable: true,
      get: function get() {
        return _apply.applyPatches;
      }
    });
    Object.defineProperty(exports, "parsePatch", {
      enumerable: true,
      get: function get() {
        return _parse.parsePatch;
      }
    });
    Object.defineProperty(exports, "merge", {
      enumerable: true,
      get: function get() {
        return _merge.merge;
      }
    });
    Object.defineProperty(exports, "structuredPatch", {
      enumerable: true,
      get: function get() {
        return _create.structuredPatch;
      }
    });
    Object.defineProperty(exports, "createTwoFilesPatch", {
      enumerable: true,
      get: function get() {
        return _create.createTwoFilesPatch;
      }
    });
    Object.defineProperty(exports, "createPatch", {
      enumerable: true,
      get: function get() {
        return _create.createPatch;
      }
    });
    Object.defineProperty(exports, "convertChangesToDMP", {
      enumerable: true,
      get: function get() {
        return _dmp.convertChangesToDMP;
      }
    });
    Object.defineProperty(exports, "convertChangesToXML", {
      enumerable: true,
      get: function get() {
        return _xml.convertChangesToXML;
      }
    });
    var _base = _interopRequireDefault(require_base());
    var _character = require_character();
    var _word = require_word();
    var _line = require_line();
    var _sentence = require_sentence();
    var _css = require_css();
    var _json = require_json();
    var _array = require_array();
    var _apply = require_apply();
    var _parse = require_parse();
    var _merge = require_merge();
    var _create = require_create();
    var _dmp = require_dmp();
    var _xml = require_xml();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
  }
});

// node_modules/mocha/node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/mocha/node_modules/ms/index.js"(exports, module) {
    init_shim();
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/nanoid/non-secure/index.cjs
var require_non_secure = __commonJS({
  "node_modules/nanoid/non-secure/index.cjs"(exports, module) {
    init_shim();
    var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
    var customAlphabet = (alphabet, defaultSize = 21) => {
      return (size = defaultSize) => {
        let id = "";
        let i = size;
        while (i--) {
          id += alphabet[Math.random() * alphabet.length | 0];
        }
        return id;
      };
    };
    var nanoid = (size = 21) => {
      let id = "";
      let i = size;
      while (i--) {
        id += urlAlphabet[Math.random() * 64 | 0];
      }
      return id;
    };
    module.exports = { nanoid, customAlphabet };
  }
});

// node_modules/he/he.js
var require_he = __commonJS({
  "node_modules/he/he.js"(exports, module) {
    init_shim();
    (function(root) {
      var freeExports = typeof exports == "object" && exports;
      var freeModule = typeof module == "object" && module && module.exports == freeExports && module;
      var freeGlobal = typeof _global == "object" && _global;
      if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
        root = freeGlobal;
      }
      var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
      var regexAsciiWhitelist = /[\x01-\x7F]/g;
      var regexBmpWhitelist = /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g;
      var regexEncodeNonAscii = /<\u20D2|=\u20E5|>\u20D2|\u205F\u200A|\u219D\u0338|\u2202\u0338|\u2220\u20D2|\u2229\uFE00|\u222A\uFE00|\u223C\u20D2|\u223D\u0331|\u223E\u0333|\u2242\u0338|\u224B\u0338|\u224D\u20D2|\u224E\u0338|\u224F\u0338|\u2250\u0338|\u2261\u20E5|\u2264\u20D2|\u2265\u20D2|\u2266\u0338|\u2267\u0338|\u2268\uFE00|\u2269\uFE00|\u226A\u0338|\u226A\u20D2|\u226B\u0338|\u226B\u20D2|\u227F\u0338|\u2282\u20D2|\u2283\u20D2|\u228A\uFE00|\u228B\uFE00|\u228F\u0338|\u2290\u0338|\u2293\uFE00|\u2294\uFE00|\u22B4\u20D2|\u22B5\u20D2|\u22D8\u0338|\u22D9\u0338|\u22DA\uFE00|\u22DB\uFE00|\u22F5\u0338|\u22F9\u0338|\u2933\u0338|\u29CF\u0338|\u29D0\u0338|\u2A6D\u0338|\u2A70\u0338|\u2A7D\u0338|\u2A7E\u0338|\u2AA1\u0338|\u2AA2\u0338|\u2AAC\uFE00|\u2AAD\uFE00|\u2AAF\u0338|\u2AB0\u0338|\u2AC5\u0338|\u2AC6\u0338|\u2ACB\uFE00|\u2ACC\uFE00|\u2AFD\u20E5|[\xA0-\u0113\u0116-\u0122\u0124-\u012B\u012E-\u014D\u0150-\u017E\u0192\u01B5\u01F5\u0237\u02C6\u02C7\u02D8-\u02DD\u0311\u0391-\u03A1\u03A3-\u03A9\u03B1-\u03C9\u03D1\u03D2\u03D5\u03D6\u03DC\u03DD\u03F0\u03F1\u03F5\u03F6\u0401-\u040C\u040E-\u044F\u0451-\u045C\u045E\u045F\u2002-\u2005\u2007-\u2010\u2013-\u2016\u2018-\u201A\u201C-\u201E\u2020-\u2022\u2025\u2026\u2030-\u2035\u2039\u203A\u203E\u2041\u2043\u2044\u204F\u2057\u205F-\u2063\u20AC\u20DB\u20DC\u2102\u2105\u210A-\u2113\u2115-\u211E\u2122\u2124\u2127-\u2129\u212C\u212D\u212F-\u2131\u2133-\u2138\u2145-\u2148\u2153-\u215E\u2190-\u219B\u219D-\u21A7\u21A9-\u21AE\u21B0-\u21B3\u21B5-\u21B7\u21BA-\u21DB\u21DD\u21E4\u21E5\u21F5\u21FD-\u2205\u2207-\u2209\u220B\u220C\u220F-\u2214\u2216-\u2218\u221A\u221D-\u2238\u223A-\u2257\u2259\u225A\u225C\u225F-\u2262\u2264-\u228B\u228D-\u229B\u229D-\u22A5\u22A7-\u22B0\u22B2-\u22BB\u22BD-\u22DB\u22DE-\u22E3\u22E6-\u22F7\u22F9-\u22FE\u2305\u2306\u2308-\u2310\u2312\u2313\u2315\u2316\u231C-\u231F\u2322\u2323\u232D\u232E\u2336\u233D\u233F\u237C\u23B0\u23B1\u23B4-\u23B6\u23DC-\u23DF\u23E2\u23E7\u2423\u24C8\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2550-\u256C\u2580\u2584\u2588\u2591-\u2593\u25A1\u25AA\u25AB\u25AD\u25AE\u25B1\u25B3-\u25B5\u25B8\u25B9\u25BD-\u25BF\u25C2\u25C3\u25CA\u25CB\u25EC\u25EF\u25F8-\u25FC\u2605\u2606\u260E\u2640\u2642\u2660\u2663\u2665\u2666\u266A\u266D-\u266F\u2713\u2717\u2720\u2736\u2758\u2772\u2773\u27C8\u27C9\u27E6-\u27ED\u27F5-\u27FA\u27FC\u27FF\u2902-\u2905\u290C-\u2913\u2916\u2919-\u2920\u2923-\u292A\u2933\u2935-\u2939\u293C\u293D\u2945\u2948-\u294B\u294E-\u2976\u2978\u2979\u297B-\u297F\u2985\u2986\u298B-\u2996\u299A\u299C\u299D\u29A4-\u29B7\u29B9\u29BB\u29BC\u29BE-\u29C5\u29C9\u29CD-\u29D0\u29DC-\u29DE\u29E3-\u29E5\u29EB\u29F4\u29F6\u2A00-\u2A02\u2A04\u2A06\u2A0C\u2A0D\u2A10-\u2A17\u2A22-\u2A27\u2A29\u2A2A\u2A2D-\u2A31\u2A33-\u2A3C\u2A3F\u2A40\u2A42-\u2A4D\u2A50\u2A53-\u2A58\u2A5A-\u2A5D\u2A5F\u2A66\u2A6A\u2A6D-\u2A75\u2A77-\u2A9A\u2A9D-\u2AA2\u2AA4-\u2AB0\u2AB3-\u2AC8\u2ACB\u2ACC\u2ACF-\u2ADB\u2AE4\u2AE6-\u2AE9\u2AEB-\u2AF3\u2AFD\uFB00-\uFB04]|\uD835[\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDD6B]/g;
      var encodeMap = { "­": "shy", "‌": "zwnj", "‍": "zwj", "‎": "lrm", "⁣": "ic", "⁢": "it", "⁡": "af", "‏": "rlm", "​": "ZeroWidthSpace", "⁠": "NoBreak", "̑": "DownBreve", "⃛": "tdot", "⃜": "DotDot", "	": "Tab", "\n": "NewLine", " ": "puncsp", " ": "MediumSpace", " ": "thinsp", " ": "hairsp", " ": "emsp13", " ": "ensp", " ": "emsp14", " ": "emsp", " ": "numsp", " ": "nbsp", "  ": "ThickSpace", "‾": "oline", "_": "lowbar", "‐": "dash", "–": "ndash", "—": "mdash", "―": "horbar", ",": "comma", ";": "semi", "⁏": "bsemi", ":": "colon", "⩴": "Colone", "!": "excl", "¡": "iexcl", "?": "quest", "¿": "iquest", ".": "period", "‥": "nldr", "…": "mldr", "·": "middot", "'": "apos", "‘": "lsquo", "’": "rsquo", "‚": "sbquo", "‹": "lsaquo", "›": "rsaquo", '"': "quot", "“": "ldquo", "”": "rdquo", "„": "bdquo", "«": "laquo", "»": "raquo", "(": "lpar", ")": "rpar", "[": "lsqb", "]": "rsqb", "{": "lcub", "}": "rcub", "⌈": "lceil", "⌉": "rceil", "⌊": "lfloor", "⌋": "rfloor", "⦅": "lopar", "⦆": "ropar", "⦋": "lbrke", "⦌": "rbrke", "⦍": "lbrkslu", "⦎": "rbrksld", "⦏": "lbrksld", "⦐": "rbrkslu", "⦑": "langd", "⦒": "rangd", "⦓": "lparlt", "⦔": "rpargt", "⦕": "gtlPar", "⦖": "ltrPar", "⟦": "lobrk", "⟧": "robrk", "⟨": "lang", "⟩": "rang", "⟪": "Lang", "⟫": "Rang", "⟬": "loang", "⟭": "roang", "❲": "lbbrk", "❳": "rbbrk", "‖": "Vert", "§": "sect", "¶": "para", "@": "commat", "*": "ast", "/": "sol", "undefined": null, "&": "amp", "#": "num", "%": "percnt", "‰": "permil", "‱": "pertenk", "†": "dagger", "‡": "Dagger", "•": "bull", "⁃": "hybull", "′": "prime", "″": "Prime", "‴": "tprime", "⁗": "qprime", "‵": "bprime", "⁁": "caret", "`": "grave", "´": "acute", "˜": "tilde", "^": "Hat", "¯": "macr", "˘": "breve", "˙": "dot", "¨": "die", "˚": "ring", "˝": "dblac", "¸": "cedil", "˛": "ogon", "ˆ": "circ", "ˇ": "caron", "°": "deg", "©": "copy", "®": "reg", "℗": "copysr", "℘": "wp", "℞": "rx", "℧": "mho", "℩": "iiota", "←": "larr", "↚": "nlarr", "→": "rarr", "↛": "nrarr", "↑": "uarr", "↓": "darr", "↔": "harr", "↮": "nharr", "↕": "varr", "↖": "nwarr", "↗": "nearr", "↘": "searr", "↙": "swarr", "↝": "rarrw", "↝̸": "nrarrw", "↞": "Larr", "↟": "Uarr", "↠": "Rarr", "↡": "Darr", "↢": "larrtl", "↣": "rarrtl", "↤": "mapstoleft", "↥": "mapstoup", "↦": "map", "↧": "mapstodown", "↩": "larrhk", "↪": "rarrhk", "↫": "larrlp", "↬": "rarrlp", "↭": "harrw", "↰": "lsh", "↱": "rsh", "↲": "ldsh", "↳": "rdsh", "↵": "crarr", "↶": "cularr", "↷": "curarr", "↺": "olarr", "↻": "orarr", "↼": "lharu", "↽": "lhard", "↾": "uharr", "↿": "uharl", "⇀": "rharu", "⇁": "rhard", "⇂": "dharr", "⇃": "dharl", "⇄": "rlarr", "⇅": "udarr", "⇆": "lrarr", "⇇": "llarr", "⇈": "uuarr", "⇉": "rrarr", "⇊": "ddarr", "⇋": "lrhar", "⇌": "rlhar", "⇐": "lArr", "⇍": "nlArr", "⇑": "uArr", "⇒": "rArr", "⇏": "nrArr", "⇓": "dArr", "⇔": "iff", "⇎": "nhArr", "⇕": "vArr", "⇖": "nwArr", "⇗": "neArr", "⇘": "seArr", "⇙": "swArr", "⇚": "lAarr", "⇛": "rAarr", "⇝": "zigrarr", "⇤": "larrb", "⇥": "rarrb", "⇵": "duarr", "⇽": "loarr", "⇾": "roarr", "⇿": "hoarr", "∀": "forall", "∁": "comp", "∂": "part", "∂̸": "npart", "∃": "exist", "∄": "nexist", "∅": "empty", "∇": "Del", "∈": "in", "∉": "notin", "∋": "ni", "∌": "notni", "϶": "bepsi", "∏": "prod", "∐": "coprod", "∑": "sum", "+": "plus", "±": "pm", "÷": "div", "×": "times", "<": "lt", "≮": "nlt", "<⃒": "nvlt", "=": "equals", "≠": "ne", "=⃥": "bne", "⩵": "Equal", ">": "gt", "≯": "ngt", ">⃒": "nvgt", "¬": "not", "|": "vert", "¦": "brvbar", "−": "minus", "∓": "mp", "∔": "plusdo", "⁄": "frasl", "∖": "setmn", "∗": "lowast", "∘": "compfn", "√": "Sqrt", "∝": "prop", "∞": "infin", "∟": "angrt", "∠": "ang", "∠⃒": "nang", "∡": "angmsd", "∢": "angsph", "∣": "mid", "∤": "nmid", "∥": "par", "∦": "npar", "∧": "and", "∨": "or", "∩": "cap", "∩︀": "caps", "∪": "cup", "∪︀": "cups", "∫": "int", "∬": "Int", "∭": "tint", "⨌": "qint", "∮": "oint", "∯": "Conint", "∰": "Cconint", "∱": "cwint", "∲": "cwconint", "∳": "awconint", "∴": "there4", "∵": "becaus", "∶": "ratio", "∷": "Colon", "∸": "minusd", "∺": "mDDot", "∻": "homtht", "∼": "sim", "≁": "nsim", "∼⃒": "nvsim", "∽": "bsim", "∽̱": "race", "∾": "ac", "∾̳": "acE", "∿": "acd", "≀": "wr", "≂": "esim", "≂̸": "nesim", "≃": "sime", "≄": "nsime", "≅": "cong", "≇": "ncong", "≆": "simne", "≈": "ap", "≉": "nap", "≊": "ape", "≋": "apid", "≋̸": "napid", "≌": "bcong", "≍": "CupCap", "≭": "NotCupCap", "≍⃒": "nvap", "≎": "bump", "≎̸": "nbump", "≏": "bumpe", "≏̸": "nbumpe", "≐": "doteq", "≐̸": "nedot", "≑": "eDot", "≒": "efDot", "≓": "erDot", "≔": "colone", "≕": "ecolon", "≖": "ecir", "≗": "cire", "≙": "wedgeq", "≚": "veeeq", "≜": "trie", "≟": "equest", "≡": "equiv", "≢": "nequiv", "≡⃥": "bnequiv", "≤": "le", "≰": "nle", "≤⃒": "nvle", "≥": "ge", "≱": "nge", "≥⃒": "nvge", "≦": "lE", "≦̸": "nlE", "≧": "gE", "≧̸": "ngE", "≨︀": "lvnE", "≨": "lnE", "≩": "gnE", "≩︀": "gvnE", "≪": "ll", "≪̸": "nLtv", "≪⃒": "nLt", "≫": "gg", "≫̸": "nGtv", "≫⃒": "nGt", "≬": "twixt", "≲": "lsim", "≴": "nlsim", "≳": "gsim", "≵": "ngsim", "≶": "lg", "≸": "ntlg", "≷": "gl", "≹": "ntgl", "≺": "pr", "⊀": "npr", "≻": "sc", "⊁": "nsc", "≼": "prcue", "⋠": "nprcue", "≽": "sccue", "⋡": "nsccue", "≾": "prsim", "≿": "scsim", "≿̸": "NotSucceedsTilde", "⊂": "sub", "⊄": "nsub", "⊂⃒": "vnsub", "⊃": "sup", "⊅": "nsup", "⊃⃒": "vnsup", "⊆": "sube", "⊈": "nsube", "⊇": "supe", "⊉": "nsupe", "⊊︀": "vsubne", "⊊": "subne", "⊋︀": "vsupne", "⊋": "supne", "⊍": "cupdot", "⊎": "uplus", "⊏": "sqsub", "⊏̸": "NotSquareSubset", "⊐": "sqsup", "⊐̸": "NotSquareSuperset", "⊑": "sqsube", "⋢": "nsqsube", "⊒": "sqsupe", "⋣": "nsqsupe", "⊓": "sqcap", "⊓︀": "sqcaps", "⊔": "sqcup", "⊔︀": "sqcups", "⊕": "oplus", "⊖": "ominus", "⊗": "otimes", "⊘": "osol", "⊙": "odot", "⊚": "ocir", "⊛": "oast", "⊝": "odash", "⊞": "plusb", "⊟": "minusb", "⊠": "timesb", "⊡": "sdotb", "⊢": "vdash", "⊬": "nvdash", "⊣": "dashv", "⊤": "top", "⊥": "bot", "⊧": "models", "⊨": "vDash", "⊭": "nvDash", "⊩": "Vdash", "⊮": "nVdash", "⊪": "Vvdash", "⊫": "VDash", "⊯": "nVDash", "⊰": "prurel", "⊲": "vltri", "⋪": "nltri", "⊳": "vrtri", "⋫": "nrtri", "⊴": "ltrie", "⋬": "nltrie", "⊴⃒": "nvltrie", "⊵": "rtrie", "⋭": "nrtrie", "⊵⃒": "nvrtrie", "⊶": "origof", "⊷": "imof", "⊸": "mumap", "⊹": "hercon", "⊺": "intcal", "⊻": "veebar", "⊽": "barvee", "⊾": "angrtvb", "⊿": "lrtri", "⋀": "Wedge", "⋁": "Vee", "⋂": "xcap", "⋃": "xcup", "⋄": "diam", "⋅": "sdot", "⋆": "Star", "⋇": "divonx", "⋈": "bowtie", "⋉": "ltimes", "⋊": "rtimes", "⋋": "lthree", "⋌": "rthree", "⋍": "bsime", "⋎": "cuvee", "⋏": "cuwed", "⋐": "Sub", "⋑": "Sup", "⋒": "Cap", "⋓": "Cup", "⋔": "fork", "⋕": "epar", "⋖": "ltdot", "⋗": "gtdot", "⋘": "Ll", "⋘̸": "nLl", "⋙": "Gg", "⋙̸": "nGg", "⋚︀": "lesg", "⋚": "leg", "⋛": "gel", "⋛︀": "gesl", "⋞": "cuepr", "⋟": "cuesc", "⋦": "lnsim", "⋧": "gnsim", "⋨": "prnsim", "⋩": "scnsim", "⋮": "vellip", "⋯": "ctdot", "⋰": "utdot", "⋱": "dtdot", "⋲": "disin", "⋳": "isinsv", "⋴": "isins", "⋵": "isindot", "⋵̸": "notindot", "⋶": "notinvc", "⋷": "notinvb", "⋹": "isinE", "⋹̸": "notinE", "⋺": "nisd", "⋻": "xnis", "⋼": "nis", "⋽": "notnivc", "⋾": "notnivb", "⌅": "barwed", "⌆": "Barwed", "⌌": "drcrop", "⌍": "dlcrop", "⌎": "urcrop", "⌏": "ulcrop", "⌐": "bnot", "⌒": "profline", "⌓": "profsurf", "⌕": "telrec", "⌖": "target", "⌜": "ulcorn", "⌝": "urcorn", "⌞": "dlcorn", "⌟": "drcorn", "⌢": "frown", "⌣": "smile", "⌭": "cylcty", "⌮": "profalar", "⌶": "topbot", "⌽": "ovbar", "⌿": "solbar", "⍼": "angzarr", "⎰": "lmoust", "⎱": "rmoust", "⎴": "tbrk", "⎵": "bbrk", "⎶": "bbrktbrk", "⏜": "OverParenthesis", "⏝": "UnderParenthesis", "⏞": "OverBrace", "⏟": "UnderBrace", "⏢": "trpezium", "⏧": "elinters", "␣": "blank", "─": "boxh", "│": "boxv", "┌": "boxdr", "┐": "boxdl", "└": "boxur", "┘": "boxul", "├": "boxvr", "┤": "boxvl", "┬": "boxhd", "┴": "boxhu", "┼": "boxvh", "═": "boxH", "║": "boxV", "╒": "boxdR", "╓": "boxDr", "╔": "boxDR", "╕": "boxdL", "╖": "boxDl", "╗": "boxDL", "╘": "boxuR", "╙": "boxUr", "╚": "boxUR", "╛": "boxuL", "╜": "boxUl", "╝": "boxUL", "╞": "boxvR", "╟": "boxVr", "╠": "boxVR", "╡": "boxvL", "╢": "boxVl", "╣": "boxVL", "╤": "boxHd", "╥": "boxhD", "╦": "boxHD", "╧": "boxHu", "╨": "boxhU", "╩": "boxHU", "╪": "boxvH", "╫": "boxVh", "╬": "boxVH", "▀": "uhblk", "▄": "lhblk", "█": "block", "░": "blk14", "▒": "blk12", "▓": "blk34", "□": "squ", "▪": "squf", "▫": "EmptyVerySmallSquare", "▭": "rect", "▮": "marker", "▱": "fltns", "△": "xutri", "▴": "utrif", "▵": "utri", "▸": "rtrif", "▹": "rtri", "▽": "xdtri", "▾": "dtrif", "▿": "dtri", "◂": "ltrif", "◃": "ltri", "◊": "loz", "○": "cir", "◬": "tridot", "◯": "xcirc", "◸": "ultri", "◹": "urtri", "◺": "lltri", "◻": "EmptySmallSquare", "◼": "FilledSmallSquare", "★": "starf", "☆": "star", "☎": "phone", "♀": "female", "♂": "male", "♠": "spades", "♣": "clubs", "♥": "hearts", "♦": "diams", "♪": "sung", "✓": "check", "✗": "cross", "✠": "malt", "✶": "sext", "❘": "VerticalSeparator", "⟈": "bsolhsub", "⟉": "suphsol", "⟵": "xlarr", "⟶": "xrarr", "⟷": "xharr", "⟸": "xlArr", "⟹": "xrArr", "⟺": "xhArr", "⟼": "xmap", "⟿": "dzigrarr", "⤂": "nvlArr", "⤃": "nvrArr", "⤄": "nvHarr", "⤅": "Map", "⤌": "lbarr", "⤍": "rbarr", "⤎": "lBarr", "⤏": "rBarr", "⤐": "RBarr", "⤑": "DDotrahd", "⤒": "UpArrowBar", "⤓": "DownArrowBar", "⤖": "Rarrtl", "⤙": "latail", "⤚": "ratail", "⤛": "lAtail", "⤜": "rAtail", "⤝": "larrfs", "⤞": "rarrfs", "⤟": "larrbfs", "⤠": "rarrbfs", "⤣": "nwarhk", "⤤": "nearhk", "⤥": "searhk", "⤦": "swarhk", "⤧": "nwnear", "⤨": "toea", "⤩": "tosa", "⤪": "swnwar", "⤳": "rarrc", "⤳̸": "nrarrc", "⤵": "cudarrr", "⤶": "ldca", "⤷": "rdca", "⤸": "cudarrl", "⤹": "larrpl", "⤼": "curarrm", "⤽": "cularrp", "⥅": "rarrpl", "⥈": "harrcir", "⥉": "Uarrocir", "⥊": "lurdshar", "⥋": "ldrushar", "⥎": "LeftRightVector", "⥏": "RightUpDownVector", "⥐": "DownLeftRightVector", "⥑": "LeftUpDownVector", "⥒": "LeftVectorBar", "⥓": "RightVectorBar", "⥔": "RightUpVectorBar", "⥕": "RightDownVectorBar", "⥖": "DownLeftVectorBar", "⥗": "DownRightVectorBar", "⥘": "LeftUpVectorBar", "⥙": "LeftDownVectorBar", "⥚": "LeftTeeVector", "⥛": "RightTeeVector", "⥜": "RightUpTeeVector", "⥝": "RightDownTeeVector", "⥞": "DownLeftTeeVector", "⥟": "DownRightTeeVector", "⥠": "LeftUpTeeVector", "⥡": "LeftDownTeeVector", "⥢": "lHar", "⥣": "uHar", "⥤": "rHar", "⥥": "dHar", "⥦": "luruhar", "⥧": "ldrdhar", "⥨": "ruluhar", "⥩": "rdldhar", "⥪": "lharul", "⥫": "llhard", "⥬": "rharul", "⥭": "lrhard", "⥮": "udhar", "⥯": "duhar", "⥰": "RoundImplies", "⥱": "erarr", "⥲": "simrarr", "⥳": "larrsim", "⥴": "rarrsim", "⥵": "rarrap", "⥶": "ltlarr", "⥸": "gtrarr", "⥹": "subrarr", "⥻": "suplarr", "⥼": "lfisht", "⥽": "rfisht", "⥾": "ufisht", "⥿": "dfisht", "⦚": "vzigzag", "⦜": "vangrt", "⦝": "angrtvbd", "⦤": "ange", "⦥": "range", "⦦": "dwangle", "⦧": "uwangle", "⦨": "angmsdaa", "⦩": "angmsdab", "⦪": "angmsdac", "⦫": "angmsdad", "⦬": "angmsdae", "⦭": "angmsdaf", "⦮": "angmsdag", "⦯": "angmsdah", "⦰": "bemptyv", "⦱": "demptyv", "⦲": "cemptyv", "⦳": "raemptyv", "⦴": "laemptyv", "⦵": "ohbar", "⦶": "omid", "⦷": "opar", "⦹": "operp", "⦻": "olcross", "⦼": "odsold", "⦾": "olcir", "⦿": "ofcir", "⧀": "olt", "⧁": "ogt", "⧂": "cirscir", "⧃": "cirE", "⧄": "solb", "⧅": "bsolb", "⧉": "boxbox", "⧍": "trisb", "⧎": "rtriltri", "⧏": "LeftTriangleBar", "⧏̸": "NotLeftTriangleBar", "⧐": "RightTriangleBar", "⧐̸": "NotRightTriangleBar", "⧜": "iinfin", "⧝": "infintie", "⧞": "nvinfin", "⧣": "eparsl", "⧤": "smeparsl", "⧥": "eqvparsl", "⧫": "lozf", "⧴": "RuleDelayed", "⧶": "dsol", "⨀": "xodot", "⨁": "xoplus", "⨂": "xotime", "⨄": "xuplus", "⨆": "xsqcup", "⨍": "fpartint", "⨐": "cirfnint", "⨑": "awint", "⨒": "rppolint", "⨓": "scpolint", "⨔": "npolint", "⨕": "pointint", "⨖": "quatint", "⨗": "intlarhk", "⨢": "pluscir", "⨣": "plusacir", "⨤": "simplus", "⨥": "plusdu", "⨦": "plussim", "⨧": "plustwo", "⨩": "mcomma", "⨪": "minusdu", "⨭": "loplus", "⨮": "roplus", "⨯": "Cross", "⨰": "timesd", "⨱": "timesbar", "⨳": "smashp", "⨴": "lotimes", "⨵": "rotimes", "⨶": "otimesas", "⨷": "Otimes", "⨸": "odiv", "⨹": "triplus", "⨺": "triminus", "⨻": "tritime", "⨼": "iprod", "⨿": "amalg", "⩀": "capdot", "⩂": "ncup", "⩃": "ncap", "⩄": "capand", "⩅": "cupor", "⩆": "cupcap", "⩇": "capcup", "⩈": "cupbrcap", "⩉": "capbrcup", "⩊": "cupcup", "⩋": "capcap", "⩌": "ccups", "⩍": "ccaps", "⩐": "ccupssm", "⩓": "And", "⩔": "Or", "⩕": "andand", "⩖": "oror", "⩗": "orslope", "⩘": "andslope", "⩚": "andv", "⩛": "orv", "⩜": "andd", "⩝": "ord", "⩟": "wedbar", "⩦": "sdote", "⩪": "simdot", "⩭": "congdot", "⩭̸": "ncongdot", "⩮": "easter", "⩯": "apacir", "⩰": "apE", "⩰̸": "napE", "⩱": "eplus", "⩲": "pluse", "⩳": "Esim", "⩷": "eDDot", "⩸": "equivDD", "⩹": "ltcir", "⩺": "gtcir", "⩻": "ltquest", "⩼": "gtquest", "⩽": "les", "⩽̸": "nles", "⩾": "ges", "⩾̸": "nges", "⩿": "lesdot", "⪀": "gesdot", "⪁": "lesdoto", "⪂": "gesdoto", "⪃": "lesdotor", "⪄": "gesdotol", "⪅": "lap", "⪆": "gap", "⪇": "lne", "⪈": "gne", "⪉": "lnap", "⪊": "gnap", "⪋": "lEg", "⪌": "gEl", "⪍": "lsime", "⪎": "gsime", "⪏": "lsimg", "⪐": "gsiml", "⪑": "lgE", "⪒": "glE", "⪓": "lesges", "⪔": "gesles", "⪕": "els", "⪖": "egs", "⪗": "elsdot", "⪘": "egsdot", "⪙": "el", "⪚": "eg", "⪝": "siml", "⪞": "simg", "⪟": "simlE", "⪠": "simgE", "⪡": "LessLess", "⪡̸": "NotNestedLessLess", "⪢": "GreaterGreater", "⪢̸": "NotNestedGreaterGreater", "⪤": "glj", "⪥": "gla", "⪦": "ltcc", "⪧": "gtcc", "⪨": "lescc", "⪩": "gescc", "⪪": "smt", "⪫": "lat", "⪬": "smte", "⪬︀": "smtes", "⪭": "late", "⪭︀": "lates", "⪮": "bumpE", "⪯": "pre", "⪯̸": "npre", "⪰": "sce", "⪰̸": "nsce", "⪳": "prE", "⪴": "scE", "⪵": "prnE", "⪶": "scnE", "⪷": "prap", "⪸": "scap", "⪹": "prnap", "⪺": "scnap", "⪻": "Pr", "⪼": "Sc", "⪽": "subdot", "⪾": "supdot", "⪿": "subplus", "⫀": "supplus", "⫁": "submult", "⫂": "supmult", "⫃": "subedot", "⫄": "supedot", "⫅": "subE", "⫅̸": "nsubE", "⫆": "supE", "⫆̸": "nsupE", "⫇": "subsim", "⫈": "supsim", "⫋︀": "vsubnE", "⫋": "subnE", "⫌︀": "vsupnE", "⫌": "supnE", "⫏": "csub", "⫐": "csup", "⫑": "csube", "⫒": "csupe", "⫓": "subsup", "⫔": "supsub", "⫕": "subsub", "⫖": "supsup", "⫗": "suphsub", "⫘": "supdsub", "⫙": "forkv", "⫚": "topfork", "⫛": "mlcp", "⫤": "Dashv", "⫦": "Vdashl", "⫧": "Barv", "⫨": "vBar", "⫩": "vBarv", "⫫": "Vbar", "⫬": "Not", "⫭": "bNot", "⫮": "rnmid", "⫯": "cirmid", "⫰": "midcir", "⫱": "topcir", "⫲": "nhpar", "⫳": "parsim", "⫽": "parsl", "⫽⃥": "nparsl", "♭": "flat", "♮": "natur", "♯": "sharp", "¤": "curren", "¢": "cent", "$": "dollar", "£": "pound", "¥": "yen", "€": "euro", "¹": "sup1", "½": "half", "⅓": "frac13", "¼": "frac14", "⅕": "frac15", "⅙": "frac16", "⅛": "frac18", "²": "sup2", "⅔": "frac23", "⅖": "frac25", "³": "sup3", "¾": "frac34", "⅗": "frac35", "⅜": "frac38", "⅘": "frac45", "⅚": "frac56", "⅝": "frac58", "⅞": "frac78", "𝒶": "ascr", "𝕒": "aopf", "𝔞": "afr", "𝔸": "Aopf", "𝔄": "Afr", "𝒜": "Ascr", "ª": "ordf", "á": "aacute", "Á": "Aacute", "à": "agrave", "À": "Agrave", "ă": "abreve", "Ă": "Abreve", "â": "acirc", "Â": "Acirc", "å": "aring", "Å": "angst", "ä": "auml", "Ä": "Auml", "ã": "atilde", "Ã": "Atilde", "ą": "aogon", "Ą": "Aogon", "ā": "amacr", "Ā": "Amacr", "æ": "aelig", "Æ": "AElig", "𝒷": "bscr", "𝕓": "bopf", "𝔟": "bfr", "𝔹": "Bopf", "ℬ": "Bscr", "𝔅": "Bfr", "𝔠": "cfr", "𝒸": "cscr", "𝕔": "copf", "ℭ": "Cfr", "𝒞": "Cscr", "ℂ": "Copf", "ć": "cacute", "Ć": "Cacute", "ĉ": "ccirc", "Ĉ": "Ccirc", "č": "ccaron", "Č": "Ccaron", "ċ": "cdot", "Ċ": "Cdot", "ç": "ccedil", "Ç": "Ccedil", "℅": "incare", "𝔡": "dfr", "ⅆ": "dd", "𝕕": "dopf", "𝒹": "dscr", "𝒟": "Dscr", "𝔇": "Dfr", "ⅅ": "DD", "𝔻": "Dopf", "ď": "dcaron", "Ď": "Dcaron", "đ": "dstrok", "Đ": "Dstrok", "ð": "eth", "Ð": "ETH", "ⅇ": "ee", "ℯ": "escr", "𝔢": "efr", "𝕖": "eopf", "ℰ": "Escr", "𝔈": "Efr", "𝔼": "Eopf", "é": "eacute", "É": "Eacute", "è": "egrave", "È": "Egrave", "ê": "ecirc", "Ê": "Ecirc", "ě": "ecaron", "Ě": "Ecaron", "ë": "euml", "Ë": "Euml", "ė": "edot", "Ė": "Edot", "ę": "eogon", "Ę": "Eogon", "ē": "emacr", "Ē": "Emacr", "𝔣": "ffr", "𝕗": "fopf", "𝒻": "fscr", "𝔉": "Ffr", "𝔽": "Fopf", "ℱ": "Fscr", "ﬀ": "fflig", "ﬃ": "ffilig", "ﬄ": "ffllig", "ﬁ": "filig", "fj": "fjlig", "ﬂ": "fllig", "ƒ": "fnof", "ℊ": "gscr", "𝕘": "gopf", "𝔤": "gfr", "𝒢": "Gscr", "𝔾": "Gopf", "𝔊": "Gfr", "ǵ": "gacute", "ğ": "gbreve", "Ğ": "Gbreve", "ĝ": "gcirc", "Ĝ": "Gcirc", "ġ": "gdot", "Ġ": "Gdot", "Ģ": "Gcedil", "𝔥": "hfr", "ℎ": "planckh", "𝒽": "hscr", "𝕙": "hopf", "ℋ": "Hscr", "ℌ": "Hfr", "ℍ": "Hopf", "ĥ": "hcirc", "Ĥ": "Hcirc", "ℏ": "hbar", "ħ": "hstrok", "Ħ": "Hstrok", "𝕚": "iopf", "𝔦": "ifr", "𝒾": "iscr", "ⅈ": "ii", "𝕀": "Iopf", "ℐ": "Iscr", "ℑ": "Im", "í": "iacute", "Í": "Iacute", "ì": "igrave", "Ì": "Igrave", "î": "icirc", "Î": "Icirc", "ï": "iuml", "Ï": "Iuml", "ĩ": "itilde", "Ĩ": "Itilde", "İ": "Idot", "į": "iogon", "Į": "Iogon", "ī": "imacr", "Ī": "Imacr", "ĳ": "ijlig", "Ĳ": "IJlig", "ı": "imath", "𝒿": "jscr", "𝕛": "jopf", "𝔧": "jfr", "𝒥": "Jscr", "𝔍": "Jfr", "𝕁": "Jopf", "ĵ": "jcirc", "Ĵ": "Jcirc", "ȷ": "jmath", "𝕜": "kopf", "𝓀": "kscr", "𝔨": "kfr", "𝒦": "Kscr", "𝕂": "Kopf", "𝔎": "Kfr", "ķ": "kcedil", "Ķ": "Kcedil", "𝔩": "lfr", "𝓁": "lscr", "ℓ": "ell", "𝕝": "lopf", "ℒ": "Lscr", "𝔏": "Lfr", "𝕃": "Lopf", "ĺ": "lacute", "Ĺ": "Lacute", "ľ": "lcaron", "Ľ": "Lcaron", "ļ": "lcedil", "Ļ": "Lcedil", "ł": "lstrok", "Ł": "Lstrok", "ŀ": "lmidot", "Ŀ": "Lmidot", "𝔪": "mfr", "𝕞": "mopf", "𝓂": "mscr", "𝔐": "Mfr", "𝕄": "Mopf", "ℳ": "Mscr", "𝔫": "nfr", "𝕟": "nopf", "𝓃": "nscr", "ℕ": "Nopf", "𝒩": "Nscr", "𝔑": "Nfr", "ń": "nacute", "Ń": "Nacute", "ň": "ncaron", "Ň": "Ncaron", "ñ": "ntilde", "Ñ": "Ntilde", "ņ": "ncedil", "Ņ": "Ncedil", "№": "numero", "ŋ": "eng", "Ŋ": "ENG", "𝕠": "oopf", "𝔬": "ofr", "ℴ": "oscr", "𝒪": "Oscr", "𝔒": "Ofr", "𝕆": "Oopf", "º": "ordm", "ó": "oacute", "Ó": "Oacute", "ò": "ograve", "Ò": "Ograve", "ô": "ocirc", "Ô": "Ocirc", "ö": "ouml", "Ö": "Ouml", "ő": "odblac", "Ő": "Odblac", "õ": "otilde", "Õ": "Otilde", "ø": "oslash", "Ø": "Oslash", "ō": "omacr", "Ō": "Omacr", "œ": "oelig", "Œ": "OElig", "𝔭": "pfr", "𝓅": "pscr", "𝕡": "popf", "ℙ": "Popf", "𝔓": "Pfr", "𝒫": "Pscr", "𝕢": "qopf", "𝔮": "qfr", "𝓆": "qscr", "𝒬": "Qscr", "𝔔": "Qfr", "ℚ": "Qopf", "ĸ": "kgreen", "𝔯": "rfr", "𝕣": "ropf", "𝓇": "rscr", "ℛ": "Rscr", "ℜ": "Re", "ℝ": "Ropf", "ŕ": "racute", "Ŕ": "Racute", "ř": "rcaron", "Ř": "Rcaron", "ŗ": "rcedil", "Ŗ": "Rcedil", "𝕤": "sopf", "𝓈": "sscr", "𝔰": "sfr", "𝕊": "Sopf", "𝔖": "Sfr", "𝒮": "Sscr", "Ⓢ": "oS", "ś": "sacute", "Ś": "Sacute", "ŝ": "scirc", "Ŝ": "Scirc", "š": "scaron", "Š": "Scaron", "ş": "scedil", "Ş": "Scedil", "ß": "szlig", "𝔱": "tfr", "𝓉": "tscr", "𝕥": "topf", "𝒯": "Tscr", "𝔗": "Tfr", "𝕋": "Topf", "ť": "tcaron", "Ť": "Tcaron", "ţ": "tcedil", "Ţ": "Tcedil", "™": "trade", "ŧ": "tstrok", "Ŧ": "Tstrok", "𝓊": "uscr", "𝕦": "uopf", "𝔲": "ufr", "𝕌": "Uopf", "𝔘": "Ufr", "𝒰": "Uscr", "ú": "uacute", "Ú": "Uacute", "ù": "ugrave", "Ù": "Ugrave", "ŭ": "ubreve", "Ŭ": "Ubreve", "û": "ucirc", "Û": "Ucirc", "ů": "uring", "Ů": "Uring", "ü": "uuml", "Ü": "Uuml", "ű": "udblac", "Ű": "Udblac", "ũ": "utilde", "Ũ": "Utilde", "ų": "uogon", "Ų": "Uogon", "ū": "umacr", "Ū": "Umacr", "𝔳": "vfr", "𝕧": "vopf", "𝓋": "vscr", "𝔙": "Vfr", "𝕍": "Vopf", "𝒱": "Vscr", "𝕨": "wopf", "𝓌": "wscr", "𝔴": "wfr", "𝒲": "Wscr", "𝕎": "Wopf", "𝔚": "Wfr", "ŵ": "wcirc", "Ŵ": "Wcirc", "𝔵": "xfr", "𝓍": "xscr", "𝕩": "xopf", "𝕏": "Xopf", "𝔛": "Xfr", "𝒳": "Xscr", "𝔶": "yfr", "𝓎": "yscr", "𝕪": "yopf", "𝒴": "Yscr", "𝔜": "Yfr", "𝕐": "Yopf", "ý": "yacute", "Ý": "Yacute", "ŷ": "ycirc", "Ŷ": "Ycirc", "ÿ": "yuml", "Ÿ": "Yuml", "𝓏": "zscr", "𝔷": "zfr", "𝕫": "zopf", "ℨ": "Zfr", "ℤ": "Zopf", "𝒵": "Zscr", "ź": "zacute", "Ź": "Zacute", "ž": "zcaron", "Ž": "Zcaron", "ż": "zdot", "Ż": "Zdot", "Ƶ": "imped", "þ": "thorn", "Þ": "THORN", "ŉ": "napos", "α": "alpha", "Α": "Alpha", "β": "beta", "Β": "Beta", "γ": "gamma", "Γ": "Gamma", "δ": "delta", "Δ": "Delta", "ε": "epsi", "ϵ": "epsiv", "Ε": "Epsilon", "ϝ": "gammad", "Ϝ": "Gammad", "ζ": "zeta", "Ζ": "Zeta", "η": "eta", "Η": "Eta", "θ": "theta", "ϑ": "thetav", "Θ": "Theta", "ι": "iota", "Ι": "Iota", "κ": "kappa", "ϰ": "kappav", "Κ": "Kappa", "λ": "lambda", "Λ": "Lambda", "μ": "mu", "µ": "micro", "Μ": "Mu", "ν": "nu", "Ν": "Nu", "ξ": "xi", "Ξ": "Xi", "ο": "omicron", "Ο": "Omicron", "π": "pi", "ϖ": "piv", "Π": "Pi", "ρ": "rho", "ϱ": "rhov", "Ρ": "Rho", "σ": "sigma", "Σ": "Sigma", "ς": "sigmaf", "τ": "tau", "Τ": "Tau", "υ": "upsi", "Υ": "Upsilon", "ϒ": "Upsi", "φ": "phi", "ϕ": "phiv", "Φ": "Phi", "χ": "chi", "Χ": "Chi", "ψ": "psi", "Ψ": "Psi", "ω": "omega", "Ω": "ohm", "а": "acy", "А": "Acy", "б": "bcy", "Б": "Bcy", "в": "vcy", "В": "Vcy", "г": "gcy", "Г": "Gcy", "ѓ": "gjcy", "Ѓ": "GJcy", "д": "dcy", "Д": "Dcy", "ђ": "djcy", "Ђ": "DJcy", "е": "iecy", "Е": "IEcy", "ё": "iocy", "Ё": "IOcy", "є": "jukcy", "Є": "Jukcy", "ж": "zhcy", "Ж": "ZHcy", "з": "zcy", "З": "Zcy", "ѕ": "dscy", "Ѕ": "DScy", "и": "icy", "И": "Icy", "і": "iukcy", "І": "Iukcy", "ї": "yicy", "Ї": "YIcy", "й": "jcy", "Й": "Jcy", "ј": "jsercy", "Ј": "Jsercy", "к": "kcy", "К": "Kcy", "ќ": "kjcy", "Ќ": "KJcy", "л": "lcy", "Л": "Lcy", "љ": "ljcy", "Љ": "LJcy", "м": "mcy", "М": "Mcy", "н": "ncy", "Н": "Ncy", "њ": "njcy", "Њ": "NJcy", "о": "ocy", "О": "Ocy", "п": "pcy", "П": "Pcy", "р": "rcy", "Р": "Rcy", "с": "scy", "С": "Scy", "т": "tcy", "Т": "Tcy", "ћ": "tshcy", "Ћ": "TSHcy", "у": "ucy", "У": "Ucy", "ў": "ubrcy", "Ў": "Ubrcy", "ф": "fcy", "Ф": "Fcy", "х": "khcy", "Х": "KHcy", "ц": "tscy", "Ц": "TScy", "ч": "chcy", "Ч": "CHcy", "џ": "dzcy", "Џ": "DZcy", "ш": "shcy", "Ш": "SHcy", "щ": "shchcy", "Щ": "SHCHcy", "ъ": "hardcy", "Ъ": "HARDcy", "ы": "ycy", "Ы": "Ycy", "ь": "softcy", "Ь": "SOFTcy", "э": "ecy", "Э": "Ecy", "ю": "yucy", "Ю": "YUcy", "я": "yacy", "Я": "YAcy", "ℵ": "aleph", "ℶ": "beth", "ℷ": "gimel", "ℸ": "daleth" };
      var regexEscape = /["&'<>`]/g;
      var escapeMap = {
        '"': "&quot;",
        "&": "&amp;",
        "'": "&#x27;",
        "<": "&lt;",
        // See https://mathiasbynens.be/notes/ambiguous-ampersands: in HTML, the
        // following is not strictly necessary unless it’s part of a tag or an
        // unquoted attribute value. We’re only escaping it to support those
        // situations, and for XML support.
        ">": "&gt;",
        // In Internet Explorer ≤ 8, the backtick character can be used
        // to break out of (un)quoted attribute values or HTML comments.
        // See http://html5sec.org/#102, http://html5sec.org/#108, and
        // http://html5sec.org/#133.
        "`": "&#x60;"
      };
      var regexInvalidEntity = /&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/;
      var regexInvalidRawCodePoint = /[\0-\x08\x0B\x0E-\x1F\x7F-\x9F\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
      var regexDecode = /&(CounterClockwiseContourIntegral|DoubleLongLeftRightArrow|ClockwiseContourIntegral|NotNestedGreaterGreater|NotSquareSupersetEqual|DiacriticalDoubleAcute|NotRightTriangleEqual|NotSucceedsSlantEqual|NotPrecedesSlantEqual|CloseCurlyDoubleQuote|NegativeVeryThinSpace|DoubleContourIntegral|FilledVerySmallSquare|CapitalDifferentialD|OpenCurlyDoubleQuote|EmptyVerySmallSquare|NestedGreaterGreater|DoubleLongRightArrow|NotLeftTriangleEqual|NotGreaterSlantEqual|ReverseUpEquilibrium|DoubleLeftRightArrow|NotSquareSubsetEqual|NotDoubleVerticalBar|RightArrowLeftArrow|NotGreaterFullEqual|NotRightTriangleBar|SquareSupersetEqual|DownLeftRightVector|DoubleLongLeftArrow|leftrightsquigarrow|LeftArrowRightArrow|NegativeMediumSpace|blacktriangleright|RightDownVectorBar|PrecedesSlantEqual|RightDoubleBracket|SucceedsSlantEqual|NotLeftTriangleBar|RightTriangleEqual|SquareIntersection|RightDownTeeVector|ReverseEquilibrium|NegativeThickSpace|longleftrightarrow|Longleftrightarrow|LongLeftRightArrow|DownRightTeeVector|DownRightVectorBar|GreaterSlantEqual|SquareSubsetEqual|LeftDownVectorBar|LeftDoubleBracket|VerticalSeparator|rightleftharpoons|NotGreaterGreater|NotSquareSuperset|blacktriangleleft|blacktriangledown|NegativeThinSpace|LeftDownTeeVector|NotLessSlantEqual|leftrightharpoons|DoubleUpDownArrow|DoubleVerticalBar|LeftTriangleEqual|FilledSmallSquare|twoheadrightarrow|NotNestedLessLess|DownLeftTeeVector|DownLeftVectorBar|RightAngleBracket|NotTildeFullEqual|NotReverseElement|RightUpDownVector|DiacriticalTilde|NotSucceedsTilde|circlearrowright|NotPrecedesEqual|rightharpoondown|DoubleRightArrow|NotSucceedsEqual|NonBreakingSpace|NotRightTriangle|LessEqualGreater|RightUpTeeVector|LeftAngleBracket|GreaterFullEqual|DownArrowUpArrow|RightUpVectorBar|twoheadleftarrow|GreaterEqualLess|downharpoonright|RightTriangleBar|ntrianglerighteq|NotSupersetEqual|LeftUpDownVector|DiacriticalAcute|rightrightarrows|vartriangleright|UpArrowDownArrow|DiacriticalGrave|UnderParenthesis|EmptySmallSquare|LeftUpVectorBar|leftrightarrows|DownRightVector|downharpoonleft|trianglerighteq|ShortRightArrow|OverParenthesis|DoubleLeftArrow|DoubleDownArrow|NotSquareSubset|bigtriangledown|ntrianglelefteq|UpperRightArrow|curvearrowright|vartriangleleft|NotLeftTriangle|nleftrightarrow|LowerRightArrow|NotHumpDownHump|NotGreaterTilde|rightthreetimes|LeftUpTeeVector|NotGreaterEqual|straightepsilon|LeftTriangleBar|rightsquigarrow|ContourIntegral|rightleftarrows|CloseCurlyQuote|RightDownVector|LeftRightVector|nLeftrightarrow|leftharpoondown|circlearrowleft|SquareSuperset|OpenCurlyQuote|hookrightarrow|HorizontalLine|DiacriticalDot|NotLessGreater|ntriangleright|DoubleRightTee|InvisibleComma|InvisibleTimes|LowerLeftArrow|DownLeftVector|NotSubsetEqual|curvearrowleft|trianglelefteq|NotVerticalBar|TildeFullEqual|downdownarrows|NotGreaterLess|RightTeeVector|ZeroWidthSpace|looparrowright|LongRightArrow|doublebarwedge|ShortLeftArrow|ShortDownArrow|RightVectorBar|GreaterGreater|ReverseElement|rightharpoonup|LessSlantEqual|leftthreetimes|upharpoonright|rightarrowtail|LeftDownVector|Longrightarrow|NestedLessLess|UpperLeftArrow|nshortparallel|leftleftarrows|leftrightarrow|Leftrightarrow|LeftRightArrow|longrightarrow|upharpoonleft|RightArrowBar|ApplyFunction|LeftTeeVector|leftarrowtail|NotEqualTilde|varsubsetneqq|varsupsetneqq|RightTeeArrow|SucceedsEqual|SucceedsTilde|LeftVectorBar|SupersetEqual|hookleftarrow|DifferentialD|VerticalTilde|VeryThinSpace|blacktriangle|bigtriangleup|LessFullEqual|divideontimes|leftharpoonup|UpEquilibrium|ntriangleleft|RightTriangle|measuredangle|shortparallel|longleftarrow|Longleftarrow|LongLeftArrow|DoubleLeftTee|Poincareplane|PrecedesEqual|triangleright|DoubleUpArrow|RightUpVector|fallingdotseq|looparrowleft|PrecedesTilde|NotTildeEqual|NotTildeTilde|smallsetminus|Proportional|triangleleft|triangledown|UnderBracket|NotHumpEqual|exponentiale|ExponentialE|NotLessTilde|HilbertSpace|RightCeiling|blacklozenge|varsupsetneq|HumpDownHump|GreaterEqual|VerticalLine|LeftTeeArrow|NotLessEqual|DownTeeArrow|LeftTriangle|varsubsetneq|Intersection|NotCongruent|DownArrowBar|LeftUpVector|LeftArrowBar|risingdotseq|GreaterTilde|RoundImplies|SquareSubset|ShortUpArrow|NotSuperset|quaternions|precnapprox|backepsilon|preccurlyeq|OverBracket|blacksquare|MediumSpace|VerticalBar|circledcirc|circleddash|CircleMinus|CircleTimes|LessGreater|curlyeqprec|curlyeqsucc|diamondsuit|UpDownArrow|Updownarrow|RuleDelayed|Rrightarrow|updownarrow|RightVector|nRightarrow|nrightarrow|eqslantless|LeftCeiling|Equilibrium|SmallCircle|expectation|NotSucceeds|thickapprox|GreaterLess|SquareUnion|NotPrecedes|NotLessLess|straightphi|succnapprox|succcurlyeq|SubsetEqual|sqsupseteq|Proportion|Laplacetrf|ImaginaryI|supsetneqq|NotGreater|gtreqqless|NotElement|ThickSpace|TildeEqual|TildeTilde|Fouriertrf|rmoustache|EqualTilde|eqslantgtr|UnderBrace|LeftVector|UpArrowBar|nLeftarrow|nsubseteqq|subsetneqq|nsupseteqq|nleftarrow|succapprox|lessapprox|UpTeeArrow|upuparrows|curlywedge|lesseqqgtr|varepsilon|varnothing|RightFloor|complement|CirclePlus|sqsubseteq|Lleftarrow|circledast|RightArrow|Rightarrow|rightarrow|lmoustache|Bernoullis|precapprox|mapstoleft|mapstodown|longmapsto|dotsquare|downarrow|DoubleDot|nsubseteq|supsetneq|leftarrow|nsupseteq|subsetneq|ThinSpace|ngeqslant|subseteqq|HumpEqual|NotSubset|triangleq|NotCupCap|lesseqgtr|heartsuit|TripleDot|Leftarrow|Coproduct|Congruent|varpropto|complexes|gvertneqq|LeftArrow|LessTilde|supseteqq|MinusPlus|CircleDot|nleqslant|NotExists|gtreqless|nparallel|UnionPlus|LeftFloor|checkmark|CenterDot|centerdot|Mellintrf|gtrapprox|bigotimes|OverBrace|spadesuit|therefore|pitchfork|rationals|PlusMinus|Backslash|Therefore|DownBreve|backsimeq|backprime|DownArrow|nshortmid|Downarrow|lvertneqq|eqvparsl|imagline|imagpart|infintie|integers|Integral|intercal|LessLess|Uarrocir|intlarhk|sqsupset|angmsdaf|sqsubset|llcorner|vartheta|cupbrcap|lnapprox|Superset|SuchThat|succnsim|succneqq|angmsdag|biguplus|curlyvee|trpezium|Succeeds|NotTilde|bigwedge|angmsdah|angrtvbd|triminus|cwconint|fpartint|lrcorner|smeparsl|subseteq|urcorner|lurdshar|laemptyv|DDotrahd|approxeq|ldrushar|awconint|mapstoup|backcong|shortmid|triangle|geqslant|gesdotol|timesbar|circledR|circledS|setminus|multimap|naturals|scpolint|ncongdot|RightTee|boxminus|gnapprox|boxtimes|andslope|thicksim|angmsdaa|varsigma|cirfnint|rtriltri|angmsdab|rppolint|angmsdac|barwedge|drbkarow|clubsuit|thetasym|bsolhsub|capbrcup|dzigrarr|doteqdot|DotEqual|dotminus|UnderBar|NotEqual|realpart|otimesas|ulcorner|hksearow|hkswarow|parallel|PartialD|elinters|emptyset|plusacir|bbrktbrk|angmsdad|pointint|bigoplus|angmsdae|Precedes|bigsqcup|varkappa|notindot|supseteq|precneqq|precnsim|profalar|profline|profsurf|leqslant|lesdotor|raemptyv|subplus|notnivb|notnivc|subrarr|zigrarr|vzigzag|submult|subedot|Element|between|cirscir|larrbfs|larrsim|lotimes|lbrksld|lbrkslu|lozenge|ldrdhar|dbkarow|bigcirc|epsilon|simrarr|simplus|ltquest|Epsilon|luruhar|gtquest|maltese|npolint|eqcolon|npreceq|bigodot|ddagger|gtrless|bnequiv|harrcir|ddotseq|equivDD|backsim|demptyv|nsqsube|nsqsupe|Upsilon|nsubset|upsilon|minusdu|nsucceq|swarrow|nsupset|coloneq|searrow|boxplus|napprox|natural|asympeq|alefsym|congdot|nearrow|bigstar|diamond|supplus|tritime|LeftTee|nvinfin|triplus|NewLine|nvltrie|nvrtrie|nwarrow|nexists|Diamond|ruluhar|Implies|supmult|angzarr|suplarr|suphsub|questeq|because|digamma|Because|olcross|bemptyv|omicron|Omicron|rotimes|NoBreak|intprod|angrtvb|orderof|uwangle|suphsol|lesdoto|orslope|DownTee|realine|cudarrl|rdldhar|OverBar|supedot|lessdot|supdsub|topfork|succsim|rbrkslu|rbrksld|pertenk|cudarrr|isindot|planckh|lessgtr|pluscir|gesdoto|plussim|plustwo|lesssim|cularrp|rarrsim|Cayleys|notinva|notinvb|notinvc|UpArrow|Uparrow|uparrow|NotLess|dwangle|precsim|Product|curarrm|Cconint|dotplus|rarrbfs|ccupssm|Cedilla|cemptyv|notniva|quatint|frac35|frac38|frac45|frac56|frac58|frac78|tridot|xoplus|gacute|gammad|Gammad|lfisht|lfloor|bigcup|sqsupe|gbreve|Gbreve|lharul|sqsube|sqcups|Gcedil|apacir|llhard|lmidot|Lmidot|lmoust|andand|sqcaps|approx|Abreve|spades|circeq|tprime|divide|topcir|Assign|topbot|gesdot|divonx|xuplus|timesd|gesles|atilde|solbar|SOFTcy|loplus|timesb|lowast|lowbar|dlcorn|dlcrop|softcy|dollar|lparlt|thksim|lrhard|Atilde|lsaquo|smashp|bigvee|thinsp|wreath|bkarow|lsquor|lstrok|Lstrok|lthree|ltimes|ltlarr|DotDot|simdot|ltrPar|weierp|xsqcup|angmsd|sigmav|sigmaf|zeetrf|Zcaron|zcaron|mapsto|vsupne|thetav|cirmid|marker|mcomma|Zacute|vsubnE|there4|gtlPar|vsubne|bottom|gtrarr|SHCHcy|shchcy|midast|midcir|middot|minusb|minusd|gtrdot|bowtie|sfrown|mnplus|models|colone|seswar|Colone|mstpos|searhk|gtrsim|nacute|Nacute|boxbox|telrec|hairsp|Tcedil|nbumpe|scnsim|ncaron|Ncaron|ncedil|Ncedil|hamilt|Scedil|nearhk|hardcy|HARDcy|tcedil|Tcaron|commat|nequiv|nesear|tcaron|target|hearts|nexist|varrho|scedil|Scaron|scaron|hellip|Sacute|sacute|hercon|swnwar|compfn|rtimes|rthree|rsquor|rsaquo|zacute|wedgeq|homtht|barvee|barwed|Barwed|rpargt|horbar|conint|swarhk|roplus|nltrie|hslash|hstrok|Hstrok|rmoust|Conint|bprime|hybull|hyphen|iacute|Iacute|supsup|supsub|supsim|varphi|coprod|brvbar|agrave|Supset|supset|igrave|Igrave|notinE|Agrave|iiiint|iinfin|copysr|wedbar|Verbar|vangrt|becaus|incare|verbar|inodot|bullet|drcorn|intcal|drcrop|cularr|vellip|Utilde|bumpeq|cupcap|dstrok|Dstrok|CupCap|cupcup|cupdot|eacute|Eacute|supdot|iquest|easter|ecaron|Ecaron|ecolon|isinsv|utilde|itilde|Itilde|curarr|succeq|Bumpeq|cacute|ulcrop|nparsl|Cacute|nprcue|egrave|Egrave|nrarrc|nrarrw|subsup|subsub|nrtrie|jsercy|nsccue|Jsercy|kappav|kcedil|Kcedil|subsim|ulcorn|nsimeq|egsdot|veebar|kgreen|capand|elsdot|Subset|subset|curren|aacute|lacute|Lacute|emptyv|ntilde|Ntilde|lagran|lambda|Lambda|capcap|Ugrave|langle|subdot|emsp13|numero|emsp14|nvdash|nvDash|nVdash|nVDash|ugrave|ufisht|nvHarr|larrfs|nvlArr|larrhk|larrlp|larrpl|nvrArr|Udblac|nwarhk|larrtl|nwnear|oacute|Oacute|latail|lAtail|sstarf|lbrace|odblac|Odblac|lbrack|udblac|odsold|eparsl|lcaron|Lcaron|ograve|Ograve|lcedil|Lcedil|Aacute|ssmile|ssetmn|squarf|ldquor|capcup|ominus|cylcty|rharul|eqcirc|dagger|rfloor|rfisht|Dagger|daleth|equals|origof|capdot|equest|dcaron|Dcaron|rdquor|oslash|Oslash|otilde|Otilde|otimes|Otimes|urcrop|Ubreve|ubreve|Yacute|Uacute|uacute|Rcedil|rcedil|urcorn|parsim|Rcaron|Vdashl|rcaron|Tstrok|percnt|period|permil|Exists|yacute|rbrack|rbrace|phmmat|ccaron|Ccaron|planck|ccedil|plankv|tstrok|female|plusdo|plusdu|ffilig|plusmn|ffllig|Ccedil|rAtail|dfisht|bernou|ratail|Rarrtl|rarrtl|angsph|rarrpl|rarrlp|rarrhk|xwedge|xotime|forall|ForAll|Vvdash|vsupnE|preceq|bigcap|frac12|frac13|frac14|primes|rarrfs|prnsim|frac15|Square|frac16|square|lesdot|frac18|frac23|propto|prurel|rarrap|rangle|puncsp|frac25|Racute|qprime|racute|lesges|frac34|abreve|AElig|eqsim|utdot|setmn|urtri|Equal|Uring|seArr|uring|searr|dashv|Dashv|mumap|nabla|iogon|Iogon|sdote|sdotb|scsim|napid|napos|equiv|natur|Acirc|dblac|erarr|nbump|iprod|erDot|ucirc|awint|esdot|angrt|ncong|isinE|scnap|Scirc|scirc|ndash|isins|Ubrcy|nearr|neArr|isinv|nedot|ubrcy|acute|Ycirc|iukcy|Iukcy|xutri|nesim|caret|jcirc|Jcirc|caron|twixt|ddarr|sccue|exist|jmath|sbquo|ngeqq|angst|ccaps|lceil|ngsim|UpTee|delta|Delta|rtrif|nharr|nhArr|nhpar|rtrie|jukcy|Jukcy|kappa|rsquo|Kappa|nlarr|nlArr|TSHcy|rrarr|aogon|Aogon|fflig|xrarr|tshcy|ccirc|nleqq|filig|upsih|nless|dharl|nlsim|fjlig|ropar|nltri|dharr|robrk|roarr|fllig|fltns|roang|rnmid|subnE|subne|lAarr|trisb|Ccirc|acirc|ccups|blank|VDash|forkv|Vdash|langd|cedil|blk12|blk14|laquo|strns|diams|notin|vDash|larrb|blk34|block|disin|uplus|vdash|vBarv|aelig|starf|Wedge|check|xrArr|lates|lbarr|lBarr|notni|lbbrk|bcong|frasl|lbrke|frown|vrtri|vprop|vnsup|gamma|Gamma|wedge|xodot|bdquo|srarr|doteq|ldquo|boxdl|boxdL|gcirc|Gcirc|boxDl|boxDL|boxdr|boxdR|boxDr|TRADE|trade|rlhar|boxDR|vnsub|npart|vltri|rlarr|boxhd|boxhD|nprec|gescc|nrarr|nrArr|boxHd|boxHD|boxhu|boxhU|nrtri|boxHu|clubs|boxHU|times|colon|Colon|gimel|xlArr|Tilde|nsime|tilde|nsmid|nspar|THORN|thorn|xlarr|nsube|nsubE|thkap|xhArr|comma|nsucc|boxul|boxuL|nsupe|nsupE|gneqq|gnsim|boxUl|boxUL|grave|boxur|boxuR|boxUr|boxUR|lescc|angle|bepsi|boxvh|varpi|boxvH|numsp|Theta|gsime|gsiml|theta|boxVh|boxVH|boxvl|gtcir|gtdot|boxvL|boxVl|boxVL|crarr|cross|Cross|nvsim|boxvr|nwarr|nwArr|sqsup|dtdot|Uogon|lhard|lharu|dtrif|ocirc|Ocirc|lhblk|duarr|odash|sqsub|Hacek|sqcup|llarr|duhar|oelig|OElig|ofcir|boxvR|uogon|lltri|boxVr|csube|uuarr|ohbar|csupe|ctdot|olarr|olcir|harrw|oline|sqcap|omacr|Omacr|omega|Omega|boxVR|aleph|lneqq|lnsim|loang|loarr|rharu|lobrk|hcirc|operp|oplus|rhard|Hcirc|orarr|Union|order|ecirc|Ecirc|cuepr|szlig|cuesc|breve|reals|eDDot|Breve|hoarr|lopar|utrif|rdquo|Umacr|umacr|efDot|swArr|ultri|alpha|rceil|ovbar|swarr|Wcirc|wcirc|smtes|smile|bsemi|lrarr|aring|parsl|lrhar|bsime|uhblk|lrtri|cupor|Aring|uharr|uharl|slarr|rbrke|bsolb|lsime|rbbrk|RBarr|lsimg|phone|rBarr|rbarr|icirc|lsquo|Icirc|emacr|Emacr|ratio|simne|plusb|simlE|simgE|simeq|pluse|ltcir|ltdot|empty|xharr|xdtri|iexcl|Alpha|ltrie|rarrw|pound|ltrif|xcirc|bumpe|prcue|bumpE|asymp|amacr|cuvee|Sigma|sigma|iiint|udhar|iiota|ijlig|IJlig|supnE|imacr|Imacr|prime|Prime|image|prnap|eogon|Eogon|rarrc|mdash|mDDot|cuwed|imath|supne|imped|Amacr|udarr|prsim|micro|rarrb|cwint|raquo|infin|eplus|range|rangd|Ucirc|radic|minus|amalg|veeeq|rAarr|epsiv|ycirc|quest|sharp|quot|zwnj|Qscr|race|qscr|Qopf|qopf|qint|rang|Rang|Zscr|zscr|Zopf|zopf|rarr|rArr|Rarr|Pscr|pscr|prop|prod|prnE|prec|ZHcy|zhcy|prap|Zeta|zeta|Popf|popf|Zdot|plus|zdot|Yuml|yuml|phiv|YUcy|yucy|Yscr|yscr|perp|Yopf|yopf|part|para|YIcy|Ouml|rcub|yicy|YAcy|rdca|ouml|osol|Oscr|rdsh|yacy|real|oscr|xvee|andd|rect|andv|Xscr|oror|ordm|ordf|xscr|ange|aopf|Aopf|rHar|Xopf|opar|Oopf|xopf|xnis|rhov|oopf|omid|xmap|oint|apid|apos|ogon|ascr|Ascr|odot|odiv|xcup|xcap|ocir|oast|nvlt|nvle|nvgt|nvge|nvap|Wscr|wscr|auml|ntlg|ntgl|nsup|nsub|nsim|Nscr|nscr|nsce|Wopf|ring|npre|wopf|npar|Auml|Barv|bbrk|Nopf|nopf|nmid|nLtv|beta|ropf|Ropf|Beta|beth|nles|rpar|nleq|bnot|bNot|nldr|NJcy|rscr|Rscr|Vscr|vscr|rsqb|njcy|bopf|nisd|Bopf|rtri|Vopf|nGtv|ngtr|vopf|boxh|boxH|boxv|nges|ngeq|boxV|bscr|scap|Bscr|bsim|Vert|vert|bsol|bull|bump|caps|cdot|ncup|scnE|ncap|nbsp|napE|Cdot|cent|sdot|Vbar|nang|vBar|chcy|Mscr|mscr|sect|semi|CHcy|Mopf|mopf|sext|circ|cire|mldr|mlcp|cirE|comp|shcy|SHcy|vArr|varr|cong|copf|Copf|copy|COPY|malt|male|macr|lvnE|cscr|ltri|sime|ltcc|simg|Cscr|siml|csub|Uuml|lsqb|lsim|uuml|csup|Lscr|lscr|utri|smid|lpar|cups|smte|lozf|darr|Lopf|Uscr|solb|lopf|sopf|Sopf|lneq|uscr|spar|dArr|lnap|Darr|dash|Sqrt|LJcy|ljcy|lHar|dHar|Upsi|upsi|diam|lesg|djcy|DJcy|leqq|dopf|Dopf|dscr|Dscr|dscy|ldsh|ldca|squf|DScy|sscr|Sscr|dsol|lcub|late|star|Star|Uopf|Larr|lArr|larr|uopf|dtri|dzcy|sube|subE|Lang|lang|Kscr|kscr|Kopf|kopf|KJcy|kjcy|KHcy|khcy|DZcy|ecir|edot|eDot|Jscr|jscr|succ|Jopf|jopf|Edot|uHar|emsp|ensp|Iuml|iuml|eopf|isin|Iscr|iscr|Eopf|epar|sung|epsi|escr|sup1|sup2|sup3|Iota|iota|supe|supE|Iopf|iopf|IOcy|iocy|Escr|esim|Esim|imof|Uarr|QUOT|uArr|uarr|euml|IEcy|iecy|Idot|Euml|euro|excl|Hscr|hscr|Hopf|hopf|TScy|tscy|Tscr|hbar|tscr|flat|tbrk|fnof|hArr|harr|half|fopf|Fopf|tdot|gvnE|fork|trie|gtcc|fscr|Fscr|gdot|gsim|Gscr|gscr|Gopf|gopf|gneq|Gdot|tosa|gnap|Topf|topf|geqq|toea|GJcy|gjcy|tint|gesl|mid|Sfr|ggg|top|ges|gla|glE|glj|geq|gne|gEl|gel|gnE|Gcy|gcy|gap|Tfr|tfr|Tcy|tcy|Hat|Tau|Ffr|tau|Tab|hfr|Hfr|ffr|Fcy|fcy|icy|Icy|iff|ETH|eth|ifr|Ifr|Eta|eta|int|Int|Sup|sup|ucy|Ucy|Sum|sum|jcy|ENG|ufr|Ufr|eng|Jcy|jfr|els|ell|egs|Efr|efr|Jfr|uml|kcy|Kcy|Ecy|ecy|kfr|Kfr|lap|Sub|sub|lat|lcy|Lcy|leg|Dot|dot|lEg|leq|les|squ|div|die|lfr|Lfr|lgE|Dfr|dfr|Del|deg|Dcy|dcy|lne|lnE|sol|loz|smt|Cup|lrm|cup|lsh|Lsh|sim|shy|map|Map|mcy|Mcy|mfr|Mfr|mho|gfr|Gfr|sfr|cir|Chi|chi|nap|Cfr|vcy|Vcy|cfr|Scy|scy|ncy|Ncy|vee|Vee|Cap|cap|nfr|scE|sce|Nfr|nge|ngE|nGg|vfr|Vfr|ngt|bot|nGt|nis|niv|Rsh|rsh|nle|nlE|bne|Bfr|bfr|nLl|nlt|nLt|Bcy|bcy|not|Not|rlm|wfr|Wfr|npr|nsc|num|ocy|ast|Ocy|ofr|xfr|Xfr|Ofr|ogt|ohm|apE|olt|Rho|ape|rho|Rfr|rfr|ord|REG|ang|reg|orv|And|and|AMP|Rcy|amp|Afr|ycy|Ycy|yen|yfr|Yfr|rcy|par|pcy|Pcy|pfr|Pfr|phi|Phi|afr|Acy|acy|zcy|Zcy|piv|acE|acd|zfr|Zfr|pre|prE|psi|Psi|qfr|Qfr|zwj|Or|ge|Gg|gt|gg|el|oS|lt|Lt|LT|Re|lg|gl|eg|ne|Im|it|le|DD|wp|wr|nu|Nu|dd|lE|Sc|sc|pi|Pi|ee|af|ll|Ll|rx|gE|xi|pm|Xi|ic|pr|Pr|in|ni|mp|mu|ac|Mu|or|ap|Gt|GT|ii);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)(?!;)([=a-zA-Z0-9]?)|&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+)/g;
      var decodeMap = { "aacute": "á", "Aacute": "Á", "abreve": "ă", "Abreve": "Ă", "ac": "∾", "acd": "∿", "acE": "∾̳", "acirc": "â", "Acirc": "Â", "acute": "´", "acy": "а", "Acy": "А", "aelig": "æ", "AElig": "Æ", "af": "⁡", "afr": "𝔞", "Afr": "𝔄", "agrave": "à", "Agrave": "À", "alefsym": "ℵ", "aleph": "ℵ", "alpha": "α", "Alpha": "Α", "amacr": "ā", "Amacr": "Ā", "amalg": "⨿", "amp": "&", "AMP": "&", "and": "∧", "And": "⩓", "andand": "⩕", "andd": "⩜", "andslope": "⩘", "andv": "⩚", "ang": "∠", "ange": "⦤", "angle": "∠", "angmsd": "∡", "angmsdaa": "⦨", "angmsdab": "⦩", "angmsdac": "⦪", "angmsdad": "⦫", "angmsdae": "⦬", "angmsdaf": "⦭", "angmsdag": "⦮", "angmsdah": "⦯", "angrt": "∟", "angrtvb": "⊾", "angrtvbd": "⦝", "angsph": "∢", "angst": "Å", "angzarr": "⍼", "aogon": "ą", "Aogon": "Ą", "aopf": "𝕒", "Aopf": "𝔸", "ap": "≈", "apacir": "⩯", "ape": "≊", "apE": "⩰", "apid": "≋", "apos": "'", "ApplyFunction": "⁡", "approx": "≈", "approxeq": "≊", "aring": "å", "Aring": "Å", "ascr": "𝒶", "Ascr": "𝒜", "Assign": "≔", "ast": "*", "asymp": "≈", "asympeq": "≍", "atilde": "ã", "Atilde": "Ã", "auml": "ä", "Auml": "Ä", "awconint": "∳", "awint": "⨑", "backcong": "≌", "backepsilon": "϶", "backprime": "‵", "backsim": "∽", "backsimeq": "⋍", "Backslash": "∖", "Barv": "⫧", "barvee": "⊽", "barwed": "⌅", "Barwed": "⌆", "barwedge": "⌅", "bbrk": "⎵", "bbrktbrk": "⎶", "bcong": "≌", "bcy": "б", "Bcy": "Б", "bdquo": "„", "becaus": "∵", "because": "∵", "Because": "∵", "bemptyv": "⦰", "bepsi": "϶", "bernou": "ℬ", "Bernoullis": "ℬ", "beta": "β", "Beta": "Β", "beth": "ℶ", "between": "≬", "bfr": "𝔟", "Bfr": "𝔅", "bigcap": "⋂", "bigcirc": "◯", "bigcup": "⋃", "bigodot": "⨀", "bigoplus": "⨁", "bigotimes": "⨂", "bigsqcup": "⨆", "bigstar": "★", "bigtriangledown": "▽", "bigtriangleup": "△", "biguplus": "⨄", "bigvee": "⋁", "bigwedge": "⋀", "bkarow": "⤍", "blacklozenge": "⧫", "blacksquare": "▪", "blacktriangle": "▴", "blacktriangledown": "▾", "blacktriangleleft": "◂", "blacktriangleright": "▸", "blank": "␣", "blk12": "▒", "blk14": "░", "blk34": "▓", "block": "█", "bne": "=⃥", "bnequiv": "≡⃥", "bnot": "⌐", "bNot": "⫭", "bopf": "𝕓", "Bopf": "𝔹", "bot": "⊥", "bottom": "⊥", "bowtie": "⋈", "boxbox": "⧉", "boxdl": "┐", "boxdL": "╕", "boxDl": "╖", "boxDL": "╗", "boxdr": "┌", "boxdR": "╒", "boxDr": "╓", "boxDR": "╔", "boxh": "─", "boxH": "═", "boxhd": "┬", "boxhD": "╥", "boxHd": "╤", "boxHD": "╦", "boxhu": "┴", "boxhU": "╨", "boxHu": "╧", "boxHU": "╩", "boxminus": "⊟", "boxplus": "⊞", "boxtimes": "⊠", "boxul": "┘", "boxuL": "╛", "boxUl": "╜", "boxUL": "╝", "boxur": "└", "boxuR": "╘", "boxUr": "╙", "boxUR": "╚", "boxv": "│", "boxV": "║", "boxvh": "┼", "boxvH": "╪", "boxVh": "╫", "boxVH": "╬", "boxvl": "┤", "boxvL": "╡", "boxVl": "╢", "boxVL": "╣", "boxvr": "├", "boxvR": "╞", "boxVr": "╟", "boxVR": "╠", "bprime": "‵", "breve": "˘", "Breve": "˘", "brvbar": "¦", "bscr": "𝒷", "Bscr": "ℬ", "bsemi": "⁏", "bsim": "∽", "bsime": "⋍", "bsol": "\\", "bsolb": "⧅", "bsolhsub": "⟈", "bull": "•", "bullet": "•", "bump": "≎", "bumpe": "≏", "bumpE": "⪮", "bumpeq": "≏", "Bumpeq": "≎", "cacute": "ć", "Cacute": "Ć", "cap": "∩", "Cap": "⋒", "capand": "⩄", "capbrcup": "⩉", "capcap": "⩋", "capcup": "⩇", "capdot": "⩀", "CapitalDifferentialD": "ⅅ", "caps": "∩︀", "caret": "⁁", "caron": "ˇ", "Cayleys": "ℭ", "ccaps": "⩍", "ccaron": "č", "Ccaron": "Č", "ccedil": "ç", "Ccedil": "Ç", "ccirc": "ĉ", "Ccirc": "Ĉ", "Cconint": "∰", "ccups": "⩌", "ccupssm": "⩐", "cdot": "ċ", "Cdot": "Ċ", "cedil": "¸", "Cedilla": "¸", "cemptyv": "⦲", "cent": "¢", "centerdot": "·", "CenterDot": "·", "cfr": "𝔠", "Cfr": "ℭ", "chcy": "ч", "CHcy": "Ч", "check": "✓", "checkmark": "✓", "chi": "χ", "Chi": "Χ", "cir": "○", "circ": "ˆ", "circeq": "≗", "circlearrowleft": "↺", "circlearrowright": "↻", "circledast": "⊛", "circledcirc": "⊚", "circleddash": "⊝", "CircleDot": "⊙", "circledR": "®", "circledS": "Ⓢ", "CircleMinus": "⊖", "CirclePlus": "⊕", "CircleTimes": "⊗", "cire": "≗", "cirE": "⧃", "cirfnint": "⨐", "cirmid": "⫯", "cirscir": "⧂", "ClockwiseContourIntegral": "∲", "CloseCurlyDoubleQuote": "”", "CloseCurlyQuote": "’", "clubs": "♣", "clubsuit": "♣", "colon": ":", "Colon": "∷", "colone": "≔", "Colone": "⩴", "coloneq": "≔", "comma": ",", "commat": "@", "comp": "∁", "compfn": "∘", "complement": "∁", "complexes": "ℂ", "cong": "≅", "congdot": "⩭", "Congruent": "≡", "conint": "∮", "Conint": "∯", "ContourIntegral": "∮", "copf": "𝕔", "Copf": "ℂ", "coprod": "∐", "Coproduct": "∐", "copy": "©", "COPY": "©", "copysr": "℗", "CounterClockwiseContourIntegral": "∳", "crarr": "↵", "cross": "✗", "Cross": "⨯", "cscr": "𝒸", "Cscr": "𝒞", "csub": "⫏", "csube": "⫑", "csup": "⫐", "csupe": "⫒", "ctdot": "⋯", "cudarrl": "⤸", "cudarrr": "⤵", "cuepr": "⋞", "cuesc": "⋟", "cularr": "↶", "cularrp": "⤽", "cup": "∪", "Cup": "⋓", "cupbrcap": "⩈", "cupcap": "⩆", "CupCap": "≍", "cupcup": "⩊", "cupdot": "⊍", "cupor": "⩅", "cups": "∪︀", "curarr": "↷", "curarrm": "⤼", "curlyeqprec": "⋞", "curlyeqsucc": "⋟", "curlyvee": "⋎", "curlywedge": "⋏", "curren": "¤", "curvearrowleft": "↶", "curvearrowright": "↷", "cuvee": "⋎", "cuwed": "⋏", "cwconint": "∲", "cwint": "∱", "cylcty": "⌭", "dagger": "†", "Dagger": "‡", "daleth": "ℸ", "darr": "↓", "dArr": "⇓", "Darr": "↡", "dash": "‐", "dashv": "⊣", "Dashv": "⫤", "dbkarow": "⤏", "dblac": "˝", "dcaron": "ď", "Dcaron": "Ď", "dcy": "д", "Dcy": "Д", "dd": "ⅆ", "DD": "ⅅ", "ddagger": "‡", "ddarr": "⇊", "DDotrahd": "⤑", "ddotseq": "⩷", "deg": "°", "Del": "∇", "delta": "δ", "Delta": "Δ", "demptyv": "⦱", "dfisht": "⥿", "dfr": "𝔡", "Dfr": "𝔇", "dHar": "⥥", "dharl": "⇃", "dharr": "⇂", "DiacriticalAcute": "´", "DiacriticalDot": "˙", "DiacriticalDoubleAcute": "˝", "DiacriticalGrave": "`", "DiacriticalTilde": "˜", "diam": "⋄", "diamond": "⋄", "Diamond": "⋄", "diamondsuit": "♦", "diams": "♦", "die": "¨", "DifferentialD": "ⅆ", "digamma": "ϝ", "disin": "⋲", "div": "÷", "divide": "÷", "divideontimes": "⋇", "divonx": "⋇", "djcy": "ђ", "DJcy": "Ђ", "dlcorn": "⌞", "dlcrop": "⌍", "dollar": "$", "dopf": "𝕕", "Dopf": "𝔻", "dot": "˙", "Dot": "¨", "DotDot": "⃜", "doteq": "≐", "doteqdot": "≑", "DotEqual": "≐", "dotminus": "∸", "dotplus": "∔", "dotsquare": "⊡", "doublebarwedge": "⌆", "DoubleContourIntegral": "∯", "DoubleDot": "¨", "DoubleDownArrow": "⇓", "DoubleLeftArrow": "⇐", "DoubleLeftRightArrow": "⇔", "DoubleLeftTee": "⫤", "DoubleLongLeftArrow": "⟸", "DoubleLongLeftRightArrow": "⟺", "DoubleLongRightArrow": "⟹", "DoubleRightArrow": "⇒", "DoubleRightTee": "⊨", "DoubleUpArrow": "⇑", "DoubleUpDownArrow": "⇕", "DoubleVerticalBar": "∥", "downarrow": "↓", "Downarrow": "⇓", "DownArrow": "↓", "DownArrowBar": "⤓", "DownArrowUpArrow": "⇵", "DownBreve": "̑", "downdownarrows": "⇊", "downharpoonleft": "⇃", "downharpoonright": "⇂", "DownLeftRightVector": "⥐", "DownLeftTeeVector": "⥞", "DownLeftVector": "↽", "DownLeftVectorBar": "⥖", "DownRightTeeVector": "⥟", "DownRightVector": "⇁", "DownRightVectorBar": "⥗", "DownTee": "⊤", "DownTeeArrow": "↧", "drbkarow": "⤐", "drcorn": "⌟", "drcrop": "⌌", "dscr": "𝒹", "Dscr": "𝒟", "dscy": "ѕ", "DScy": "Ѕ", "dsol": "⧶", "dstrok": "đ", "Dstrok": "Đ", "dtdot": "⋱", "dtri": "▿", "dtrif": "▾", "duarr": "⇵", "duhar": "⥯", "dwangle": "⦦", "dzcy": "џ", "DZcy": "Џ", "dzigrarr": "⟿", "eacute": "é", "Eacute": "É", "easter": "⩮", "ecaron": "ě", "Ecaron": "Ě", "ecir": "≖", "ecirc": "ê", "Ecirc": "Ê", "ecolon": "≕", "ecy": "э", "Ecy": "Э", "eDDot": "⩷", "edot": "ė", "eDot": "≑", "Edot": "Ė", "ee": "ⅇ", "efDot": "≒", "efr": "𝔢", "Efr": "𝔈", "eg": "⪚", "egrave": "è", "Egrave": "È", "egs": "⪖", "egsdot": "⪘", "el": "⪙", "Element": "∈", "elinters": "⏧", "ell": "ℓ", "els": "⪕", "elsdot": "⪗", "emacr": "ē", "Emacr": "Ē", "empty": "∅", "emptyset": "∅", "EmptySmallSquare": "◻", "emptyv": "∅", "EmptyVerySmallSquare": "▫", "emsp": " ", "emsp13": " ", "emsp14": " ", "eng": "ŋ", "ENG": "Ŋ", "ensp": " ", "eogon": "ę", "Eogon": "Ę", "eopf": "𝕖", "Eopf": "𝔼", "epar": "⋕", "eparsl": "⧣", "eplus": "⩱", "epsi": "ε", "epsilon": "ε", "Epsilon": "Ε", "epsiv": "ϵ", "eqcirc": "≖", "eqcolon": "≕", "eqsim": "≂", "eqslantgtr": "⪖", "eqslantless": "⪕", "Equal": "⩵", "equals": "=", "EqualTilde": "≂", "equest": "≟", "Equilibrium": "⇌", "equiv": "≡", "equivDD": "⩸", "eqvparsl": "⧥", "erarr": "⥱", "erDot": "≓", "escr": "ℯ", "Escr": "ℰ", "esdot": "≐", "esim": "≂", "Esim": "⩳", "eta": "η", "Eta": "Η", "eth": "ð", "ETH": "Ð", "euml": "ë", "Euml": "Ë", "euro": "€", "excl": "!", "exist": "∃", "Exists": "∃", "expectation": "ℰ", "exponentiale": "ⅇ", "ExponentialE": "ⅇ", "fallingdotseq": "≒", "fcy": "ф", "Fcy": "Ф", "female": "♀", "ffilig": "ﬃ", "fflig": "ﬀ", "ffllig": "ﬄ", "ffr": "𝔣", "Ffr": "𝔉", "filig": "ﬁ", "FilledSmallSquare": "◼", "FilledVerySmallSquare": "▪", "fjlig": "fj", "flat": "♭", "fllig": "ﬂ", "fltns": "▱", "fnof": "ƒ", "fopf": "𝕗", "Fopf": "𝔽", "forall": "∀", "ForAll": "∀", "fork": "⋔", "forkv": "⫙", "Fouriertrf": "ℱ", "fpartint": "⨍", "frac12": "½", "frac13": "⅓", "frac14": "¼", "frac15": "⅕", "frac16": "⅙", "frac18": "⅛", "frac23": "⅔", "frac25": "⅖", "frac34": "¾", "frac35": "⅗", "frac38": "⅜", "frac45": "⅘", "frac56": "⅚", "frac58": "⅝", "frac78": "⅞", "frasl": "⁄", "frown": "⌢", "fscr": "𝒻", "Fscr": "ℱ", "gacute": "ǵ", "gamma": "γ", "Gamma": "Γ", "gammad": "ϝ", "Gammad": "Ϝ", "gap": "⪆", "gbreve": "ğ", "Gbreve": "Ğ", "Gcedil": "Ģ", "gcirc": "ĝ", "Gcirc": "Ĝ", "gcy": "г", "Gcy": "Г", "gdot": "ġ", "Gdot": "Ġ", "ge": "≥", "gE": "≧", "gel": "⋛", "gEl": "⪌", "geq": "≥", "geqq": "≧", "geqslant": "⩾", "ges": "⩾", "gescc": "⪩", "gesdot": "⪀", "gesdoto": "⪂", "gesdotol": "⪄", "gesl": "⋛︀", "gesles": "⪔", "gfr": "𝔤", "Gfr": "𝔊", "gg": "≫", "Gg": "⋙", "ggg": "⋙", "gimel": "ℷ", "gjcy": "ѓ", "GJcy": "Ѓ", "gl": "≷", "gla": "⪥", "glE": "⪒", "glj": "⪤", "gnap": "⪊", "gnapprox": "⪊", "gne": "⪈", "gnE": "≩", "gneq": "⪈", "gneqq": "≩", "gnsim": "⋧", "gopf": "𝕘", "Gopf": "𝔾", "grave": "`", "GreaterEqual": "≥", "GreaterEqualLess": "⋛", "GreaterFullEqual": "≧", "GreaterGreater": "⪢", "GreaterLess": "≷", "GreaterSlantEqual": "⩾", "GreaterTilde": "≳", "gscr": "ℊ", "Gscr": "𝒢", "gsim": "≳", "gsime": "⪎", "gsiml": "⪐", "gt": ">", "Gt": "≫", "GT": ">", "gtcc": "⪧", "gtcir": "⩺", "gtdot": "⋗", "gtlPar": "⦕", "gtquest": "⩼", "gtrapprox": "⪆", "gtrarr": "⥸", "gtrdot": "⋗", "gtreqless": "⋛", "gtreqqless": "⪌", "gtrless": "≷", "gtrsim": "≳", "gvertneqq": "≩︀", "gvnE": "≩︀", "Hacek": "ˇ", "hairsp": " ", "half": "½", "hamilt": "ℋ", "hardcy": "ъ", "HARDcy": "Ъ", "harr": "↔", "hArr": "⇔", "harrcir": "⥈", "harrw": "↭", "Hat": "^", "hbar": "ℏ", "hcirc": "ĥ", "Hcirc": "Ĥ", "hearts": "♥", "heartsuit": "♥", "hellip": "…", "hercon": "⊹", "hfr": "𝔥", "Hfr": "ℌ", "HilbertSpace": "ℋ", "hksearow": "⤥", "hkswarow": "⤦", "hoarr": "⇿", "homtht": "∻", "hookleftarrow": "↩", "hookrightarrow": "↪", "hopf": "𝕙", "Hopf": "ℍ", "horbar": "―", "HorizontalLine": "─", "hscr": "𝒽", "Hscr": "ℋ", "hslash": "ℏ", "hstrok": "ħ", "Hstrok": "Ħ", "HumpDownHump": "≎", "HumpEqual": "≏", "hybull": "⁃", "hyphen": "‐", "iacute": "í", "Iacute": "Í", "ic": "⁣", "icirc": "î", "Icirc": "Î", "icy": "и", "Icy": "И", "Idot": "İ", "iecy": "е", "IEcy": "Е", "iexcl": "¡", "iff": "⇔", "ifr": "𝔦", "Ifr": "ℑ", "igrave": "ì", "Igrave": "Ì", "ii": "ⅈ", "iiiint": "⨌", "iiint": "∭", "iinfin": "⧜", "iiota": "℩", "ijlig": "ĳ", "IJlig": "Ĳ", "Im": "ℑ", "imacr": "ī", "Imacr": "Ī", "image": "ℑ", "ImaginaryI": "ⅈ", "imagline": "ℐ", "imagpart": "ℑ", "imath": "ı", "imof": "⊷", "imped": "Ƶ", "Implies": "⇒", "in": "∈", "incare": "℅", "infin": "∞", "infintie": "⧝", "inodot": "ı", "int": "∫", "Int": "∬", "intcal": "⊺", "integers": "ℤ", "Integral": "∫", "intercal": "⊺", "Intersection": "⋂", "intlarhk": "⨗", "intprod": "⨼", "InvisibleComma": "⁣", "InvisibleTimes": "⁢", "iocy": "ё", "IOcy": "Ё", "iogon": "į", "Iogon": "Į", "iopf": "𝕚", "Iopf": "𝕀", "iota": "ι", "Iota": "Ι", "iprod": "⨼", "iquest": "¿", "iscr": "𝒾", "Iscr": "ℐ", "isin": "∈", "isindot": "⋵", "isinE": "⋹", "isins": "⋴", "isinsv": "⋳", "isinv": "∈", "it": "⁢", "itilde": "ĩ", "Itilde": "Ĩ", "iukcy": "і", "Iukcy": "І", "iuml": "ï", "Iuml": "Ï", "jcirc": "ĵ", "Jcirc": "Ĵ", "jcy": "й", "Jcy": "Й", "jfr": "𝔧", "Jfr": "𝔍", "jmath": "ȷ", "jopf": "𝕛", "Jopf": "𝕁", "jscr": "𝒿", "Jscr": "𝒥", "jsercy": "ј", "Jsercy": "Ј", "jukcy": "є", "Jukcy": "Є", "kappa": "κ", "Kappa": "Κ", "kappav": "ϰ", "kcedil": "ķ", "Kcedil": "Ķ", "kcy": "к", "Kcy": "К", "kfr": "𝔨", "Kfr": "𝔎", "kgreen": "ĸ", "khcy": "х", "KHcy": "Х", "kjcy": "ќ", "KJcy": "Ќ", "kopf": "𝕜", "Kopf": "𝕂", "kscr": "𝓀", "Kscr": "𝒦", "lAarr": "⇚", "lacute": "ĺ", "Lacute": "Ĺ", "laemptyv": "⦴", "lagran": "ℒ", "lambda": "λ", "Lambda": "Λ", "lang": "⟨", "Lang": "⟪", "langd": "⦑", "langle": "⟨", "lap": "⪅", "Laplacetrf": "ℒ", "laquo": "«", "larr": "←", "lArr": "⇐", "Larr": "↞", "larrb": "⇤", "larrbfs": "⤟", "larrfs": "⤝", "larrhk": "↩", "larrlp": "↫", "larrpl": "⤹", "larrsim": "⥳", "larrtl": "↢", "lat": "⪫", "latail": "⤙", "lAtail": "⤛", "late": "⪭", "lates": "⪭︀", "lbarr": "⤌", "lBarr": "⤎", "lbbrk": "❲", "lbrace": "{", "lbrack": "[", "lbrke": "⦋", "lbrksld": "⦏", "lbrkslu": "⦍", "lcaron": "ľ", "Lcaron": "Ľ", "lcedil": "ļ", "Lcedil": "Ļ", "lceil": "⌈", "lcub": "{", "lcy": "л", "Lcy": "Л", "ldca": "⤶", "ldquo": "“", "ldquor": "„", "ldrdhar": "⥧", "ldrushar": "⥋", "ldsh": "↲", "le": "≤", "lE": "≦", "LeftAngleBracket": "⟨", "leftarrow": "←", "Leftarrow": "⇐", "LeftArrow": "←", "LeftArrowBar": "⇤", "LeftArrowRightArrow": "⇆", "leftarrowtail": "↢", "LeftCeiling": "⌈", "LeftDoubleBracket": "⟦", "LeftDownTeeVector": "⥡", "LeftDownVector": "⇃", "LeftDownVectorBar": "⥙", "LeftFloor": "⌊", "leftharpoondown": "↽", "leftharpoonup": "↼", "leftleftarrows": "⇇", "leftrightarrow": "↔", "Leftrightarrow": "⇔", "LeftRightArrow": "↔", "leftrightarrows": "⇆", "leftrightharpoons": "⇋", "leftrightsquigarrow": "↭", "LeftRightVector": "⥎", "LeftTee": "⊣", "LeftTeeArrow": "↤", "LeftTeeVector": "⥚", "leftthreetimes": "⋋", "LeftTriangle": "⊲", "LeftTriangleBar": "⧏", "LeftTriangleEqual": "⊴", "LeftUpDownVector": "⥑", "LeftUpTeeVector": "⥠", "LeftUpVector": "↿", "LeftUpVectorBar": "⥘", "LeftVector": "↼", "LeftVectorBar": "⥒", "leg": "⋚", "lEg": "⪋", "leq": "≤", "leqq": "≦", "leqslant": "⩽", "les": "⩽", "lescc": "⪨", "lesdot": "⩿", "lesdoto": "⪁", "lesdotor": "⪃", "lesg": "⋚︀", "lesges": "⪓", "lessapprox": "⪅", "lessdot": "⋖", "lesseqgtr": "⋚", "lesseqqgtr": "⪋", "LessEqualGreater": "⋚", "LessFullEqual": "≦", "LessGreater": "≶", "lessgtr": "≶", "LessLess": "⪡", "lesssim": "≲", "LessSlantEqual": "⩽", "LessTilde": "≲", "lfisht": "⥼", "lfloor": "⌊", "lfr": "𝔩", "Lfr": "𝔏", "lg": "≶", "lgE": "⪑", "lHar": "⥢", "lhard": "↽", "lharu": "↼", "lharul": "⥪", "lhblk": "▄", "ljcy": "љ", "LJcy": "Љ", "ll": "≪", "Ll": "⋘", "llarr": "⇇", "llcorner": "⌞", "Lleftarrow": "⇚", "llhard": "⥫", "lltri": "◺", "lmidot": "ŀ", "Lmidot": "Ŀ", "lmoust": "⎰", "lmoustache": "⎰", "lnap": "⪉", "lnapprox": "⪉", "lne": "⪇", "lnE": "≨", "lneq": "⪇", "lneqq": "≨", "lnsim": "⋦", "loang": "⟬", "loarr": "⇽", "lobrk": "⟦", "longleftarrow": "⟵", "Longleftarrow": "⟸", "LongLeftArrow": "⟵", "longleftrightarrow": "⟷", "Longleftrightarrow": "⟺", "LongLeftRightArrow": "⟷", "longmapsto": "⟼", "longrightarrow": "⟶", "Longrightarrow": "⟹", "LongRightArrow": "⟶", "looparrowleft": "↫", "looparrowright": "↬", "lopar": "⦅", "lopf": "𝕝", "Lopf": "𝕃", "loplus": "⨭", "lotimes": "⨴", "lowast": "∗", "lowbar": "_", "LowerLeftArrow": "↙", "LowerRightArrow": "↘", "loz": "◊", "lozenge": "◊", "lozf": "⧫", "lpar": "(", "lparlt": "⦓", "lrarr": "⇆", "lrcorner": "⌟", "lrhar": "⇋", "lrhard": "⥭", "lrm": "‎", "lrtri": "⊿", "lsaquo": "‹", "lscr": "𝓁", "Lscr": "ℒ", "lsh": "↰", "Lsh": "↰", "lsim": "≲", "lsime": "⪍", "lsimg": "⪏", "lsqb": "[", "lsquo": "‘", "lsquor": "‚", "lstrok": "ł", "Lstrok": "Ł", "lt": "<", "Lt": "≪", "LT": "<", "ltcc": "⪦", "ltcir": "⩹", "ltdot": "⋖", "lthree": "⋋", "ltimes": "⋉", "ltlarr": "⥶", "ltquest": "⩻", "ltri": "◃", "ltrie": "⊴", "ltrif": "◂", "ltrPar": "⦖", "lurdshar": "⥊", "luruhar": "⥦", "lvertneqq": "≨︀", "lvnE": "≨︀", "macr": "¯", "male": "♂", "malt": "✠", "maltese": "✠", "map": "↦", "Map": "⤅", "mapsto": "↦", "mapstodown": "↧", "mapstoleft": "↤", "mapstoup": "↥", "marker": "▮", "mcomma": "⨩", "mcy": "м", "Mcy": "М", "mdash": "—", "mDDot": "∺", "measuredangle": "∡", "MediumSpace": " ", "Mellintrf": "ℳ", "mfr": "𝔪", "Mfr": "𝔐", "mho": "℧", "micro": "µ", "mid": "∣", "midast": "*", "midcir": "⫰", "middot": "·", "minus": "−", "minusb": "⊟", "minusd": "∸", "minusdu": "⨪", "MinusPlus": "∓", "mlcp": "⫛", "mldr": "…", "mnplus": "∓", "models": "⊧", "mopf": "𝕞", "Mopf": "𝕄", "mp": "∓", "mscr": "𝓂", "Mscr": "ℳ", "mstpos": "∾", "mu": "μ", "Mu": "Μ", "multimap": "⊸", "mumap": "⊸", "nabla": "∇", "nacute": "ń", "Nacute": "Ń", "nang": "∠⃒", "nap": "≉", "napE": "⩰̸", "napid": "≋̸", "napos": "ŉ", "napprox": "≉", "natur": "♮", "natural": "♮", "naturals": "ℕ", "nbsp": " ", "nbump": "≎̸", "nbumpe": "≏̸", "ncap": "⩃", "ncaron": "ň", "Ncaron": "Ň", "ncedil": "ņ", "Ncedil": "Ņ", "ncong": "≇", "ncongdot": "⩭̸", "ncup": "⩂", "ncy": "н", "Ncy": "Н", "ndash": "–", "ne": "≠", "nearhk": "⤤", "nearr": "↗", "neArr": "⇗", "nearrow": "↗", "nedot": "≐̸", "NegativeMediumSpace": "​", "NegativeThickSpace": "​", "NegativeThinSpace": "​", "NegativeVeryThinSpace": "​", "nequiv": "≢", "nesear": "⤨", "nesim": "≂̸", "NestedGreaterGreater": "≫", "NestedLessLess": "≪", "NewLine": "\n", "nexist": "∄", "nexists": "∄", "nfr": "𝔫", "Nfr": "𝔑", "nge": "≱", "ngE": "≧̸", "ngeq": "≱", "ngeqq": "≧̸", "ngeqslant": "⩾̸", "nges": "⩾̸", "nGg": "⋙̸", "ngsim": "≵", "ngt": "≯", "nGt": "≫⃒", "ngtr": "≯", "nGtv": "≫̸", "nharr": "↮", "nhArr": "⇎", "nhpar": "⫲", "ni": "∋", "nis": "⋼", "nisd": "⋺", "niv": "∋", "njcy": "њ", "NJcy": "Њ", "nlarr": "↚", "nlArr": "⇍", "nldr": "‥", "nle": "≰", "nlE": "≦̸", "nleftarrow": "↚", "nLeftarrow": "⇍", "nleftrightarrow": "↮", "nLeftrightarrow": "⇎", "nleq": "≰", "nleqq": "≦̸", "nleqslant": "⩽̸", "nles": "⩽̸", "nless": "≮", "nLl": "⋘̸", "nlsim": "≴", "nlt": "≮", "nLt": "≪⃒", "nltri": "⋪", "nltrie": "⋬", "nLtv": "≪̸", "nmid": "∤", "NoBreak": "⁠", "NonBreakingSpace": " ", "nopf": "𝕟", "Nopf": "ℕ", "not": "¬", "Not": "⫬", "NotCongruent": "≢", "NotCupCap": "≭", "NotDoubleVerticalBar": "∦", "NotElement": "∉", "NotEqual": "≠", "NotEqualTilde": "≂̸", "NotExists": "∄", "NotGreater": "≯", "NotGreaterEqual": "≱", "NotGreaterFullEqual": "≧̸", "NotGreaterGreater": "≫̸", "NotGreaterLess": "≹", "NotGreaterSlantEqual": "⩾̸", "NotGreaterTilde": "≵", "NotHumpDownHump": "≎̸", "NotHumpEqual": "≏̸", "notin": "∉", "notindot": "⋵̸", "notinE": "⋹̸", "notinva": "∉", "notinvb": "⋷", "notinvc": "⋶", "NotLeftTriangle": "⋪", "NotLeftTriangleBar": "⧏̸", "NotLeftTriangleEqual": "⋬", "NotLess": "≮", "NotLessEqual": "≰", "NotLessGreater": "≸", "NotLessLess": "≪̸", "NotLessSlantEqual": "⩽̸", "NotLessTilde": "≴", "NotNestedGreaterGreater": "⪢̸", "NotNestedLessLess": "⪡̸", "notni": "∌", "notniva": "∌", "notnivb": "⋾", "notnivc": "⋽", "NotPrecedes": "⊀", "NotPrecedesEqual": "⪯̸", "NotPrecedesSlantEqual": "⋠", "NotReverseElement": "∌", "NotRightTriangle": "⋫", "NotRightTriangleBar": "⧐̸", "NotRightTriangleEqual": "⋭", "NotSquareSubset": "⊏̸", "NotSquareSubsetEqual": "⋢", "NotSquareSuperset": "⊐̸", "NotSquareSupersetEqual": "⋣", "NotSubset": "⊂⃒", "NotSubsetEqual": "⊈", "NotSucceeds": "⊁", "NotSucceedsEqual": "⪰̸", "NotSucceedsSlantEqual": "⋡", "NotSucceedsTilde": "≿̸", "NotSuperset": "⊃⃒", "NotSupersetEqual": "⊉", "NotTilde": "≁", "NotTildeEqual": "≄", "NotTildeFullEqual": "≇", "NotTildeTilde": "≉", "NotVerticalBar": "∤", "npar": "∦", "nparallel": "∦", "nparsl": "⫽⃥", "npart": "∂̸", "npolint": "⨔", "npr": "⊀", "nprcue": "⋠", "npre": "⪯̸", "nprec": "⊀", "npreceq": "⪯̸", "nrarr": "↛", "nrArr": "⇏", "nrarrc": "⤳̸", "nrarrw": "↝̸", "nrightarrow": "↛", "nRightarrow": "⇏", "nrtri": "⋫", "nrtrie": "⋭", "nsc": "⊁", "nsccue": "⋡", "nsce": "⪰̸", "nscr": "𝓃", "Nscr": "𝒩", "nshortmid": "∤", "nshortparallel": "∦", "nsim": "≁", "nsime": "≄", "nsimeq": "≄", "nsmid": "∤", "nspar": "∦", "nsqsube": "⋢", "nsqsupe": "⋣", "nsub": "⊄", "nsube": "⊈", "nsubE": "⫅̸", "nsubset": "⊂⃒", "nsubseteq": "⊈", "nsubseteqq": "⫅̸", "nsucc": "⊁", "nsucceq": "⪰̸", "nsup": "⊅", "nsupe": "⊉", "nsupE": "⫆̸", "nsupset": "⊃⃒", "nsupseteq": "⊉", "nsupseteqq": "⫆̸", "ntgl": "≹", "ntilde": "ñ", "Ntilde": "Ñ", "ntlg": "≸", "ntriangleleft": "⋪", "ntrianglelefteq": "⋬", "ntriangleright": "⋫", "ntrianglerighteq": "⋭", "nu": "ν", "Nu": "Ν", "num": "#", "numero": "№", "numsp": " ", "nvap": "≍⃒", "nvdash": "⊬", "nvDash": "⊭", "nVdash": "⊮", "nVDash": "⊯", "nvge": "≥⃒", "nvgt": ">⃒", "nvHarr": "⤄", "nvinfin": "⧞", "nvlArr": "⤂", "nvle": "≤⃒", "nvlt": "<⃒", "nvltrie": "⊴⃒", "nvrArr": "⤃", "nvrtrie": "⊵⃒", "nvsim": "∼⃒", "nwarhk": "⤣", "nwarr": "↖", "nwArr": "⇖", "nwarrow": "↖", "nwnear": "⤧", "oacute": "ó", "Oacute": "Ó", "oast": "⊛", "ocir": "⊚", "ocirc": "ô", "Ocirc": "Ô", "ocy": "о", "Ocy": "О", "odash": "⊝", "odblac": "ő", "Odblac": "Ő", "odiv": "⨸", "odot": "⊙", "odsold": "⦼", "oelig": "œ", "OElig": "Œ", "ofcir": "⦿", "ofr": "𝔬", "Ofr": "𝔒", "ogon": "˛", "ograve": "ò", "Ograve": "Ò", "ogt": "⧁", "ohbar": "⦵", "ohm": "Ω", "oint": "∮", "olarr": "↺", "olcir": "⦾", "olcross": "⦻", "oline": "‾", "olt": "⧀", "omacr": "ō", "Omacr": "Ō", "omega": "ω", "Omega": "Ω", "omicron": "ο", "Omicron": "Ο", "omid": "⦶", "ominus": "⊖", "oopf": "𝕠", "Oopf": "𝕆", "opar": "⦷", "OpenCurlyDoubleQuote": "“", "OpenCurlyQuote": "‘", "operp": "⦹", "oplus": "⊕", "or": "∨", "Or": "⩔", "orarr": "↻", "ord": "⩝", "order": "ℴ", "orderof": "ℴ", "ordf": "ª", "ordm": "º", "origof": "⊶", "oror": "⩖", "orslope": "⩗", "orv": "⩛", "oS": "Ⓢ", "oscr": "ℴ", "Oscr": "𝒪", "oslash": "ø", "Oslash": "Ø", "osol": "⊘", "otilde": "õ", "Otilde": "Õ", "otimes": "⊗", "Otimes": "⨷", "otimesas": "⨶", "ouml": "ö", "Ouml": "Ö", "ovbar": "⌽", "OverBar": "‾", "OverBrace": "⏞", "OverBracket": "⎴", "OverParenthesis": "⏜", "par": "∥", "para": "¶", "parallel": "∥", "parsim": "⫳", "parsl": "⫽", "part": "∂", "PartialD": "∂", "pcy": "п", "Pcy": "П", "percnt": "%", "period": ".", "permil": "‰", "perp": "⊥", "pertenk": "‱", "pfr": "𝔭", "Pfr": "𝔓", "phi": "φ", "Phi": "Φ", "phiv": "ϕ", "phmmat": "ℳ", "phone": "☎", "pi": "π", "Pi": "Π", "pitchfork": "⋔", "piv": "ϖ", "planck": "ℏ", "planckh": "ℎ", "plankv": "ℏ", "plus": "+", "plusacir": "⨣", "plusb": "⊞", "pluscir": "⨢", "plusdo": "∔", "plusdu": "⨥", "pluse": "⩲", "PlusMinus": "±", "plusmn": "±", "plussim": "⨦", "plustwo": "⨧", "pm": "±", "Poincareplane": "ℌ", "pointint": "⨕", "popf": "𝕡", "Popf": "ℙ", "pound": "£", "pr": "≺", "Pr": "⪻", "prap": "⪷", "prcue": "≼", "pre": "⪯", "prE": "⪳", "prec": "≺", "precapprox": "⪷", "preccurlyeq": "≼", "Precedes": "≺", "PrecedesEqual": "⪯", "PrecedesSlantEqual": "≼", "PrecedesTilde": "≾", "preceq": "⪯", "precnapprox": "⪹", "precneqq": "⪵", "precnsim": "⋨", "precsim": "≾", "prime": "′", "Prime": "″", "primes": "ℙ", "prnap": "⪹", "prnE": "⪵", "prnsim": "⋨", "prod": "∏", "Product": "∏", "profalar": "⌮", "profline": "⌒", "profsurf": "⌓", "prop": "∝", "Proportion": "∷", "Proportional": "∝", "propto": "∝", "prsim": "≾", "prurel": "⊰", "pscr": "𝓅", "Pscr": "𝒫", "psi": "ψ", "Psi": "Ψ", "puncsp": " ", "qfr": "𝔮", "Qfr": "𝔔", "qint": "⨌", "qopf": "𝕢", "Qopf": "ℚ", "qprime": "⁗", "qscr": "𝓆", "Qscr": "𝒬", "quaternions": "ℍ", "quatint": "⨖", "quest": "?", "questeq": "≟", "quot": '"', "QUOT": '"', "rAarr": "⇛", "race": "∽̱", "racute": "ŕ", "Racute": "Ŕ", "radic": "√", "raemptyv": "⦳", "rang": "⟩", "Rang": "⟫", "rangd": "⦒", "range": "⦥", "rangle": "⟩", "raquo": "»", "rarr": "→", "rArr": "⇒", "Rarr": "↠", "rarrap": "⥵", "rarrb": "⇥", "rarrbfs": "⤠", "rarrc": "⤳", "rarrfs": "⤞", "rarrhk": "↪", "rarrlp": "↬", "rarrpl": "⥅", "rarrsim": "⥴", "rarrtl": "↣", "Rarrtl": "⤖", "rarrw": "↝", "ratail": "⤚", "rAtail": "⤜", "ratio": "∶", "rationals": "ℚ", "rbarr": "⤍", "rBarr": "⤏", "RBarr": "⤐", "rbbrk": "❳", "rbrace": "}", "rbrack": "]", "rbrke": "⦌", "rbrksld": "⦎", "rbrkslu": "⦐", "rcaron": "ř", "Rcaron": "Ř", "rcedil": "ŗ", "Rcedil": "Ŗ", "rceil": "⌉", "rcub": "}", "rcy": "р", "Rcy": "Р", "rdca": "⤷", "rdldhar": "⥩", "rdquo": "”", "rdquor": "”", "rdsh": "↳", "Re": "ℜ", "real": "ℜ", "realine": "ℛ", "realpart": "ℜ", "reals": "ℝ", "rect": "▭", "reg": "®", "REG": "®", "ReverseElement": "∋", "ReverseEquilibrium": "⇋", "ReverseUpEquilibrium": "⥯", "rfisht": "⥽", "rfloor": "⌋", "rfr": "𝔯", "Rfr": "ℜ", "rHar": "⥤", "rhard": "⇁", "rharu": "⇀", "rharul": "⥬", "rho": "ρ", "Rho": "Ρ", "rhov": "ϱ", "RightAngleBracket": "⟩", "rightarrow": "→", "Rightarrow": "⇒", "RightArrow": "→", "RightArrowBar": "⇥", "RightArrowLeftArrow": "⇄", "rightarrowtail": "↣", "RightCeiling": "⌉", "RightDoubleBracket": "⟧", "RightDownTeeVector": "⥝", "RightDownVector": "⇂", "RightDownVectorBar": "⥕", "RightFloor": "⌋", "rightharpoondown": "⇁", "rightharpoonup": "⇀", "rightleftarrows": "⇄", "rightleftharpoons": "⇌", "rightrightarrows": "⇉", "rightsquigarrow": "↝", "RightTee": "⊢", "RightTeeArrow": "↦", "RightTeeVector": "⥛", "rightthreetimes": "⋌", "RightTriangle": "⊳", "RightTriangleBar": "⧐", "RightTriangleEqual": "⊵", "RightUpDownVector": "⥏", "RightUpTeeVector": "⥜", "RightUpVector": "↾", "RightUpVectorBar": "⥔", "RightVector": "⇀", "RightVectorBar": "⥓", "ring": "˚", "risingdotseq": "≓", "rlarr": "⇄", "rlhar": "⇌", "rlm": "‏", "rmoust": "⎱", "rmoustache": "⎱", "rnmid": "⫮", "roang": "⟭", "roarr": "⇾", "robrk": "⟧", "ropar": "⦆", "ropf": "𝕣", "Ropf": "ℝ", "roplus": "⨮", "rotimes": "⨵", "RoundImplies": "⥰", "rpar": ")", "rpargt": "⦔", "rppolint": "⨒", "rrarr": "⇉", "Rrightarrow": "⇛", "rsaquo": "›", "rscr": "𝓇", "Rscr": "ℛ", "rsh": "↱", "Rsh": "↱", "rsqb": "]", "rsquo": "’", "rsquor": "’", "rthree": "⋌", "rtimes": "⋊", "rtri": "▹", "rtrie": "⊵", "rtrif": "▸", "rtriltri": "⧎", "RuleDelayed": "⧴", "ruluhar": "⥨", "rx": "℞", "sacute": "ś", "Sacute": "Ś", "sbquo": "‚", "sc": "≻", "Sc": "⪼", "scap": "⪸", "scaron": "š", "Scaron": "Š", "sccue": "≽", "sce": "⪰", "scE": "⪴", "scedil": "ş", "Scedil": "Ş", "scirc": "ŝ", "Scirc": "Ŝ", "scnap": "⪺", "scnE": "⪶", "scnsim": "⋩", "scpolint": "⨓", "scsim": "≿", "scy": "с", "Scy": "С", "sdot": "⋅", "sdotb": "⊡", "sdote": "⩦", "searhk": "⤥", "searr": "↘", "seArr": "⇘", "searrow": "↘", "sect": "§", "semi": ";", "seswar": "⤩", "setminus": "∖", "setmn": "∖", "sext": "✶", "sfr": "𝔰", "Sfr": "𝔖", "sfrown": "⌢", "sharp": "♯", "shchcy": "щ", "SHCHcy": "Щ", "shcy": "ш", "SHcy": "Ш", "ShortDownArrow": "↓", "ShortLeftArrow": "←", "shortmid": "∣", "shortparallel": "∥", "ShortRightArrow": "→", "ShortUpArrow": "↑", "shy": "­", "sigma": "σ", "Sigma": "Σ", "sigmaf": "ς", "sigmav": "ς", "sim": "∼", "simdot": "⩪", "sime": "≃", "simeq": "≃", "simg": "⪞", "simgE": "⪠", "siml": "⪝", "simlE": "⪟", "simne": "≆", "simplus": "⨤", "simrarr": "⥲", "slarr": "←", "SmallCircle": "∘", "smallsetminus": "∖", "smashp": "⨳", "smeparsl": "⧤", "smid": "∣", "smile": "⌣", "smt": "⪪", "smte": "⪬", "smtes": "⪬︀", "softcy": "ь", "SOFTcy": "Ь", "sol": "/", "solb": "⧄", "solbar": "⌿", "sopf": "𝕤", "Sopf": "𝕊", "spades": "♠", "spadesuit": "♠", "spar": "∥", "sqcap": "⊓", "sqcaps": "⊓︀", "sqcup": "⊔", "sqcups": "⊔︀", "Sqrt": "√", "sqsub": "⊏", "sqsube": "⊑", "sqsubset": "⊏", "sqsubseteq": "⊑", "sqsup": "⊐", "sqsupe": "⊒", "sqsupset": "⊐", "sqsupseteq": "⊒", "squ": "□", "square": "□", "Square": "□", "SquareIntersection": "⊓", "SquareSubset": "⊏", "SquareSubsetEqual": "⊑", "SquareSuperset": "⊐", "SquareSupersetEqual": "⊒", "SquareUnion": "⊔", "squarf": "▪", "squf": "▪", "srarr": "→", "sscr": "𝓈", "Sscr": "𝒮", "ssetmn": "∖", "ssmile": "⌣", "sstarf": "⋆", "star": "☆", "Star": "⋆", "starf": "★", "straightepsilon": "ϵ", "straightphi": "ϕ", "strns": "¯", "sub": "⊂", "Sub": "⋐", "subdot": "⪽", "sube": "⊆", "subE": "⫅", "subedot": "⫃", "submult": "⫁", "subne": "⊊", "subnE": "⫋", "subplus": "⪿", "subrarr": "⥹", "subset": "⊂", "Subset": "⋐", "subseteq": "⊆", "subseteqq": "⫅", "SubsetEqual": "⊆", "subsetneq": "⊊", "subsetneqq": "⫋", "subsim": "⫇", "subsub": "⫕", "subsup": "⫓", "succ": "≻", "succapprox": "⪸", "succcurlyeq": "≽", "Succeeds": "≻", "SucceedsEqual": "⪰", "SucceedsSlantEqual": "≽", "SucceedsTilde": "≿", "succeq": "⪰", "succnapprox": "⪺", "succneqq": "⪶", "succnsim": "⋩", "succsim": "≿", "SuchThat": "∋", "sum": "∑", "Sum": "∑", "sung": "♪", "sup": "⊃", "Sup": "⋑", "sup1": "¹", "sup2": "²", "sup3": "³", "supdot": "⪾", "supdsub": "⫘", "supe": "⊇", "supE": "⫆", "supedot": "⫄", "Superset": "⊃", "SupersetEqual": "⊇", "suphsol": "⟉", "suphsub": "⫗", "suplarr": "⥻", "supmult": "⫂", "supne": "⊋", "supnE": "⫌", "supplus": "⫀", "supset": "⊃", "Supset": "⋑", "supseteq": "⊇", "supseteqq": "⫆", "supsetneq": "⊋", "supsetneqq": "⫌", "supsim": "⫈", "supsub": "⫔", "supsup": "⫖", "swarhk": "⤦", "swarr": "↙", "swArr": "⇙", "swarrow": "↙", "swnwar": "⤪", "szlig": "ß", "Tab": "	", "target": "⌖", "tau": "τ", "Tau": "Τ", "tbrk": "⎴", "tcaron": "ť", "Tcaron": "Ť", "tcedil": "ţ", "Tcedil": "Ţ", "tcy": "т", "Tcy": "Т", "tdot": "⃛", "telrec": "⌕", "tfr": "𝔱", "Tfr": "𝔗", "there4": "∴", "therefore": "∴", "Therefore": "∴", "theta": "θ", "Theta": "Θ", "thetasym": "ϑ", "thetav": "ϑ", "thickapprox": "≈", "thicksim": "∼", "ThickSpace": "  ", "thinsp": " ", "ThinSpace": " ", "thkap": "≈", "thksim": "∼", "thorn": "þ", "THORN": "Þ", "tilde": "˜", "Tilde": "∼", "TildeEqual": "≃", "TildeFullEqual": "≅", "TildeTilde": "≈", "times": "×", "timesb": "⊠", "timesbar": "⨱", "timesd": "⨰", "tint": "∭", "toea": "⤨", "top": "⊤", "topbot": "⌶", "topcir": "⫱", "topf": "𝕥", "Topf": "𝕋", "topfork": "⫚", "tosa": "⤩", "tprime": "‴", "trade": "™", "TRADE": "™", "triangle": "▵", "triangledown": "▿", "triangleleft": "◃", "trianglelefteq": "⊴", "triangleq": "≜", "triangleright": "▹", "trianglerighteq": "⊵", "tridot": "◬", "trie": "≜", "triminus": "⨺", "TripleDot": "⃛", "triplus": "⨹", "trisb": "⧍", "tritime": "⨻", "trpezium": "⏢", "tscr": "𝓉", "Tscr": "𝒯", "tscy": "ц", "TScy": "Ц", "tshcy": "ћ", "TSHcy": "Ћ", "tstrok": "ŧ", "Tstrok": "Ŧ", "twixt": "≬", "twoheadleftarrow": "↞", "twoheadrightarrow": "↠", "uacute": "ú", "Uacute": "Ú", "uarr": "↑", "uArr": "⇑", "Uarr": "↟", "Uarrocir": "⥉", "ubrcy": "ў", "Ubrcy": "Ў", "ubreve": "ŭ", "Ubreve": "Ŭ", "ucirc": "û", "Ucirc": "Û", "ucy": "у", "Ucy": "У", "udarr": "⇅", "udblac": "ű", "Udblac": "Ű", "udhar": "⥮", "ufisht": "⥾", "ufr": "𝔲", "Ufr": "𝔘", "ugrave": "ù", "Ugrave": "Ù", "uHar": "⥣", "uharl": "↿", "uharr": "↾", "uhblk": "▀", "ulcorn": "⌜", "ulcorner": "⌜", "ulcrop": "⌏", "ultri": "◸", "umacr": "ū", "Umacr": "Ū", "uml": "¨", "UnderBar": "_", "UnderBrace": "⏟", "UnderBracket": "⎵", "UnderParenthesis": "⏝", "Union": "⋃", "UnionPlus": "⊎", "uogon": "ų", "Uogon": "Ų", "uopf": "𝕦", "Uopf": "𝕌", "uparrow": "↑", "Uparrow": "⇑", "UpArrow": "↑", "UpArrowBar": "⤒", "UpArrowDownArrow": "⇅", "updownarrow": "↕", "Updownarrow": "⇕", "UpDownArrow": "↕", "UpEquilibrium": "⥮", "upharpoonleft": "↿", "upharpoonright": "↾", "uplus": "⊎", "UpperLeftArrow": "↖", "UpperRightArrow": "↗", "upsi": "υ", "Upsi": "ϒ", "upsih": "ϒ", "upsilon": "υ", "Upsilon": "Υ", "UpTee": "⊥", "UpTeeArrow": "↥", "upuparrows": "⇈", "urcorn": "⌝", "urcorner": "⌝", "urcrop": "⌎", "uring": "ů", "Uring": "Ů", "urtri": "◹", "uscr": "𝓊", "Uscr": "𝒰", "utdot": "⋰", "utilde": "ũ", "Utilde": "Ũ", "utri": "▵", "utrif": "▴", "uuarr": "⇈", "uuml": "ü", "Uuml": "Ü", "uwangle": "⦧", "vangrt": "⦜", "varepsilon": "ϵ", "varkappa": "ϰ", "varnothing": "∅", "varphi": "ϕ", "varpi": "ϖ", "varpropto": "∝", "varr": "↕", "vArr": "⇕", "varrho": "ϱ", "varsigma": "ς", "varsubsetneq": "⊊︀", "varsubsetneqq": "⫋︀", "varsupsetneq": "⊋︀", "varsupsetneqq": "⫌︀", "vartheta": "ϑ", "vartriangleleft": "⊲", "vartriangleright": "⊳", "vBar": "⫨", "Vbar": "⫫", "vBarv": "⫩", "vcy": "в", "Vcy": "В", "vdash": "⊢", "vDash": "⊨", "Vdash": "⊩", "VDash": "⊫", "Vdashl": "⫦", "vee": "∨", "Vee": "⋁", "veebar": "⊻", "veeeq": "≚", "vellip": "⋮", "verbar": "|", "Verbar": "‖", "vert": "|", "Vert": "‖", "VerticalBar": "∣", "VerticalLine": "|", "VerticalSeparator": "❘", "VerticalTilde": "≀", "VeryThinSpace": " ", "vfr": "𝔳", "Vfr": "𝔙", "vltri": "⊲", "vnsub": "⊂⃒", "vnsup": "⊃⃒", "vopf": "𝕧", "Vopf": "𝕍", "vprop": "∝", "vrtri": "⊳", "vscr": "𝓋", "Vscr": "𝒱", "vsubne": "⊊︀", "vsubnE": "⫋︀", "vsupne": "⊋︀", "vsupnE": "⫌︀", "Vvdash": "⊪", "vzigzag": "⦚", "wcirc": "ŵ", "Wcirc": "Ŵ", "wedbar": "⩟", "wedge": "∧", "Wedge": "⋀", "wedgeq": "≙", "weierp": "℘", "wfr": "𝔴", "Wfr": "𝔚", "wopf": "𝕨", "Wopf": "𝕎", "wp": "℘", "wr": "≀", "wreath": "≀", "wscr": "𝓌", "Wscr": "𝒲", "xcap": "⋂", "xcirc": "◯", "xcup": "⋃", "xdtri": "▽", "xfr": "𝔵", "Xfr": "𝔛", "xharr": "⟷", "xhArr": "⟺", "xi": "ξ", "Xi": "Ξ", "xlarr": "⟵", "xlArr": "⟸", "xmap": "⟼", "xnis": "⋻", "xodot": "⨀", "xopf": "𝕩", "Xopf": "𝕏", "xoplus": "⨁", "xotime": "⨂", "xrarr": "⟶", "xrArr": "⟹", "xscr": "𝓍", "Xscr": "𝒳", "xsqcup": "⨆", "xuplus": "⨄", "xutri": "△", "xvee": "⋁", "xwedge": "⋀", "yacute": "ý", "Yacute": "Ý", "yacy": "я", "YAcy": "Я", "ycirc": "ŷ", "Ycirc": "Ŷ", "ycy": "ы", "Ycy": "Ы", "yen": "¥", "yfr": "𝔶", "Yfr": "𝔜", "yicy": "ї", "YIcy": "Ї", "yopf": "𝕪", "Yopf": "𝕐", "yscr": "𝓎", "Yscr": "𝒴", "yucy": "ю", "YUcy": "Ю", "yuml": "ÿ", "Yuml": "Ÿ", "zacute": "ź", "Zacute": "Ź", "zcaron": "ž", "Zcaron": "Ž", "zcy": "з", "Zcy": "З", "zdot": "ż", "Zdot": "Ż", "zeetrf": "ℨ", "ZeroWidthSpace": "​", "zeta": "ζ", "Zeta": "Ζ", "zfr": "𝔷", "Zfr": "ℨ", "zhcy": "ж", "ZHcy": "Ж", "zigrarr": "⇝", "zopf": "𝕫", "Zopf": "ℤ", "zscr": "𝓏", "Zscr": "𝒵", "zwj": "‍", "zwnj": "‌" };
      var decodeMapLegacy = { "aacute": "á", "Aacute": "Á", "acirc": "â", "Acirc": "Â", "acute": "´", "aelig": "æ", "AElig": "Æ", "agrave": "à", "Agrave": "À", "amp": "&", "AMP": "&", "aring": "å", "Aring": "Å", "atilde": "ã", "Atilde": "Ã", "auml": "ä", "Auml": "Ä", "brvbar": "¦", "ccedil": "ç", "Ccedil": "Ç", "cedil": "¸", "cent": "¢", "copy": "©", "COPY": "©", "curren": "¤", "deg": "°", "divide": "÷", "eacute": "é", "Eacute": "É", "ecirc": "ê", "Ecirc": "Ê", "egrave": "è", "Egrave": "È", "eth": "ð", "ETH": "Ð", "euml": "ë", "Euml": "Ë", "frac12": "½", "frac14": "¼", "frac34": "¾", "gt": ">", "GT": ">", "iacute": "í", "Iacute": "Í", "icirc": "î", "Icirc": "Î", "iexcl": "¡", "igrave": "ì", "Igrave": "Ì", "iquest": "¿", "iuml": "ï", "Iuml": "Ï", "laquo": "«", "lt": "<", "LT": "<", "macr": "¯", "micro": "µ", "middot": "·", "nbsp": " ", "not": "¬", "ntilde": "ñ", "Ntilde": "Ñ", "oacute": "ó", "Oacute": "Ó", "ocirc": "ô", "Ocirc": "Ô", "ograve": "ò", "Ograve": "Ò", "ordf": "ª", "ordm": "º", "oslash": "ø", "Oslash": "Ø", "otilde": "õ", "Otilde": "Õ", "ouml": "ö", "Ouml": "Ö", "para": "¶", "plusmn": "±", "pound": "£", "quot": '"', "QUOT": '"', "raquo": "»", "reg": "®", "REG": "®", "sect": "§", "shy": "­", "sup1": "¹", "sup2": "²", "sup3": "³", "szlig": "ß", "thorn": "þ", "THORN": "Þ", "times": "×", "uacute": "ú", "Uacute": "Ú", "ucirc": "û", "Ucirc": "Û", "ugrave": "ù", "Ugrave": "Ù", "uml": "¨", "uuml": "ü", "Uuml": "Ü", "yacute": "ý", "Yacute": "Ý", "yen": "¥", "yuml": "ÿ" };
      var decodeMapNumeric = { "0": "�", "128": "€", "130": "‚", "131": "ƒ", "132": "„", "133": "…", "134": "†", "135": "‡", "136": "ˆ", "137": "‰", "138": "Š", "139": "‹", "140": "Œ", "142": "Ž", "145": "‘", "146": "’", "147": "“", "148": "”", "149": "•", "150": "–", "151": "—", "152": "˜", "153": "™", "154": "š", "155": "›", "156": "œ", "158": "ž", "159": "Ÿ" };
      var invalidReferenceCodePoints = [1, 2, 3, 4, 5, 6, 7, 8, 11, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 64976, 64977, 64978, 64979, 64980, 64981, 64982, 64983, 64984, 64985, 64986, 64987, 64988, 64989, 64990, 64991, 64992, 64993, 64994, 64995, 64996, 64997, 64998, 64999, 65e3, 65001, 65002, 65003, 65004, 65005, 65006, 65007, 65534, 65535, 131070, 131071, 196606, 196607, 262142, 262143, 327678, 327679, 393214, 393215, 458750, 458751, 524286, 524287, 589822, 589823, 655358, 655359, 720894, 720895, 786430, 786431, 851966, 851967, 917502, 917503, 983038, 983039, 1048574, 1048575, 1114110, 1114111];
      var stringFromCharCode = String.fromCharCode;
      var object = {};
      var hasOwnProperty = object.hasOwnProperty;
      var has = function(object2, propertyName) {
        return hasOwnProperty.call(object2, propertyName);
      };
      var contains = function(array, value) {
        var index = -1;
        var length = array.length;
        while (++index < length) {
          if (array[index] == value) {
            return true;
          }
        }
        return false;
      };
      var merge = function(options, defaults) {
        if (!options) {
          return defaults;
        }
        var result = {};
        var key2;
        for (key2 in defaults) {
          result[key2] = has(options, key2) ? options[key2] : defaults[key2];
        }
        return result;
      };
      var codePointToSymbol = function(codePoint, strict) {
        var output = "";
        if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
          if (strict) {
            parseError("character reference outside the permissible Unicode range");
          }
          return "�";
        }
        if (has(decodeMapNumeric, codePoint)) {
          if (strict) {
            parseError("disallowed character reference");
          }
          return decodeMapNumeric[codePoint];
        }
        if (strict && contains(invalidReferenceCodePoints, codePoint)) {
          parseError("disallowed character reference");
        }
        if (codePoint > 65535) {
          codePoint -= 65536;
          output += stringFromCharCode(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        output += stringFromCharCode(codePoint);
        return output;
      };
      var hexEscape = function(codePoint) {
        return "&#x" + codePoint.toString(16).toUpperCase() + ";";
      };
      var decEscape = function(codePoint) {
        return "&#" + codePoint + ";";
      };
      var parseError = function(message) {
        throw Error("Parse error: " + message);
      };
      var encode = function(string, options) {
        options = merge(options, encode.options);
        var strict = options.strict;
        if (strict && regexInvalidRawCodePoint.test(string)) {
          parseError("forbidden code point");
        }
        var encodeEverything = options.encodeEverything;
        var useNamedReferences = options.useNamedReferences;
        var allowUnsafeSymbols = options.allowUnsafeSymbols;
        var escapeCodePoint = options.decimal ? decEscape : hexEscape;
        var escapeBmpSymbol = function(symbol) {
          return escapeCodePoint(symbol.charCodeAt(0));
        };
        if (encodeEverything) {
          string = string.replace(regexAsciiWhitelist, function(symbol) {
            if (useNamedReferences && has(encodeMap, symbol)) {
              return "&" + encodeMap[symbol] + ";";
            }
            return escapeBmpSymbol(symbol);
          });
          if (useNamedReferences) {
            string = string.replace(/&gt;\u20D2/g, "&nvgt;").replace(/&lt;\u20D2/g, "&nvlt;").replace(/&#x66;&#x6A;/g, "&fjlig;");
          }
          if (useNamedReferences) {
            string = string.replace(regexEncodeNonAscii, function(string2) {
              return "&" + encodeMap[string2] + ";";
            });
          }
        } else if (useNamedReferences) {
          if (!allowUnsafeSymbols) {
            string = string.replace(regexEscape, function(string2) {
              return "&" + encodeMap[string2] + ";";
            });
          }
          string = string.replace(/&gt;\u20D2/g, "&nvgt;").replace(/&lt;\u20D2/g, "&nvlt;");
          string = string.replace(regexEncodeNonAscii, function(string2) {
            return "&" + encodeMap[string2] + ";";
          });
        } else if (!allowUnsafeSymbols) {
          string = string.replace(regexEscape, escapeBmpSymbol);
        }
        return string.replace(regexAstralSymbols, function($0) {
          var high = $0.charCodeAt(0);
          var low = $0.charCodeAt(1);
          var codePoint = (high - 55296) * 1024 + low - 56320 + 65536;
          return escapeCodePoint(codePoint);
        }).replace(regexBmpWhitelist, escapeBmpSymbol);
      };
      encode.options = {
        "allowUnsafeSymbols": false,
        "encodeEverything": false,
        "strict": false,
        "useNamedReferences": false,
        "decimal": false
      };
      var decode = function(html, options) {
        options = merge(options, decode.options);
        var strict = options.strict;
        if (strict && regexInvalidEntity.test(html)) {
          parseError("malformed character reference");
        }
        return html.replace(regexDecode, function($0, $1, $2, $3, $4, $5, $6, $7, $8) {
          var codePoint;
          var semicolon;
          var decDigits;
          var hexDigits;
          var reference;
          var next;
          if ($1) {
            reference = $1;
            return decodeMap[reference];
          }
          if ($2) {
            reference = $2;
            next = $3;
            if (next && options.isAttributeValue) {
              if (strict && next == "=") {
                parseError("`&` did not start a character reference");
              }
              return $0;
            } else {
              if (strict) {
                parseError(
                  "named character reference was not terminated by a semicolon"
                );
              }
              return decodeMapLegacy[reference] + (next || "");
            }
          }
          if ($4) {
            decDigits = $4;
            semicolon = $5;
            if (strict && !semicolon) {
              parseError("character reference was not terminated by a semicolon");
            }
            codePoint = parseInt(decDigits, 10);
            return codePointToSymbol(codePoint, strict);
          }
          if ($6) {
            hexDigits = $6;
            semicolon = $7;
            if (strict && !semicolon) {
              parseError("character reference was not terminated by a semicolon");
            }
            codePoint = parseInt(hexDigits, 16);
            return codePointToSymbol(codePoint, strict);
          }
          if (strict) {
            parseError(
              "named character reference was not terminated by a semicolon"
            );
          }
          return $0;
        });
      };
      decode.options = {
        "isAttributeValue": false,
        "strict": false
      };
      var escape = function(string) {
        return string.replace(regexEscape, function($0) {
          return escapeMap[$0];
        });
      };
      var he = {
        "version": "1.2.0",
        "encode": encode,
        "decode": decode,
        "escape": escape,
        "unescape": decode
      };
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        define(function() {
          return he;
        });
      } else if (freeExports && !freeExports.nodeType) {
        if (freeModule) {
          freeModule.exports = he;
        } else {
          for (var key in he) {
            has(he, key) && (freeExports[key] = he[key]);
          }
        }
      } else {
        root.he = he;
      }
    })(exports);
  }
});

// node_modules/mocha/lib/utils.js
var require_utils = __commonJS({
  "node_modules/mocha/lib/utils.js"(exports) {
    "use strict";
    init_shim();
    var { nanoid } = require_non_secure();
    var path = require_path_browserify();
    var util = require_util();
    var he = require_he();
    var MOCHA_ID_PROP_NAME = "__mocha_id__";
    exports.inherits = util.inherits;
    exports.escape = function(html) {
      return he.encode(String(html), { useNamedReferences: false });
    };
    exports.isString = function(obj) {
      return typeof obj === "string";
    };
    exports.slug = function(str) {
      return str.toLowerCase().replace(/\s+/g, "-").replace(/[^-\w]/g, "").replace(/-{2,}/g, "-");
    };
    exports.clean = function(str) {
      str = str.replace(/\r\n?|[\n\u2028\u2029]/g, "\n").replace(/^\uFEFF/, "").replace(
        /^function(?:\s*|\s[^(]*)\([^)]*\)\s*\{((?:.|\n)*?)\}$|^\([^)]*\)\s*=>\s*(?:\{((?:.|\n)*?)\}|((?:.|\n)*))$/,
        "$1$2$3"
      );
      var spaces = str.match(/^\n?( *)/)[1].length;
      var tabs = str.match(/^\n?(\t*)/)[1].length;
      var re = new RegExp(
        "^\n?" + (tabs ? "	" : " ") + "{" + (tabs || spaces) + "}",
        "gm"
      );
      str = str.replace(re, "");
      return str.trim();
    };
    function emptyRepresentation(value, typeHint) {
      switch (typeHint) {
        case "function":
          return "[Function]";
        case "object":
          return "{}";
        case "array":
          return "[]";
        default:
          return value.toString();
      }
    }
    var canonicalType = exports.canonicalType = function canonicalType2(value) {
      if (value === void 0) {
        return "undefined";
      } else if (value === null) {
        return "null";
      } else if (import_buffer.Buffer.isBuffer(value)) {
        return "buffer";
      }
      return Object.prototype.toString.call(value).replace(/^\[.+\s(.+?)]$/, "$1").toLowerCase();
    };
    exports.type = function type(value) {
      if (value === null)
        return "null";
      const primitives = /* @__PURE__ */ new Set([
        "undefined",
        "boolean",
        "number",
        "string",
        "bigint",
        "symbol"
      ]);
      const _type = typeof value;
      if (_type === "function")
        return _type;
      if (primitives.has(_type))
        return _type;
      if (value instanceof String)
        return "string";
      if (value instanceof Error)
        return "error";
      if (Array.isArray(value))
        return "array";
      return _type;
    };
    exports.stringify = function(value) {
      var typeHint = canonicalType(value);
      if (!~["object", "array", "function"].indexOf(typeHint)) {
        if (typeHint === "buffer") {
          var json = import_buffer.Buffer.prototype.toJSON.call(value);
          return jsonStringify(
            json.data && json.type ? json.data : json,
            2
          ).replace(/,(\n|$)/g, "$1");
        }
        if (typeHint === "string" && typeof value === "object") {
          value = value.split("").reduce(function(acc, char, idx) {
            acc[idx] = char;
            return acc;
          }, {});
          typeHint = "object";
        } else {
          return jsonStringify(value);
        }
      }
      for (var prop in value) {
        if (Object.prototype.hasOwnProperty.call(value, prop)) {
          return jsonStringify(
            exports.canonicalize(value, null, typeHint),
            2
          ).replace(/,(\n|$)/g, "$1");
        }
      }
      return emptyRepresentation(value, typeHint);
    };
    function jsonStringify(object, spaces, depth) {
      if (typeof spaces === "undefined") {
        return _stringify(object);
      }
      depth = depth || 1;
      var space = spaces * depth;
      var str = Array.isArray(object) ? "[" : "{";
      var end = Array.isArray(object) ? "]" : "}";
      var length = typeof object.length === "number" ? object.length : Object.keys(object).length;
      function repeat(s, n) {
        return new Array(n).join(s);
      }
      function _stringify(val) {
        switch (canonicalType(val)) {
          case "null":
          case "undefined":
            val = "[" + val + "]";
            break;
          case "array":
          case "object":
            val = jsonStringify(val, spaces, depth + 1);
            break;
          case "boolean":
          case "regexp":
          case "symbol":
          case "number":
            val = val === 0 && 1 / val === -Infinity ? "-0" : val.toString();
            break;
          case "bigint":
            val = val.toString() + "n";
            break;
          case "date":
            var sDate = isNaN(val.getTime()) ? val.toString() : val.toISOString();
            val = "[Date: " + sDate + "]";
            break;
          case "buffer":
            var json = val.toJSON();
            json = json.data && json.type ? json.data : json;
            val = "[Buffer: " + jsonStringify(json, 2, depth + 1) + "]";
            break;
          default:
            val = val === "[Function]" || val === "[Circular]" ? val : JSON.stringify(val);
        }
        return val;
      }
      for (var i in object) {
        if (!Object.prototype.hasOwnProperty.call(object, i)) {
          continue;
        }
        --length;
        str += "\n " + repeat(" ", space) + (Array.isArray(object) ? "" : '"' + i + '": ') + // key
        _stringify(object[i]) + // value
        (length ? "," : "");
      }
      return str + // [], {}
      (str.length !== 1 ? "\n" + repeat(" ", --space) + end : end);
    }
    exports.canonicalize = function canonicalize(value, stack, typeHint) {
      var canonicalizedObj;
      var prop;
      typeHint = typeHint || canonicalType(value);
      function withStack(value2, fn) {
        stack.push(value2);
        fn();
        stack.pop();
      }
      stack = stack || [];
      if (stack.indexOf(value) !== -1) {
        return "[Circular]";
      }
      switch (typeHint) {
        case "undefined":
        case "buffer":
        case "null":
          canonicalizedObj = value;
          break;
        case "array":
          withStack(value, function() {
            canonicalizedObj = value.map(function(item) {
              return exports.canonicalize(item, stack);
            });
          });
          break;
        case "function":
          for (prop in value) {
            canonicalizedObj = {};
            break;
          }
          if (!canonicalizedObj) {
            canonicalizedObj = emptyRepresentation(value, typeHint);
            break;
          }
        case "object":
          canonicalizedObj = canonicalizedObj || {};
          withStack(value, function() {
            Object.keys(value).sort().forEach(function(key) {
              canonicalizedObj[key] = exports.canonicalize(value[key], stack);
            });
          });
          break;
        case "date":
        case "number":
        case "regexp":
        case "boolean":
        case "symbol":
          canonicalizedObj = value;
          break;
        default:
          canonicalizedObj = value + "";
      }
      return canonicalizedObj;
    };
    exports.stackTraceFilter = function() {
      var is = typeof document === "undefined" ? { node: true } : { browser: true };
      var slash = path.sep;
      var cwd;
      if (is.node) {
        cwd = exports.cwd() + slash;
      } else {
        cwd = (typeof location === "undefined" ? window.location : location).href.replace(/\/[^/]*$/, "/");
        slash = "/";
      }
      function isMochaInternal(line) {
        return ~line.indexOf("node_modules" + slash + "mocha" + slash) || ~line.indexOf(slash + "mocha.js") || ~line.indexOf(slash + "mocha.min.js");
      }
      function isNodeInternal(line) {
        return ~line.indexOf("(timers.js:") || ~line.indexOf("(events.js:") || ~line.indexOf("(node.js:") || ~line.indexOf("(module.js:") || ~line.indexOf("GeneratorFunctionPrototype.next (native)") || false;
      }
      return function(stack) {
        stack = stack.split("\n");
        stack = stack.reduce(function(list, line) {
          if (isMochaInternal(line)) {
            return list;
          }
          if (is.node && isNodeInternal(line)) {
            return list;
          }
          if (/:\d+:\d+\)?$/.test(line)) {
            line = line.replace("(" + cwd, "(");
          }
          list.push(line);
          return list;
        }, []);
        return stack.join("\n");
      };
    };
    exports.isPromise = function isPromise(value) {
      return typeof value === "object" && value !== null && typeof value.then === "function";
    };
    exports.clamp = function clamp(value, range) {
      return Math.min(Math.max(value, range[0]), range[1]);
    };
    exports.noop = function() {
    };
    exports.createMap = function(obj) {
      return Object.assign.apply(
        null,
        [/* @__PURE__ */ Object.create(null)].concat(Array.prototype.slice.call(arguments))
      );
    };
    exports.defineConstants = function(obj) {
      if (canonicalType(obj) !== "object" || !Object.keys(obj).length) {
        throw new TypeError("Invalid argument; expected a non-empty object");
      }
      return Object.freeze(exports.createMap(obj));
    };
    exports.cwd = function cwd() {
      return import_process.default.cwd();
    };
    exports.isBrowser = function isBrowser() {
      return Boolean(import_process.default.browser);
    };
    exports.castArray = function castArray(value) {
      if (value === void 0) {
        return [];
      }
      if (value === null) {
        return [null];
      }
      if (typeof value === "object" && (typeof value[Symbol.iterator] === "function" || value.length !== void 0)) {
        return Array.from(value);
      }
      return [value];
    };
    exports.constants = exports.defineConstants({
      MOCHA_ID_PROP_NAME
    });
    exports.uniqueID = () => nanoid();
    exports.assignNewMochaID = (obj) => {
      const id = exports.uniqueID();
      Object.defineProperty(obj, MOCHA_ID_PROP_NAME, {
        get() {
          return id;
        }
      });
      return obj;
    };
    exports.getMochaID = (obj) => obj && typeof obj === "object" ? obj[MOCHA_ID_PROP_NAME] : void 0;
  }
});

// browser-external:supports-color
var require_supports_color = __commonJS({
  "browser-external:supports-color"(exports, module) {
    init_shim();
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "supports-color" has been externalized for browser compatibility. Cannot access "supports-color.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/log-symbols/browser.js
var require_browser2 = __commonJS({
  "node_modules/log-symbols/browser.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = {
      info: "ℹ️",
      success: "✅",
      warning: "⚠️",
      error: "❌️"
    };
  }
});

// node_modules/mocha/lib/pending.js
var require_pending = __commonJS({
  "node_modules/mocha/lib/pending.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = Pending;
    function Pending(message) {
      this.message = message;
    }
  }
});

// node_modules/ms/index.js
var require_ms2 = __commonJS({
  "node_modules/ms/index.js"(exports, module) {
    init_shim();
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module) {
    init_shim();
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms2();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser3 = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module) {
    init_shim();
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof import_process.default !== "undefined" && "env" in import_process.default) {
        r = import_process.default.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/mocha/lib/errors.js
var require_errors = __commonJS({
  "node_modules/mocha/lib/errors.js"(exports, module) {
    "use strict";
    init_shim();
    var { format } = require_util();
    var emitWarning = (msg, type) => {
      if (import_process.default.emitWarning) {
        import_process.default.emitWarning(msg, type);
      } else {
        import_process.default.nextTick(function() {
          console.warn(type + ": " + msg);
        });
      }
    };
    var deprecate = (msg) => {
      msg = String(msg);
      if (msg && !deprecate.cache[msg]) {
        deprecate.cache[msg] = true;
        emitWarning(msg, "DeprecationWarning");
      }
    };
    deprecate.cache = {};
    var warn = (msg) => {
      if (msg) {
        emitWarning(msg);
      }
    };
    var constants = {
      /**
       * An unrecoverable error.
       * @constant
       * @default
       */
      FATAL: "ERR_MOCHA_FATAL",
      /**
       * The type of an argument to a function call is invalid
       * @constant
       * @default
       */
      INVALID_ARG_TYPE: "ERR_MOCHA_INVALID_ARG_TYPE",
      /**
       * The value of an argument to a function call is invalid
       * @constant
       * @default
       */
      INVALID_ARG_VALUE: "ERR_MOCHA_INVALID_ARG_VALUE",
      /**
       * Something was thrown, but it wasn't an `Error`
       * @constant
       * @default
       */
      INVALID_EXCEPTION: "ERR_MOCHA_INVALID_EXCEPTION",
      /**
       * An interface (e.g., `Mocha.interfaces`) is unknown or invalid
       * @constant
       * @default
       */
      INVALID_INTERFACE: "ERR_MOCHA_INVALID_INTERFACE",
      /**
       * A reporter (.e.g, `Mocha.reporters`) is unknown or invalid
       * @constant
       * @default
       */
      INVALID_REPORTER: "ERR_MOCHA_INVALID_REPORTER",
      /**
       * `done()` was called twice in a `Test` or `Hook` callback
       * @constant
       * @default
       */
      MULTIPLE_DONE: "ERR_MOCHA_MULTIPLE_DONE",
      /**
       * No files matched the pattern provided by the user
       * @constant
       * @default
       */
      NO_FILES_MATCH_PATTERN: "ERR_MOCHA_NO_FILES_MATCH_PATTERN",
      /**
       * Known, but unsupported behavior of some kind
       * @constant
       * @default
       */
      UNSUPPORTED: "ERR_MOCHA_UNSUPPORTED",
      /**
       * Invalid state transition occurring in `Mocha` instance
       * @constant
       * @default
       */
      INSTANCE_ALREADY_RUNNING: "ERR_MOCHA_INSTANCE_ALREADY_RUNNING",
      /**
       * Invalid state transition occurring in `Mocha` instance
       * @constant
       * @default
       */
      INSTANCE_ALREADY_DISPOSED: "ERR_MOCHA_INSTANCE_ALREADY_DISPOSED",
      /**
       * Use of `only()` w/ `--forbid-only` results in this error.
       * @constant
       * @default
       */
      FORBIDDEN_EXCLUSIVITY: "ERR_MOCHA_FORBIDDEN_EXCLUSIVITY",
      /**
       * To be thrown when a user-defined plugin implementation (e.g., `mochaHooks`) is invalid
       * @constant
       * @default
       */
      INVALID_PLUGIN_IMPLEMENTATION: "ERR_MOCHA_INVALID_PLUGIN_IMPLEMENTATION",
      /**
       * To be thrown when a builtin or third-party plugin definition (the _definition_ of `mochaHooks`) is invalid
       * @constant
       * @default
       */
      INVALID_PLUGIN_DEFINITION: "ERR_MOCHA_INVALID_PLUGIN_DEFINITION",
      /**
       * When a runnable exceeds its allowed run time.
       * @constant
       * @default
       */
      TIMEOUT: "ERR_MOCHA_TIMEOUT",
      /**
       * Input file is not able to be parsed
       * @constant
       * @default
       */
      UNPARSABLE_FILE: "ERR_MOCHA_UNPARSABLE_FILE"
    };
    var MOCHA_ERRORS = new Set(Object.values(constants));
    function createNoFilesMatchPatternError(message, pattern) {
      var err = new Error(message);
      err.code = constants.NO_FILES_MATCH_PATTERN;
      err.pattern = pattern;
      return err;
    }
    function createInvalidReporterError(message, reporter) {
      var err = new TypeError(message);
      err.code = constants.INVALID_REPORTER;
      err.reporter = reporter;
      return err;
    }
    function createInvalidInterfaceError(message, ui) {
      var err = new Error(message);
      err.code = constants.INVALID_INTERFACE;
      err.interface = ui;
      return err;
    }
    function createUnsupportedError(message) {
      var err = new Error(message);
      err.code = constants.UNSUPPORTED;
      return err;
    }
    function createMissingArgumentError(message, argument, expected) {
      return createInvalidArgumentTypeError(message, argument, expected);
    }
    function createInvalidArgumentTypeError(message, argument, expected) {
      var err = new TypeError(message);
      err.code = constants.INVALID_ARG_TYPE;
      err.argument = argument;
      err.expected = expected;
      err.actual = typeof argument;
      return err;
    }
    function createInvalidArgumentValueError(message, argument, value, reason) {
      var err = new TypeError(message);
      err.code = constants.INVALID_ARG_VALUE;
      err.argument = argument;
      err.value = value;
      err.reason = typeof reason !== "undefined" ? reason : "is invalid";
      return err;
    }
    function createInvalidExceptionError(message, value) {
      var err = new Error(message);
      err.code = constants.INVALID_EXCEPTION;
      err.valueType = typeof value;
      err.value = value;
      return err;
    }
    function createFatalError(message, value) {
      var err = new Error(message);
      err.code = constants.FATAL;
      err.valueType = typeof value;
      err.value = value;
      return err;
    }
    function createInvalidLegacyPluginError(message, pluginType, pluginId) {
      switch (pluginType) {
        case "reporter":
          return createInvalidReporterError(message, pluginId);
        case "ui":
          return createInvalidInterfaceError(message, pluginId);
        default:
          throw new Error('unknown pluginType "' + pluginType + '"');
      }
    }
    function createInvalidPluginError(...args) {
      deprecate("Use createInvalidLegacyPluginError() instead");
      return createInvalidLegacyPluginError(...args);
    }
    function createMochaInstanceAlreadyDisposedError(message, cleanReferencesAfterRun, instance) {
      var err = new Error(message);
      err.code = constants.INSTANCE_ALREADY_DISPOSED;
      err.cleanReferencesAfterRun = cleanReferencesAfterRun;
      err.instance = instance;
      return err;
    }
    function createMochaInstanceAlreadyRunningError(message, instance) {
      var err = new Error(message);
      err.code = constants.INSTANCE_ALREADY_RUNNING;
      err.instance = instance;
      return err;
    }
    function createMultipleDoneError(runnable, originalErr) {
      var title;
      try {
        title = format("<%s>", runnable.fullTitle());
        if (runnable.parent.root) {
          title += " (of root suite)";
        }
      } catch (ignored) {
        title = format("<%s> (of unknown suite)", runnable.title);
      }
      var message = format(
        "done() called multiple times in %s %s",
        runnable.type ? runnable.type : "unknown runnable",
        title
      );
      if (runnable.file) {
        message += format(" of file %s", runnable.file);
      }
      if (originalErr) {
        message += format("; in addition, done() received error: %s", originalErr);
      }
      var err = new Error(message);
      err.code = constants.MULTIPLE_DONE;
      err.valueType = typeof originalErr;
      err.value = originalErr;
      return err;
    }
    function createForbiddenExclusivityError(mocha) {
      var err = new Error(
        mocha.isWorker ? "`.only` is not supported in parallel mode" : "`.only` forbidden by --forbid-only"
      );
      err.code = constants.FORBIDDEN_EXCLUSIVITY;
      return err;
    }
    function createInvalidPluginDefinitionError(msg, pluginDef) {
      const err = new Error(msg);
      err.code = constants.INVALID_PLUGIN_DEFINITION;
      err.pluginDef = pluginDef;
      return err;
    }
    function createInvalidPluginImplementationError(msg, { pluginDef, pluginImpl } = {}) {
      const err = new Error(msg);
      err.code = constants.INVALID_PLUGIN_IMPLEMENTATION;
      err.pluginDef = pluginDef;
      err.pluginImpl = pluginImpl;
      return err;
    }
    function createTimeoutError(msg, timeout, file) {
      const err = new Error(msg);
      err.code = constants.TIMEOUT;
      err.timeout = timeout;
      err.file = file;
      return err;
    }
    function createUnparsableFileError(message, filename) {
      var err = new Error(message);
      err.code = constants.UNPARSABLE_FILE;
      return err;
    }
    var isMochaError = (err) => Boolean(err && typeof err === "object" && MOCHA_ERRORS.has(err.code));
    module.exports = {
      constants,
      createFatalError,
      createForbiddenExclusivityError,
      createInvalidArgumentTypeError,
      createInvalidArgumentValueError,
      createInvalidExceptionError,
      createInvalidInterfaceError,
      createInvalidLegacyPluginError,
      createInvalidPluginDefinitionError,
      createInvalidPluginError,
      createInvalidPluginImplementationError,
      createInvalidReporterError,
      createMissingArgumentError,
      createMochaInstanceAlreadyDisposedError,
      createMochaInstanceAlreadyRunningError,
      createMultipleDoneError,
      createNoFilesMatchPatternError,
      createTimeoutError,
      createUnparsableFileError,
      createUnsupportedError,
      deprecate,
      isMochaError,
      warn
    };
  }
});

// node_modules/mocha/lib/runnable.js
var require_runnable = __commonJS({
  "node_modules/mocha/lib/runnable.js"(exports, module) {
    "use strict";
    init_shim();
    var EventEmitter = require_events().EventEmitter;
    var Pending = require_pending();
    var debug = require_browser3()("mocha:runnable");
    var milliseconds = require_ms();
    var utils = require_utils();
    var {
      createInvalidExceptionError,
      createMultipleDoneError,
      createTimeoutError
    } = require_errors();
    var Date2 = _global.Date;
    var setTimeout2 = _global.setTimeout;
    var clearTimeout = _global.clearTimeout;
    var toString = Object.prototype.toString;
    module.exports = Runnable;
    function Runnable(title, fn) {
      this.title = title;
      this.fn = fn;
      this.body = (fn || "").toString();
      this.async = fn && fn.length;
      this.sync = !this.async;
      this._timeout = 2e3;
      this._slow = 75;
      this._retries = -1;
      utils.assignNewMochaID(this);
      Object.defineProperty(this, "id", {
        get() {
          return utils.getMochaID(this);
        }
      });
      this.reset();
    }
    utils.inherits(Runnable, EventEmitter);
    Runnable.prototype.reset = function() {
      this.timedOut = false;
      this._currentRetry = 0;
      this.pending = false;
      delete this.state;
      delete this.err;
    };
    Runnable.prototype.timeout = function(ms) {
      if (!arguments.length) {
        return this._timeout;
      }
      if (typeof ms === "string") {
        ms = milliseconds(ms);
      }
      var INT_MAX = Math.pow(2, 31) - 1;
      var range = [0, INT_MAX];
      ms = utils.clamp(ms, range);
      if (ms === range[0] || ms === range[1]) {
        this._timeout = 0;
      } else {
        this._timeout = ms;
      }
      debug("timeout %d", this._timeout);
      if (this.timer) {
        this.resetTimeout();
      }
      return this;
    };
    Runnable.prototype.slow = function(ms) {
      if (!arguments.length || typeof ms === "undefined") {
        return this._slow;
      }
      if (typeof ms === "string") {
        ms = milliseconds(ms);
      }
      debug("slow %d", ms);
      this._slow = ms;
      return this;
    };
    Runnable.prototype.skip = function() {
      this.pending = true;
      throw new Pending("sync skip; aborting execution");
    };
    Runnable.prototype.isPending = function() {
      return this.pending || this.parent && this.parent.isPending();
    };
    Runnable.prototype.isFailed = function() {
      return !this.isPending() && this.state === constants.STATE_FAILED;
    };
    Runnable.prototype.isPassed = function() {
      return !this.isPending() && this.state === constants.STATE_PASSED;
    };
    Runnable.prototype.retries = function(n) {
      if (!arguments.length) {
        return this._retries;
      }
      this._retries = n;
    };
    Runnable.prototype.currentRetry = function(n) {
      if (!arguments.length) {
        return this._currentRetry;
      }
      this._currentRetry = n;
    };
    Runnable.prototype.fullTitle = function() {
      return this.titlePath().join(" ");
    };
    Runnable.prototype.titlePath = function() {
      return this.parent.titlePath().concat([this.title]);
    };
    Runnable.prototype.clearTimeout = function() {
      clearTimeout(this.timer);
    };
    Runnable.prototype.resetTimeout = function() {
      var self2 = this;
      var ms = this.timeout();
      if (ms === 0) {
        return;
      }
      this.clearTimeout();
      this.timer = setTimeout2(function() {
        if (self2.timeout() === 0) {
          return;
        }
        self2.callback(self2._timeoutError(ms));
        self2.timedOut = true;
      }, ms);
    };
    Runnable.prototype.globals = function(globals) {
      if (!arguments.length) {
        return this._allowedGlobals;
      }
      this._allowedGlobals = globals;
    };
    Runnable.prototype.run = function(fn) {
      var self2 = this;
      var start = new Date2();
      var ctx = this.ctx;
      var finished;
      var errorWasHandled = false;
      if (this.isPending())
        return fn();
      if (ctx && ctx.runnable) {
        ctx.runnable(this);
      }
      function multiple(err) {
        if (errorWasHandled) {
          return;
        }
        errorWasHandled = true;
        self2.emit("error", createMultipleDoneError(self2, err));
      }
      function done(err) {
        var ms = self2.timeout();
        if (self2.timedOut) {
          return;
        }
        if (finished) {
          return multiple(err);
        }
        self2.clearTimeout();
        self2.duration = new Date2() - start;
        finished = true;
        if (!err && self2.duration > ms && ms > 0) {
          err = self2._timeoutError(ms);
        }
        fn(err);
      }
      this.callback = done;
      if (this.fn && typeof this.fn.call !== "function") {
        done(
          new TypeError(
            "A runnable must be passed a function as its second argument."
          )
        );
        return;
      }
      if (this.async) {
        this.resetTimeout();
        this.skip = function asyncSkip() {
          this.pending = true;
          done();
          throw new Pending("async skip; aborting execution");
        };
        try {
          callFnAsync(this.fn);
        } catch (err) {
          errorWasHandled = true;
          if (err instanceof Pending) {
            return;
          } else if (this.allowUncaught) {
            throw err;
          }
          done(Runnable.toValueOrError(err));
        }
        return;
      }
      try {
        callFn(this.fn);
      } catch (err) {
        errorWasHandled = true;
        if (err instanceof Pending) {
          return done();
        } else if (this.allowUncaught) {
          throw err;
        }
        done(Runnable.toValueOrError(err));
      }
      function callFn(fn2) {
        var result = fn2.call(ctx);
        if (result && typeof result.then === "function") {
          self2.resetTimeout();
          result.then(
            function() {
              done();
              return null;
            },
            function(reason) {
              done(reason || new Error("Promise rejected with no or falsy reason"));
            }
          );
        } else {
          if (self2.asyncOnly) {
            return done(
              new Error(
                "--async-only option in use without declaring `done()` or returning a promise"
              )
            );
          }
          done();
        }
      }
      function callFnAsync(fn2) {
        var result = fn2.call(ctx, function(err) {
          if (err instanceof Error || toString.call(err) === "[object Error]") {
            return done(err);
          }
          if (err) {
            if (Object.prototype.toString.call(err) === "[object Object]") {
              return done(
                new Error("done() invoked with non-Error: " + JSON.stringify(err))
              );
            }
            return done(new Error("done() invoked with non-Error: " + err));
          }
          if (result && utils.isPromise(result)) {
            return done(
              new Error(
                "Resolution method is overspecified. Specify a callback *or* return a Promise; not both."
              )
            );
          }
          done();
        });
      }
    };
    Runnable.prototype._timeoutError = function(ms) {
      let msg = `Timeout of ${ms}ms exceeded. For async tests and hooks, ensure "done()" is called; if returning a Promise, ensure it resolves.`;
      if (this.file) {
        msg += " (" + this.file + ")";
      }
      return createTimeoutError(msg, ms, this.file);
    };
    var constants = utils.defineConstants(
      /**
       * {@link Runnable}-related constants.
       * @public
       * @memberof Runnable
       * @readonly
       * @static
       * @alias constants
       * @enum {string}
       */
      {
        /**
         * Value of `state` prop when a `Runnable` has failed
         */
        STATE_FAILED: "failed",
        /**
         * Value of `state` prop when a `Runnable` has passed
         */
        STATE_PASSED: "passed",
        /**
         * Value of `state` prop when a `Runnable` has been skipped by user
         */
        STATE_PENDING: "pending"
      }
    );
    Runnable.toValueOrError = function(value) {
      return value || createInvalidExceptionError(
        "Runnable failed with falsy or undefined exception. Please throw an Error instead.",
        value
      );
    };
    Runnable.constants = constants;
  }
});

// node_modules/mocha/lib/hook.js
var require_hook = __commonJS({
  "node_modules/mocha/lib/hook.js"(exports, module) {
    "use strict";
    init_shim();
    var Runnable = require_runnable();
    var { inherits, constants } = require_utils();
    var { MOCHA_ID_PROP_NAME } = constants;
    module.exports = Hook;
    function Hook(title, fn) {
      Runnable.call(this, title, fn);
      this.type = "hook";
    }
    inherits(Hook, Runnable);
    Hook.prototype.reset = function() {
      Runnable.prototype.reset.call(this);
      delete this._error;
    };
    Hook.prototype.error = function(err) {
      if (!arguments.length) {
        err = this._error;
        this._error = null;
        return err;
      }
      this._error = err;
    };
    Hook.prototype.serialize = function serialize() {
      return {
        $$currentRetry: this.currentRetry(),
        $$fullTitle: this.fullTitle(),
        $$isPending: Boolean(this.isPending()),
        $$titlePath: this.titlePath(),
        ctx: this.ctx && this.ctx.currentTest ? {
          currentTest: {
            title: this.ctx.currentTest.title,
            [MOCHA_ID_PROP_NAME]: this.ctx.currentTest.id
          }
        } : {},
        duration: this.duration,
        file: this.file,
        parent: {
          $$fullTitle: this.parent.fullTitle(),
          [MOCHA_ID_PROP_NAME]: this.parent.id
        },
        state: this.state,
        title: this.title,
        type: this.type,
        [MOCHA_ID_PROP_NAME]: this.id
      };
    };
  }
});

// node_modules/mocha/lib/suite.js
var require_suite = __commonJS({
  "node_modules/mocha/lib/suite.js"(exports, module) {
    "use strict";
    init_shim();
    var { EventEmitter } = require_events();
    var Hook = require_hook();
    var {
      assignNewMochaID,
      clamp,
      constants: utilsConstants,
      defineConstants,
      getMochaID,
      inherits,
      isString
    } = require_utils();
    var debug = require_browser3()("mocha:suite");
    var milliseconds = require_ms();
    var errors = require_errors();
    var { MOCHA_ID_PROP_NAME } = utilsConstants;
    exports = module.exports = Suite;
    Suite.create = function(parent, title) {
      var suite = new Suite(title, parent.ctx);
      suite.parent = parent;
      title = suite.fullTitle();
      parent.addSuite(suite);
      return suite;
    };
    function Suite(title, parentContext, isRoot) {
      if (!isString(title)) {
        throw errors.createInvalidArgumentTypeError(
          'Suite argument "title" must be a string. Received type "' + typeof title + '"',
          "title",
          "string"
        );
      }
      this.title = title;
      function Context() {
      }
      Context.prototype = parentContext;
      this.ctx = new Context();
      this.suites = [];
      this.tests = [];
      this.root = isRoot === true;
      this.pending = false;
      this._retries = -1;
      this._beforeEach = [];
      this._beforeAll = [];
      this._afterEach = [];
      this._afterAll = [];
      this._timeout = 2e3;
      this._slow = 75;
      this._bail = false;
      this._onlyTests = [];
      this._onlySuites = [];
      assignNewMochaID(this);
      Object.defineProperty(this, "id", {
        get() {
          return getMochaID(this);
        }
      });
      this.reset();
    }
    inherits(Suite, EventEmitter);
    Suite.prototype.reset = function() {
      this.delayed = false;
      function doReset(thingToReset) {
        thingToReset.reset();
      }
      this.suites.forEach(doReset);
      this.tests.forEach(doReset);
      this._beforeEach.forEach(doReset);
      this._afterEach.forEach(doReset);
      this._beforeAll.forEach(doReset);
      this._afterAll.forEach(doReset);
    };
    Suite.prototype.clone = function() {
      var suite = new Suite(this.title);
      debug("clone");
      suite.ctx = this.ctx;
      suite.root = this.root;
      suite.timeout(this.timeout());
      suite.retries(this.retries());
      suite.slow(this.slow());
      suite.bail(this.bail());
      return suite;
    };
    Suite.prototype.timeout = function(ms) {
      if (!arguments.length) {
        return this._timeout;
      }
      if (typeof ms === "string") {
        ms = milliseconds(ms);
      }
      var INT_MAX = Math.pow(2, 31) - 1;
      var range = [0, INT_MAX];
      ms = clamp(ms, range);
      debug("timeout %d", ms);
      this._timeout = parseInt(ms, 10);
      return this;
    };
    Suite.prototype.retries = function(n) {
      if (!arguments.length) {
        return this._retries;
      }
      debug("retries %d", n);
      this._retries = parseInt(n, 10) || 0;
      return this;
    };
    Suite.prototype.slow = function(ms) {
      if (!arguments.length) {
        return this._slow;
      }
      if (typeof ms === "string") {
        ms = milliseconds(ms);
      }
      debug("slow %d", ms);
      this._slow = ms;
      return this;
    };
    Suite.prototype.bail = function(bail) {
      if (!arguments.length) {
        return this._bail;
      }
      debug("bail %s", bail);
      this._bail = bail;
      return this;
    };
    Suite.prototype.isPending = function() {
      return this.pending || this.parent && this.parent.isPending();
    };
    Suite.prototype._createHook = function(title, fn) {
      var hook = new Hook(title, fn);
      hook.parent = this;
      hook.timeout(this.timeout());
      hook.retries(this.retries());
      hook.slow(this.slow());
      hook.ctx = this.ctx;
      hook.file = this.file;
      return hook;
    };
    Suite.prototype.beforeAll = function(title, fn) {
      if (this.isPending()) {
        return this;
      }
      if (typeof title === "function") {
        fn = title;
        title = fn.name;
      }
      title = '"before all" hook' + (title ? ": " + title : "");
      var hook = this._createHook(title, fn);
      this._beforeAll.push(hook);
      this.emit(constants.EVENT_SUITE_ADD_HOOK_BEFORE_ALL, hook);
      return this;
    };
    Suite.prototype.afterAll = function(title, fn) {
      if (this.isPending()) {
        return this;
      }
      if (typeof title === "function") {
        fn = title;
        title = fn.name;
      }
      title = '"after all" hook' + (title ? ": " + title : "");
      var hook = this._createHook(title, fn);
      this._afterAll.push(hook);
      this.emit(constants.EVENT_SUITE_ADD_HOOK_AFTER_ALL, hook);
      return this;
    };
    Suite.prototype.beforeEach = function(title, fn) {
      if (this.isPending()) {
        return this;
      }
      if (typeof title === "function") {
        fn = title;
        title = fn.name;
      }
      title = '"before each" hook' + (title ? ": " + title : "");
      var hook = this._createHook(title, fn);
      this._beforeEach.push(hook);
      this.emit(constants.EVENT_SUITE_ADD_HOOK_BEFORE_EACH, hook);
      return this;
    };
    Suite.prototype.afterEach = function(title, fn) {
      if (this.isPending()) {
        return this;
      }
      if (typeof title === "function") {
        fn = title;
        title = fn.name;
      }
      title = '"after each" hook' + (title ? ": " + title : "");
      var hook = this._createHook(title, fn);
      this._afterEach.push(hook);
      this.emit(constants.EVENT_SUITE_ADD_HOOK_AFTER_EACH, hook);
      return this;
    };
    Suite.prototype.addSuite = function(suite) {
      suite.parent = this;
      suite.root = false;
      suite.timeout(this.timeout());
      suite.retries(this.retries());
      suite.slow(this.slow());
      suite.bail(this.bail());
      this.suites.push(suite);
      this.emit(constants.EVENT_SUITE_ADD_SUITE, suite);
      return this;
    };
    Suite.prototype.addTest = function(test) {
      test.parent = this;
      test.timeout(this.timeout());
      test.retries(this.retries());
      test.slow(this.slow());
      test.ctx = this.ctx;
      this.tests.push(test);
      this.emit(constants.EVENT_SUITE_ADD_TEST, test);
      return this;
    };
    Suite.prototype.fullTitle = function() {
      return this.titlePath().join(" ");
    };
    Suite.prototype.titlePath = function() {
      var result = [];
      if (this.parent) {
        result = result.concat(this.parent.titlePath());
      }
      if (!this.root) {
        result.push(this.title);
      }
      return result;
    };
    Suite.prototype.total = function() {
      return this.suites.reduce(function(sum, suite) {
        return sum + suite.total();
      }, 0) + this.tests.length;
    };
    Suite.prototype.eachTest = function(fn) {
      this.tests.forEach(fn);
      this.suites.forEach(function(suite) {
        suite.eachTest(fn);
      });
      return this;
    };
    Suite.prototype.run = function run() {
      if (this.root) {
        this.emit(constants.EVENT_ROOT_SUITE_RUN);
      }
    };
    Suite.prototype.hasOnly = function hasOnly() {
      return this._onlyTests.length > 0 || this._onlySuites.length > 0 || this.suites.some(function(suite) {
        return suite.hasOnly();
      });
    };
    Suite.prototype.filterOnly = function filterOnly() {
      if (this._onlyTests.length) {
        this.tests = this._onlyTests;
        this.suites = [];
      } else {
        this.tests = [];
        this._onlySuites.forEach(function(onlySuite) {
          if (onlySuite.hasOnly()) {
            onlySuite.filterOnly();
          }
        });
        var onlySuites = this._onlySuites;
        this.suites = this.suites.filter(function(childSuite) {
          return onlySuites.indexOf(childSuite) !== -1 || childSuite.filterOnly();
        });
      }
      return this.tests.length > 0 || this.suites.length > 0;
    };
    Suite.prototype.appendOnlySuite = function(suite) {
      this._onlySuites.push(suite);
    };
    Suite.prototype.markOnly = function() {
      this.parent && this.parent.appendOnlySuite(this);
    };
    Suite.prototype.appendOnlyTest = function(test) {
      this._onlyTests.push(test);
    };
    Suite.prototype.getHooks = function getHooks(name) {
      return this["_" + name];
    };
    Suite.prototype.dispose = function() {
      this.suites.forEach(function(suite) {
        suite.dispose();
      });
      this.cleanReferences();
    };
    Suite.prototype.cleanReferences = function cleanReferences() {
      function cleanArrReferences(arr) {
        for (var i2 = 0; i2 < arr.length; i2++) {
          delete arr[i2].fn;
        }
      }
      if (Array.isArray(this._beforeAll)) {
        cleanArrReferences(this._beforeAll);
      }
      if (Array.isArray(this._beforeEach)) {
        cleanArrReferences(this._beforeEach);
      }
      if (Array.isArray(this._afterAll)) {
        cleanArrReferences(this._afterAll);
      }
      if (Array.isArray(this._afterEach)) {
        cleanArrReferences(this._afterEach);
      }
      for (var i = 0; i < this.tests.length; i++) {
        delete this.tests[i].fn;
      }
    };
    Suite.prototype.serialize = function serialize() {
      return {
        _bail: this._bail,
        $$fullTitle: this.fullTitle(),
        $$isPending: Boolean(this.isPending()),
        root: this.root,
        title: this.title,
        [MOCHA_ID_PROP_NAME]: this.id,
        parent: this.parent ? { [MOCHA_ID_PROP_NAME]: this.parent.id } : null
      };
    };
    var constants = defineConstants(
      /**
       * {@link Suite}-related constants.
       * @public
       * @memberof Suite
       * @alias constants
       * @readonly
       * @static
       * @enum {string}
       */
      {
        /**
         * Event emitted after a test file has been loaded. Not emitted in browser.
         */
        EVENT_FILE_POST_REQUIRE: "post-require",
        /**
         * Event emitted before a test file has been loaded. In browser, this is emitted once an interface has been selected.
         */
        EVENT_FILE_PRE_REQUIRE: "pre-require",
        /**
         * Event emitted immediately after a test file has been loaded. Not emitted in browser.
         */
        EVENT_FILE_REQUIRE: "require",
        /**
         * Event emitted when `global.run()` is called (use with `delay` option).
         */
        EVENT_ROOT_SUITE_RUN: "run",
        /**
         * Namespace for collection of a `Suite`'s "after all" hooks.
         */
        HOOK_TYPE_AFTER_ALL: "afterAll",
        /**
         * Namespace for collection of a `Suite`'s "after each" hooks.
         */
        HOOK_TYPE_AFTER_EACH: "afterEach",
        /**
         * Namespace for collection of a `Suite`'s "before all" hooks.
         */
        HOOK_TYPE_BEFORE_ALL: "beforeAll",
        /**
         * Namespace for collection of a `Suite`'s "before each" hooks.
         */
        HOOK_TYPE_BEFORE_EACH: "beforeEach",
        /**
         * Emitted after a child `Suite` has been added to a `Suite`.
         */
        EVENT_SUITE_ADD_SUITE: "suite",
        /**
         * Emitted after an "after all" `Hook` has been added to a `Suite`.
         */
        EVENT_SUITE_ADD_HOOK_AFTER_ALL: "afterAll",
        /**
         * Emitted after an "after each" `Hook` has been added to a `Suite`.
         */
        EVENT_SUITE_ADD_HOOK_AFTER_EACH: "afterEach",
        /**
         * Emitted after an "before all" `Hook` has been added to a `Suite`.
         */
        EVENT_SUITE_ADD_HOOK_BEFORE_ALL: "beforeAll",
        /**
         * Emitted after an "before each" `Hook` has been added to a `Suite`.
         */
        EVENT_SUITE_ADD_HOOK_BEFORE_EACH: "beforeEach",
        /**
         * Emitted after a `Test` has been added to a `Suite`.
         */
        EVENT_SUITE_ADD_TEST: "test"
      }
    );
    Suite.constants = constants;
  }
});

// node_modules/mocha/lib/runner.js
var require_runner = __commonJS({
  "node_modules/mocha/lib/runner.js"(exports, module) {
    "use strict";
    init_shim();
    var EventEmitter = require_events().EventEmitter;
    var Pending = require_pending();
    var utils = require_utils();
    var debug = require_browser3()("mocha:runner");
    var Runnable = require_runnable();
    var Suite = require_suite();
    var HOOK_TYPE_BEFORE_EACH = Suite.constants.HOOK_TYPE_BEFORE_EACH;
    var HOOK_TYPE_AFTER_EACH = Suite.constants.HOOK_TYPE_AFTER_EACH;
    var HOOK_TYPE_AFTER_ALL = Suite.constants.HOOK_TYPE_AFTER_ALL;
    var HOOK_TYPE_BEFORE_ALL = Suite.constants.HOOK_TYPE_BEFORE_ALL;
    var EVENT_ROOT_SUITE_RUN = Suite.constants.EVENT_ROOT_SUITE_RUN;
    var STATE_FAILED = Runnable.constants.STATE_FAILED;
    var STATE_PASSED = Runnable.constants.STATE_PASSED;
    var STATE_PENDING = Runnable.constants.STATE_PENDING;
    var stackFilter = utils.stackTraceFilter();
    var stringify = utils.stringify;
    var {
      createInvalidExceptionError,
      createUnsupportedError,
      createFatalError,
      isMochaError,
      constants: errorConstants
    } = require_errors();
    var globals = [
      "setTimeout",
      "clearTimeout",
      "setInterval",
      "clearInterval",
      "XMLHttpRequest",
      "Date",
      "setImmediate",
      "clearImmediate"
    ];
    var constants = utils.defineConstants(
      /**
       * {@link Runner}-related constants.
       * @public
       * @memberof Runner
       * @readonly
       * @alias constants
       * @static
       * @enum {string}
       */
      {
        /**
         * Emitted when {@link Hook} execution begins
         */
        EVENT_HOOK_BEGIN: "hook",
        /**
         * Emitted when {@link Hook} execution ends
         */
        EVENT_HOOK_END: "hook end",
        /**
         * Emitted when Root {@link Suite} execution begins (all files have been parsed and hooks/tests are ready for execution)
         */
        EVENT_RUN_BEGIN: "start",
        /**
         * Emitted when Root {@link Suite} execution has been delayed via `delay` option
         */
        EVENT_DELAY_BEGIN: "waiting",
        /**
         * Emitted when delayed Root {@link Suite} execution is triggered by user via `global.run()`
         */
        EVENT_DELAY_END: "ready",
        /**
         * Emitted when Root {@link Suite} execution ends
         */
        EVENT_RUN_END: "end",
        /**
         * Emitted when {@link Suite} execution begins
         */
        EVENT_SUITE_BEGIN: "suite",
        /**
         * Emitted when {@link Suite} execution ends
         */
        EVENT_SUITE_END: "suite end",
        /**
         * Emitted when {@link Test} execution begins
         */
        EVENT_TEST_BEGIN: "test",
        /**
         * Emitted when {@link Test} execution ends
         */
        EVENT_TEST_END: "test end",
        /**
         * Emitted when {@link Test} execution fails
         */
        EVENT_TEST_FAIL: "fail",
        /**
         * Emitted when {@link Test} execution succeeds
         */
        EVENT_TEST_PASS: "pass",
        /**
         * Emitted when {@link Test} becomes pending
         */
        EVENT_TEST_PENDING: "pending",
        /**
         * Emitted when {@link Test} execution has failed, but will retry
         */
        EVENT_TEST_RETRY: "retry",
        /**
         * Initial state of Runner
         */
        STATE_IDLE: "idle",
        /**
         * State set to this value when the Runner has started running
         */
        STATE_RUNNING: "running",
        /**
         * State set to this value when the Runner has stopped
         */
        STATE_STOPPED: "stopped"
      }
    );
    var Runner = class extends EventEmitter {
      /**
       * Initialize a `Runner` at the Root {@link Suite}, which represents a hierarchy of {@link Suite|Suites} and {@link Test|Tests}.
       *
       * @extends external:EventEmitter
       * @public
       * @class
       * @param {Suite} suite - Root suite
       * @param {Object} [opts] - Settings object
       * @param {boolean} [opts.cleanReferencesAfterRun] - Whether to clean references to test fns and hooks when a suite is done.
       * @param {boolean} [opts.delay] - Whether to delay execution of root suite until ready.
       * @param {boolean} [opts.dryRun] - Whether to report tests without running them.
       * @param {boolean} [opts.failZero] - Whether to fail test run if zero tests encountered.
       */
      constructor(suite, opts = {}) {
        super();
        var self2 = this;
        this._globals = [];
        this._abort = false;
        this.suite = suite;
        this._opts = opts;
        this.state = constants.STATE_IDLE;
        this.total = suite.total();
        this.failures = 0;
        this._eventListeners = /* @__PURE__ */ new Map();
        this.on(constants.EVENT_TEST_END, function(test) {
          if (test.type === "test" && test.retriedTest() && test.parent) {
            var idx = test.parent.tests && test.parent.tests.indexOf(test.retriedTest());
            if (idx > -1)
              test.parent.tests[idx] = test;
          }
          self2.checkGlobals(test);
        });
        this.on(constants.EVENT_HOOK_END, function(hook) {
          self2.checkGlobals(hook);
        });
        this._defaultGrep = /.*/;
        this.grep(this._defaultGrep);
        this.globals(this.globalProps());
        this.uncaught = this._uncaught.bind(this);
        this.unhandled = (reason, promise) => {
          if (isMochaError(reason)) {
            debug(
              "trapped unhandled rejection coming out of Mocha; forwarding to uncaught handler:",
              reason
            );
            this.uncaught(reason);
          } else {
            debug(
              "trapped unhandled rejection from (probably) user code; re-emitting on process"
            );
            this._removeEventListener(
              import_process.default,
              "unhandledRejection",
              this.unhandled
            );
            try {
              import_process.default.emit("unhandledRejection", reason, promise);
            } finally {
              this._addEventListener(import_process.default, "unhandledRejection", this.unhandled);
            }
          }
        };
      }
    };
    Runner.immediately = _global.setImmediate || import_process.default.nextTick;
    Runner.prototype._addEventListener = function(target, eventName, listener) {
      debug(
        "_addEventListener(): adding for event %s; %d current listeners",
        eventName,
        target.listenerCount(eventName)
      );
      if (this._eventListeners.has(target) && this._eventListeners.get(target).has(eventName) && this._eventListeners.get(target).get(eventName).has(listener)) {
        debug(
          "warning: tried to attach duplicate event listener for %s",
          eventName
        );
        return;
      }
      target.on(eventName, listener);
      const targetListeners = this._eventListeners.has(target) ? this._eventListeners.get(target) : /* @__PURE__ */ new Map();
      const targetEventListeners = targetListeners.has(eventName) ? targetListeners.get(eventName) : /* @__PURE__ */ new Set();
      targetEventListeners.add(listener);
      targetListeners.set(eventName, targetEventListeners);
      this._eventListeners.set(target, targetListeners);
    };
    Runner.prototype._removeEventListener = function(target, eventName, listener) {
      target.removeListener(eventName, listener);
      if (this._eventListeners.has(target)) {
        const targetListeners = this._eventListeners.get(target);
        if (targetListeners.has(eventName)) {
          const targetEventListeners = targetListeners.get(eventName);
          targetEventListeners.delete(listener);
          if (!targetEventListeners.size) {
            targetListeners.delete(eventName);
          }
        }
        if (!targetListeners.size) {
          this._eventListeners.delete(target);
        }
      } else {
        debug("trying to remove listener for untracked object %s", target);
      }
    };
    Runner.prototype.dispose = function() {
      this.removeAllListeners();
      this._eventListeners.forEach((targetListeners, target) => {
        targetListeners.forEach((targetEventListeners, eventName) => {
          targetEventListeners.forEach((listener) => {
            target.removeListener(eventName, listener);
          });
        });
      });
      this._eventListeners.clear();
    };
    Runner.prototype.grep = function(re, invert) {
      debug("grep(): setting to %s", re);
      this._grep = re;
      this._invert = invert;
      this.total = this.grepTotal(this.suite);
      return this;
    };
    Runner.prototype.grepTotal = function(suite) {
      var self2 = this;
      var total = 0;
      suite.eachTest(function(test) {
        var match = self2._grep.test(test.fullTitle());
        if (self2._invert) {
          match = !match;
        }
        if (match) {
          total++;
        }
      });
      return total;
    };
    Runner.prototype.globalProps = function() {
      var props = Object.keys(_global);
      for (var i = 0; i < globals.length; ++i) {
        if (~props.indexOf(globals[i])) {
          continue;
        }
        props.push(globals[i]);
      }
      return props;
    };
    Runner.prototype.globals = function(arr) {
      if (!arguments.length) {
        return this._globals;
      }
      debug("globals(): setting to %O", arr);
      this._globals = this._globals.concat(arr);
      return this;
    };
    Runner.prototype.checkGlobals = function(test) {
      if (!this.checkLeaks) {
        return;
      }
      var ok = this._globals;
      var globals2 = this.globalProps();
      var leaks;
      if (test) {
        ok = ok.concat(test._allowedGlobals || []);
      }
      if (this.prevGlobalsLength === globals2.length) {
        return;
      }
      this.prevGlobalsLength = globals2.length;
      leaks = filterLeaks(ok, globals2);
      this._globals = this._globals.concat(leaks);
      if (leaks.length) {
        var msg = `global leak(s) detected: ${leaks.map((e) => `'${e}'`).join(", ")}`;
        this.fail(test, new Error(msg));
      }
    };
    Runner.prototype.fail = function(test, err, force) {
      force = force === true;
      if (test.isPending() && !force) {
        return;
      }
      if (this.state === constants.STATE_STOPPED) {
        if (err.code === errorConstants.MULTIPLE_DONE) {
          throw err;
        }
        throw createFatalError(
          "Test failed after root suite execution completed!",
          err
        );
      }
      ++this.failures;
      debug("total number of failures: %d", this.failures);
      test.state = STATE_FAILED;
      if (!isError(err)) {
        err = thrown2Error(err);
      }
      try {
        err.stack = this.fullStackTrace || !err.stack ? err.stack : stackFilter(err.stack);
      } catch (ignore) {
      }
      this.emit(constants.EVENT_TEST_FAIL, test, err);
    };
    Runner.prototype.hook = function(name, fn) {
      if (this._opts.dryRun)
        return fn();
      var suite = this.suite;
      var hooks = suite.getHooks(name);
      var self2 = this;
      function next(i) {
        var hook = hooks[i];
        if (!hook) {
          return fn();
        }
        self2.currentRunnable = hook;
        if (name === HOOK_TYPE_BEFORE_ALL) {
          hook.ctx.currentTest = hook.parent.tests[0];
        } else if (name === HOOK_TYPE_AFTER_ALL) {
          hook.ctx.currentTest = hook.parent.tests[hook.parent.tests.length - 1];
        } else {
          hook.ctx.currentTest = self2.test;
        }
        setHookTitle(hook);
        hook.allowUncaught = self2.allowUncaught;
        self2.emit(constants.EVENT_HOOK_BEGIN, hook);
        if (!hook.listeners("error").length) {
          self2._addEventListener(hook, "error", function(err) {
            self2.fail(hook, err);
          });
        }
        hook.run(function cbHookRun(err) {
          var testError = hook.error();
          if (testError) {
            self2.fail(self2.test, testError);
          }
          if (hook.pending) {
            if (name === HOOK_TYPE_AFTER_EACH) {
              if (self2.test) {
                self2.test.pending = true;
              }
            } else if (name === HOOK_TYPE_BEFORE_EACH) {
              if (self2.test) {
                self2.test.pending = true;
              }
              self2.emit(constants.EVENT_HOOK_END, hook);
              hook.pending = false;
              return fn(new Error("abort hookDown"));
            } else if (name === HOOK_TYPE_BEFORE_ALL) {
              suite.tests.forEach(function(test) {
                test.pending = true;
              });
              suite.suites.forEach(function(suite2) {
                suite2.pending = true;
              });
              hooks = [];
            } else {
              hook.pending = false;
              var errForbid = createUnsupportedError("`this.skip` forbidden");
              self2.fail(hook, errForbid);
              return fn(errForbid);
            }
          } else if (err) {
            self2.fail(hook, err);
            return fn(err);
          }
          self2.emit(constants.EVENT_HOOK_END, hook);
          delete hook.ctx.currentTest;
          setHookTitle(hook);
          next(++i);
        });
        function setHookTitle(hook2) {
          hook2.originalTitle = hook2.originalTitle || hook2.title;
          if (hook2.ctx && hook2.ctx.currentTest) {
            hook2.title = `${hook2.originalTitle} for "${hook2.ctx.currentTest.title}"`;
          } else {
            var parentTitle;
            if (hook2.parent.title) {
              parentTitle = hook2.parent.title;
            } else {
              parentTitle = hook2.parent.root ? "{root}" : "";
            }
            hook2.title = `${hook2.originalTitle} in "${parentTitle}"`;
          }
        }
      }
      Runner.immediately(function() {
        next(0);
      });
    };
    Runner.prototype.hooks = function(name, suites, fn) {
      var self2 = this;
      var orig = this.suite;
      function next(suite) {
        self2.suite = suite;
        if (!suite) {
          self2.suite = orig;
          return fn();
        }
        self2.hook(name, function(err) {
          if (err) {
            var errSuite = self2.suite;
            self2.suite = orig;
            return fn(err, errSuite);
          }
          next(suites.pop());
        });
      }
      next(suites.pop());
    };
    Runner.prototype.hookUp = function(name, fn) {
      var suites = [this.suite].concat(this.parents()).reverse();
      this.hooks(name, suites, fn);
    };
    Runner.prototype.hookDown = function(name, fn) {
      var suites = [this.suite].concat(this.parents());
      this.hooks(name, suites, fn);
    };
    Runner.prototype.parents = function() {
      var suite = this.suite;
      var suites = [];
      while (suite.parent) {
        suite = suite.parent;
        suites.push(suite);
      }
      return suites;
    };
    Runner.prototype.runTest = function(fn) {
      if (this._opts.dryRun)
        return Runner.immediately(fn);
      var self2 = this;
      var test = this.test;
      if (!test) {
        return;
      }
      if (this.asyncOnly) {
        test.asyncOnly = true;
      }
      this._addEventListener(test, "error", function(err) {
        self2.fail(test, err);
      });
      if (this.allowUncaught) {
        test.allowUncaught = true;
        return test.run(fn);
      }
      try {
        test.run(fn);
      } catch (err) {
        fn(err);
      }
    };
    Runner.prototype.runTests = function(suite, fn) {
      var self2 = this;
      var tests = suite.tests.slice();
      var test;
      function hookErr(_, errSuite, after) {
        var orig = self2.suite;
        self2.suite = after ? errSuite.parent : errSuite;
        if (self2.suite) {
          self2.hookUp(HOOK_TYPE_AFTER_EACH, function(err2, errSuite2) {
            self2.suite = orig;
            if (err2) {
              return hookErr(err2, errSuite2, true);
            }
            fn(errSuite);
          });
        } else {
          self2.suite = orig;
          fn(errSuite);
        }
      }
      function next(err, errSuite) {
        if (self2.failures && suite._bail) {
          tests = [];
        }
        if (self2._abort) {
          return fn();
        }
        if (err) {
          return hookErr(err, errSuite, true);
        }
        test = tests.shift();
        if (!test) {
          return fn();
        }
        var match = self2._grep.test(test.fullTitle());
        if (self2._invert) {
          match = !match;
        }
        if (!match) {
          if (self2._grep !== self2._defaultGrep) {
            Runner.immediately(next);
          } else {
            next();
          }
          return;
        }
        if (test.isPending()) {
          if (self2.forbidPending) {
            self2.fail(test, new Error("Pending test forbidden"), true);
          } else {
            test.state = STATE_PENDING;
            self2.emit(constants.EVENT_TEST_PENDING, test);
          }
          self2.emit(constants.EVENT_TEST_END, test);
          return next();
        }
        self2.emit(constants.EVENT_TEST_BEGIN, self2.test = test);
        self2.hookDown(HOOK_TYPE_BEFORE_EACH, function(err2, errSuite2) {
          if (test.isPending()) {
            if (self2.forbidPending) {
              self2.fail(test, new Error("Pending test forbidden"), true);
            } else {
              test.state = STATE_PENDING;
              self2.emit(constants.EVENT_TEST_PENDING, test);
            }
            self2.emit(constants.EVENT_TEST_END, test);
            var origSuite = self2.suite;
            self2.suite = errSuite2 || self2.suite;
            return self2.hookUp(HOOK_TYPE_AFTER_EACH, function(e, eSuite) {
              self2.suite = origSuite;
              next(e, eSuite);
            });
          }
          if (err2) {
            return hookErr(err2, errSuite2, false);
          }
          self2.currentRunnable = self2.test;
          self2.runTest(function(err3) {
            test = self2.test;
            if (test.pending) {
              if (self2.forbidPending) {
                self2.fail(test, new Error("Pending test forbidden"), true);
              } else {
                test.state = STATE_PENDING;
                self2.emit(constants.EVENT_TEST_PENDING, test);
              }
              self2.emit(constants.EVENT_TEST_END, test);
              return self2.hookUp(HOOK_TYPE_AFTER_EACH, next);
            } else if (err3) {
              var retry = test.currentRetry();
              if (retry < test.retries()) {
                var clonedTest = test.clone();
                clonedTest.currentRetry(retry + 1);
                tests.unshift(clonedTest);
                self2.emit(constants.EVENT_TEST_RETRY, test, err3);
                return self2.hookUp(HOOK_TYPE_AFTER_EACH, next);
              } else {
                self2.fail(test, err3);
              }
              self2.emit(constants.EVENT_TEST_END, test);
              return self2.hookUp(HOOK_TYPE_AFTER_EACH, next);
            }
            test.state = STATE_PASSED;
            self2.emit(constants.EVENT_TEST_PASS, test);
            self2.emit(constants.EVENT_TEST_END, test);
            self2.hookUp(HOOK_TYPE_AFTER_EACH, next);
          });
        });
      }
      this.next = next;
      this.hookErr = hookErr;
      next();
    };
    Runner.prototype.runSuite = function(suite, fn) {
      var i = 0;
      var self2 = this;
      var total = this.grepTotal(suite);
      debug("runSuite(): running %s", suite.fullTitle());
      if (!total || self2.failures && suite._bail) {
        debug("runSuite(): bailing");
        return fn();
      }
      this.emit(constants.EVENT_SUITE_BEGIN, this.suite = suite);
      function next(errSuite) {
        if (errSuite) {
          if (errSuite === suite) {
            return done();
          }
          return done(errSuite);
        }
        if (self2._abort) {
          return done();
        }
        var curr = suite.suites[i++];
        if (!curr) {
          return done();
        }
        if (self2._grep !== self2._defaultGrep) {
          Runner.immediately(function() {
            self2.runSuite(curr, next);
          });
        } else {
          self2.runSuite(curr, next);
        }
      }
      function done(errSuite) {
        self2.suite = suite;
        self2.nextSuite = next;
        delete self2.test;
        self2.hook(HOOK_TYPE_AFTER_ALL, function() {
          self2.emit(constants.EVENT_SUITE_END, suite);
          fn(errSuite);
        });
      }
      this.nextSuite = next;
      this.hook(HOOK_TYPE_BEFORE_ALL, function(err) {
        if (err) {
          return done();
        }
        self2.runTests(suite, next);
      });
    };
    Runner.prototype._uncaught = function(err) {
      if (!(this instanceof Runner)) {
        throw createFatalError(
          "Runner#uncaught() called with invalid context",
          this
        );
      }
      if (err instanceof Pending) {
        debug("uncaught(): caught a Pending");
        return;
      }
      if (this.allowUncaught && !utils.isBrowser()) {
        debug("uncaught(): bubbling exception due to --allow-uncaught");
        throw err;
      }
      if (this.state === constants.STATE_STOPPED) {
        debug("uncaught(): throwing after run has completed!");
        throw err;
      }
      if (err) {
        debug("uncaught(): got truthy exception %O", err);
      } else {
        debug("uncaught(): undefined/falsy exception");
        err = createInvalidExceptionError(
          "Caught falsy/undefined exception which would otherwise be uncaught. No stack trace found; try a debugger",
          err
        );
      }
      if (!isError(err)) {
        err = thrown2Error(err);
        debug('uncaught(): converted "error" %o to Error', err);
      }
      err.uncaught = true;
      var runnable = this.currentRunnable;
      if (!runnable) {
        runnable = new Runnable("Uncaught error outside test suite");
        debug("uncaught(): no current Runnable; created a phony one");
        runnable.parent = this.suite;
        if (this.state === constants.STATE_RUNNING) {
          debug("uncaught(): failing gracefully");
          this.fail(runnable, err);
        } else {
          debug("uncaught(): test run has not yet started; unrecoverable");
          this.emit(constants.EVENT_RUN_BEGIN);
          this.fail(runnable, err);
          this.emit(constants.EVENT_RUN_END);
        }
        return;
      }
      runnable.clearTimeout();
      if (runnable.isFailed()) {
        debug("uncaught(): Runnable has already failed");
        return;
      } else if (runnable.isPending()) {
        debug("uncaught(): pending Runnable wound up failing!");
        this.fail(runnable, err, true);
        return;
      }
      if (runnable.isPassed()) {
        debug("uncaught(): Runnable has already passed; bailing gracefully");
        this.fail(runnable, err);
        this.abort();
      } else {
        debug("uncaught(): forcing Runnable to complete with Error");
        return runnable.callback(err);
      }
    };
    Runner.prototype.run = function(fn, opts = {}) {
      var rootSuite = this.suite;
      var options = opts.options || {};
      debug("run(): got options: %O", options);
      fn = fn || function() {
      };
      const end = () => {
        if (!this.total && this._opts.failZero)
          this.failures = 1;
        debug("run(): root suite completed; emitting %s", constants.EVENT_RUN_END);
        this.emit(constants.EVENT_RUN_END);
      };
      const begin = () => {
        debug("run(): emitting %s", constants.EVENT_RUN_BEGIN);
        this.emit(constants.EVENT_RUN_BEGIN);
        debug("run(): emitted %s", constants.EVENT_RUN_BEGIN);
        this.runSuite(rootSuite, end);
      };
      const prepare = () => {
        debug("run(): starting");
        if (rootSuite.hasOnly()) {
          rootSuite.filterOnly();
          debug("run(): filtered exclusive Runnables");
        }
        this.state = constants.STATE_RUNNING;
        if (this._opts.delay) {
          this.emit(constants.EVENT_DELAY_END);
          debug('run(): "delay" ended');
        }
        return begin();
      };
      if (this._opts.cleanReferencesAfterRun) {
        this.on(constants.EVENT_SUITE_END, (suite) => {
          suite.cleanReferences();
        });
      }
      this.on(constants.EVENT_RUN_END, function() {
        this.state = constants.STATE_STOPPED;
        debug("run(): emitted %s", constants.EVENT_RUN_END);
        fn(this.failures);
      });
      this._removeEventListener(import_process.default, "uncaughtException", this.uncaught);
      this._removeEventListener(import_process.default, "unhandledRejection", this.unhandled);
      this._addEventListener(import_process.default, "uncaughtException", this.uncaught);
      this._addEventListener(import_process.default, "unhandledRejection", this.unhandled);
      if (this._opts.delay) {
        this.emit(constants.EVENT_DELAY_BEGIN, rootSuite);
        rootSuite.once(EVENT_ROOT_SUITE_RUN, prepare);
        debug("run(): waiting for green light due to --delay");
      } else {
        Runner.immediately(prepare);
      }
      return this;
    };
    Runner.prototype.linkPartialObjects = function(value) {
      return this;
    };
    Runner.prototype.runAsync = async function runAsync(opts = {}) {
      return new Promise((resolve) => {
        this.run(resolve, opts);
      });
    };
    Runner.prototype.abort = function() {
      debug("abort(): aborting");
      this._abort = true;
      return this;
    };
    Runner.prototype.isParallelMode = function isParallelMode() {
      return false;
    };
    Runner.prototype.workerReporter = function() {
      throw createUnsupportedError("workerReporter() not supported in serial mode");
    };
    function filterLeaks(ok, globals2) {
      return globals2.filter(function(key) {
        if (/^\d+/.test(key)) {
          return false;
        }
        if (_global.navigator && /^getInterface/.test(key)) {
          return false;
        }
        if (_global.navigator && /^\d+/.test(key)) {
          return false;
        }
        if (/^mocha-/.test(key)) {
          return false;
        }
        var matched = ok.filter(function(ok2) {
          if (~ok2.indexOf("*")) {
            return key.indexOf(ok2.split("*")[0]) === 0;
          }
          return key === ok2;
        });
        return !matched.length && (!_global.navigator || key !== "onerror");
      });
    }
    function isError(err) {
      return err instanceof Error || err && typeof err.message === "string";
    }
    function thrown2Error(err) {
      return new Error(
        `the ${utils.canonicalType(err)} ${stringify(
          err
        )} was thrown, throw an Error :)`
      );
    }
    Runner.constants = constants;
    module.exports = Runner;
  }
});

// node_modules/mocha/lib/reporters/base.js
var require_base2 = __commonJS({
  "node_modules/mocha/lib/reporters/base.js"(exports, module) {
    "use strict";
    init_shim();
    var diff = require_lib();
    var milliseconds = require_ms();
    var utils = require_utils();
    var supportsColor = require_supports_color();
    var symbols = require_browser2();
    var constants = require_runner().constants;
    var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
    var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;
    var isBrowser = utils.isBrowser();
    function getBrowserWindowSize() {
      if ("innerHeight" in _global) {
        return [_global.innerHeight, _global.innerWidth];
      }
      return [640, 480];
    }
    exports = module.exports = Base;
    var isatty = isBrowser || import_process.default.stdout.isTTY && import_process.default.stderr.isTTY;
    var consoleLog = console.log;
    exports.useColors = !isBrowser && (supportsColor.stdout || import_process.default.env.MOCHA_COLORS !== void 0);
    exports.inlineDiffs = false;
    exports.maxDiffSize = 8192;
    exports.colors = {
      pass: 90,
      fail: 31,
      "bright pass": 92,
      "bright fail": 91,
      "bright yellow": 93,
      pending: 36,
      suite: 0,
      "error title": 0,
      "error message": 31,
      "error stack": 90,
      checkmark: 32,
      fast: 90,
      medium: 33,
      slow: 31,
      green: 32,
      light: 90,
      "diff gutter": 90,
      "diff added": 32,
      "diff removed": 31,
      "diff added inline": "30;42",
      "diff removed inline": "30;41"
    };
    exports.symbols = {
      ok: symbols.success,
      err: symbols.error,
      dot: ".",
      comma: ",",
      bang: "!"
    };
    var color = exports.color = function(type, str) {
      if (!exports.useColors) {
        return String(str);
      }
      return "\x1B[" + exports.colors[type] + "m" + str + "\x1B[0m";
    };
    exports.window = {
      width: 75
    };
    if (isatty) {
      if (isBrowser) {
        exports.window.width = getBrowserWindowSize()[1];
      } else {
        exports.window.width = import_process.default.stdout.getWindowSize(1)[0];
      }
    }
    exports.cursor = {
      hide: function() {
        isatty && import_process.default.stdout.write("\x1B[?25l");
      },
      show: function() {
        isatty && import_process.default.stdout.write("\x1B[?25h");
      },
      deleteLine: function() {
        isatty && import_process.default.stdout.write("\x1B[2K");
      },
      beginningOfLine: function() {
        isatty && import_process.default.stdout.write("\x1B[0G");
      },
      CR: function() {
        if (isatty) {
          exports.cursor.deleteLine();
          exports.cursor.beginningOfLine();
        } else {
          import_process.default.stdout.write("\r");
        }
      }
    };
    var showDiff = exports.showDiff = function(err) {
      return err && err.showDiff !== false && sameType(err.actual, err.expected) && err.expected !== void 0;
    };
    function stringifyDiffObjs(err) {
      if (!utils.isString(err.actual) || !utils.isString(err.expected)) {
        err.actual = utils.stringify(err.actual);
        err.expected = utils.stringify(err.expected);
      }
    }
    var generateDiff = exports.generateDiff = function(actual, expected) {
      try {
        var maxLen = exports.maxDiffSize;
        var skipped = 0;
        if (maxLen > 0) {
          skipped = Math.max(actual.length - maxLen, expected.length - maxLen);
          actual = actual.slice(0, maxLen);
          expected = expected.slice(0, maxLen);
        }
        let result = exports.inlineDiffs ? inlineDiff(actual, expected) : unifiedDiff(actual, expected);
        if (skipped > 0) {
          result = `${result}
      [mocha] output truncated to ${maxLen} characters, see "maxDiffSize" reporter-option
`;
        }
        return result;
      } catch (err) {
        var msg = "\n      " + color("diff added", "+ expected") + " " + color("diff removed", "- actual:  failed to generate Mocha diff") + "\n";
        return msg;
      }
    };
    exports.list = function(failures) {
      var multipleErr, multipleTest;
      Base.consoleLog();
      failures.forEach(function(test, i) {
        var fmt = color("error title", "  %s) %s:\n") + color("error message", "     %s") + color("error stack", "\n%s\n");
        var msg;
        var err;
        if (test.err && test.err.multiple) {
          if (multipleTest !== test) {
            multipleTest = test;
            multipleErr = [test.err].concat(test.err.multiple);
          }
          err = multipleErr.shift();
        } else {
          err = test.err;
        }
        var message;
        if (typeof err.inspect === "function") {
          message = err.inspect() + "";
        } else if (err.message && typeof err.message.toString === "function") {
          message = err.message + "";
        } else {
          message = "";
        }
        var stack = err.stack || message;
        var index = message ? stack.indexOf(message) : -1;
        if (index === -1) {
          msg = message;
        } else {
          index += message.length;
          msg = stack.slice(0, index);
          stack = stack.slice(index + 1);
        }
        if (err.uncaught) {
          msg = "Uncaught " + msg;
        }
        if (!exports.hideDiff && showDiff(err)) {
          stringifyDiffObjs(err);
          fmt = color("error title", "  %s) %s:\n%s") + color("error stack", "\n%s\n");
          var match = message.match(/^([^:]+): expected/);
          msg = "\n      " + color("error message", match ? match[1] : msg);
          msg += generateDiff(err.actual, err.expected);
        }
        stack = stack.replace(/^/gm, "  ");
        var testTitle = "";
        test.titlePath().forEach(function(str, index2) {
          if (index2 !== 0) {
            testTitle += "\n     ";
          }
          for (var i2 = 0; i2 < index2; i2++) {
            testTitle += "  ";
          }
          testTitle += str;
        });
        Base.consoleLog(fmt, i + 1, testTitle, msg, stack);
      });
    };
    function Base(runner, options) {
      var failures = this.failures = [];
      if (!runner) {
        throw new TypeError("Missing runner argument");
      }
      this.options = options || {};
      this.runner = runner;
      this.stats = runner.stats;
      var maxDiffSizeOpt = this.options.reporterOption && this.options.reporterOption.maxDiffSize;
      if (maxDiffSizeOpt !== void 0 && !isNaN(Number(maxDiffSizeOpt))) {
        exports.maxDiffSize = Number(maxDiffSizeOpt);
      }
      runner.on(EVENT_TEST_PASS, function(test) {
        if (test.duration > test.slow()) {
          test.speed = "slow";
        } else if (test.duration > test.slow() / 2) {
          test.speed = "medium";
        } else {
          test.speed = "fast";
        }
      });
      runner.on(EVENT_TEST_FAIL, function(test, err) {
        if (showDiff(err)) {
          stringifyDiffObjs(err);
        }
        if (test.err && err instanceof Error) {
          test.err.multiple = (test.err.multiple || []).concat(err);
        } else {
          test.err = err;
        }
        failures.push(test);
      });
    }
    Base.prototype.epilogue = function() {
      var stats = this.stats;
      var fmt;
      Base.consoleLog();
      fmt = color("bright pass", " ") + color("green", " %d passing") + color("light", " (%s)");
      Base.consoleLog(fmt, stats.passes || 0, milliseconds(stats.duration));
      if (stats.pending) {
        fmt = color("pending", " ") + color("pending", " %d pending");
        Base.consoleLog(fmt, stats.pending);
      }
      if (stats.failures) {
        fmt = color("fail", "  %d failing");
        Base.consoleLog(fmt, stats.failures);
        Base.list(this.failures);
        Base.consoleLog();
      }
      Base.consoleLog();
    };
    function pad(str, len) {
      str = String(str);
      return Array(len - str.length + 1).join(" ") + str;
    }
    function inlineDiff(actual, expected) {
      var msg = errorDiff(actual, expected);
      var lines = msg.split("\n");
      if (lines.length > 4) {
        var width = String(lines.length).length;
        msg = lines.map(function(str, i) {
          return pad(++i, width) + " | " + str;
        }).join("\n");
      }
      msg = "\n" + color("diff removed inline", "actual") + " " + color("diff added inline", "expected") + "\n\n" + msg + "\n";
      msg = msg.replace(/^/gm, "      ");
      return msg;
    }
    function unifiedDiff(actual, expected) {
      var indent = "      ";
      function cleanUp(line) {
        if (line[0] === "+") {
          return indent + colorLines("diff added", line);
        }
        if (line[0] === "-") {
          return indent + colorLines("diff removed", line);
        }
        if (line.match(/@@/)) {
          return "--";
        }
        if (line.match(/\\ No newline/)) {
          return null;
        }
        return indent + line;
      }
      function notBlank(line) {
        return typeof line !== "undefined" && line !== null;
      }
      var msg = diff.createPatch("string", actual, expected);
      var lines = msg.split("\n").splice(5);
      return "\n      " + colorLines("diff added", "+ expected") + " " + colorLines("diff removed", "- actual") + "\n\n" + lines.map(cleanUp).filter(notBlank).join("\n");
    }
    function errorDiff(actual, expected) {
      return diff.diffWordsWithSpace(actual, expected).map(function(str) {
        if (str.added) {
          return colorLines("diff added inline", str.value);
        }
        if (str.removed) {
          return colorLines("diff removed inline", str.value);
        }
        return str.value;
      }).join("");
    }
    function colorLines(name, str) {
      return str.split("\n").map(function(str2) {
        return color(name, str2);
      }).join("\n");
    }
    var objToString = Object.prototype.toString;
    function sameType(a, b) {
      return objToString.call(a) === objToString.call(b);
    }
    Base.consoleLog = consoleLog;
    Base.abstract = true;
  }
});

// node_modules/mocha/lib/reporters/dot.js
var require_dot = __commonJS({
  "node_modules/mocha/lib/reporters/dot.js"(exports, module) {
    "use strict";
    init_shim();
    var Base = require_base2();
    var inherits = require_utils().inherits;
    var constants = require_runner().constants;
    var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
    var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;
    var EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;
    var EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;
    var EVENT_RUN_END = constants.EVENT_RUN_END;
    exports = module.exports = Dot;
    function Dot(runner, options) {
      Base.call(this, runner, options);
      var self2 = this;
      var width = Base.window.width * 0.75 | 0;
      var n = -1;
      runner.on(EVENT_RUN_BEGIN, function() {
        import_process.default.stdout.write("\n");
      });
      runner.on(EVENT_TEST_PENDING, function() {
        if (++n % width === 0) {
          import_process.default.stdout.write("\n  ");
        }
        import_process.default.stdout.write(Base.color("pending", Base.symbols.comma));
      });
      runner.on(EVENT_TEST_PASS, function(test) {
        if (++n % width === 0) {
          import_process.default.stdout.write("\n  ");
        }
        if (test.speed === "slow") {
          import_process.default.stdout.write(Base.color("bright yellow", Base.symbols.dot));
        } else {
          import_process.default.stdout.write(Base.color(test.speed, Base.symbols.dot));
        }
      });
      runner.on(EVENT_TEST_FAIL, function() {
        if (++n % width === 0) {
          import_process.default.stdout.write("\n  ");
        }
        import_process.default.stdout.write(Base.color("fail", Base.symbols.bang));
      });
      runner.once(EVENT_RUN_END, function() {
        import_process.default.stdout.write("\n");
        self2.epilogue();
      });
    }
    inherits(Dot, Base);
    Dot.description = "dot matrix representation";
  }
});

// node_modules/mocha/lib/reporters/doc.js
var require_doc = __commonJS({
  "node_modules/mocha/lib/reporters/doc.js"(exports, module) {
    "use strict";
    init_shim();
    var Base = require_base2();
    var utils = require_utils();
    var constants = require_runner().constants;
    var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
    var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;
    var EVENT_SUITE_BEGIN = constants.EVENT_SUITE_BEGIN;
    var EVENT_SUITE_END = constants.EVENT_SUITE_END;
    exports = module.exports = Doc;
    function Doc(runner, options) {
      Base.call(this, runner, options);
      var indents = 2;
      function indent() {
        return Array(indents).join("  ");
      }
      runner.on(EVENT_SUITE_BEGIN, function(suite) {
        if (suite.root) {
          return;
        }
        ++indents;
        Base.consoleLog('%s<section class="suite">', indent());
        ++indents;
        Base.consoleLog("%s<h1>%s</h1>", indent(), utils.escape(suite.title));
        Base.consoleLog("%s<dl>", indent());
      });
      runner.on(EVENT_SUITE_END, function(suite) {
        if (suite.root) {
          return;
        }
        Base.consoleLog("%s</dl>", indent());
        --indents;
        Base.consoleLog("%s</section>", indent());
        --indents;
      });
      runner.on(EVENT_TEST_PASS, function(test) {
        Base.consoleLog("%s  <dt>%s</dt>", indent(), utils.escape(test.title));
        Base.consoleLog("%s  <dt>%s</dt>", indent(), utils.escape(test.file));
        var code = utils.escape(utils.clean(test.body));
        Base.consoleLog("%s  <dd><pre><code>%s</code></pre></dd>", indent(), code);
      });
      runner.on(EVENT_TEST_FAIL, function(test, err) {
        Base.consoleLog(
          '%s  <dt class="error">%s</dt>',
          indent(),
          utils.escape(test.title)
        );
        Base.consoleLog(
          '%s  <dt class="error">%s</dt>',
          indent(),
          utils.escape(test.file)
        );
        var code = utils.escape(utils.clean(test.body));
        Base.consoleLog(
          '%s  <dd class="error"><pre><code>%s</code></pre></dd>',
          indent(),
          code
        );
        Base.consoleLog(
          '%s  <dd class="error">%s</dd>',
          indent(),
          utils.escape(err)
        );
      });
    }
    Doc.description = "HTML documentation";
  }
});

// node_modules/mocha/lib/reporters/tap.js
var require_tap = __commonJS({
  "node_modules/mocha/lib/reporters/tap.js"(exports, module) {
    "use strict";
    init_shim();
    var util = require_util();
    var Base = require_base2();
    var constants = require_runner().constants;
    var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
    var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;
    var EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;
    var EVENT_RUN_END = constants.EVENT_RUN_END;
    var EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;
    var EVENT_TEST_END = constants.EVENT_TEST_END;
    var inherits = require_utils().inherits;
    var sprintf = util.format;
    exports = module.exports = TAP;
    function TAP(runner, options) {
      Base.call(this, runner, options);
      var self2 = this;
      var n = 1;
      var tapVersion = "12";
      if (options && options.reporterOptions) {
        if (options.reporterOptions.tapVersion) {
          tapVersion = options.reporterOptions.tapVersion.toString();
        }
      }
      this._producer = createProducer(tapVersion);
      runner.once(EVENT_RUN_BEGIN, function() {
        self2._producer.writeVersion();
      });
      runner.on(EVENT_TEST_END, function() {
        ++n;
      });
      runner.on(EVENT_TEST_PENDING, function(test) {
        self2._producer.writePending(n, test);
      });
      runner.on(EVENT_TEST_PASS, function(test) {
        self2._producer.writePass(n, test);
      });
      runner.on(EVENT_TEST_FAIL, function(test, err) {
        self2._producer.writeFail(n, test, err);
      });
      runner.once(EVENT_RUN_END, function() {
        self2._producer.writeEpilogue(runner.stats);
      });
    }
    inherits(TAP, Base);
    function title(test) {
      return test.fullTitle().replace(/#/g, "");
    }
    function println(format, varArgs) {
      var vargs = Array.from(arguments);
      vargs[0] += "\n";
      import_process.default.stdout.write(sprintf.apply(null, vargs));
    }
    function createProducer(tapVersion) {
      var producers = {
        12: new TAP12Producer(),
        13: new TAP13Producer()
      };
      var producer = producers[tapVersion];
      if (!producer) {
        throw new Error(
          "invalid or unsupported TAP version: " + JSON.stringify(tapVersion)
        );
      }
      return producer;
    }
    function TAPProducer() {
    }
    TAPProducer.prototype.writeVersion = function() {
    };
    TAPProducer.prototype.writePlan = function(ntests) {
      println("%d..%d", 1, ntests);
    };
    TAPProducer.prototype.writePass = function(n, test) {
      println("ok %d %s", n, title(test));
    };
    TAPProducer.prototype.writePending = function(n, test) {
      println("ok %d %s # SKIP -", n, title(test));
    };
    TAPProducer.prototype.writeFail = function(n, test, err) {
      println("not ok %d %s", n, title(test));
    };
    TAPProducer.prototype.writeEpilogue = function(stats) {
      println("# tests " + (stats.passes + stats.failures));
      println("# pass " + stats.passes);
      println("# fail " + stats.failures);
      this.writePlan(stats.passes + stats.failures + stats.pending);
    };
    function TAP12Producer() {
      this.writeFail = function(n, test, err) {
        TAPProducer.prototype.writeFail.call(this, n, test, err);
        if (err.message) {
          println(err.message.replace(/^/gm, "  "));
        }
        if (err.stack) {
          println(err.stack.replace(/^/gm, "  "));
        }
      };
    }
    inherits(TAP12Producer, TAPProducer);
    function TAP13Producer() {
      this.writeVersion = function() {
        println("TAP version 13");
      };
      this.writeFail = function(n, test, err) {
        TAPProducer.prototype.writeFail.call(this, n, test, err);
        var emitYamlBlock = err.message != null || err.stack != null;
        if (emitYamlBlock) {
          println(indent(1) + "---");
          if (err.message) {
            println(indent(2) + "message: |-");
            println(err.message.replace(/^/gm, indent(3)));
          }
          if (err.stack) {
            println(indent(2) + "stack: |-");
            println(err.stack.replace(/^/gm, indent(3)));
          }
          println(indent(1) + "...");
        }
      };
      function indent(level) {
        return Array(level + 1).join("  ");
      }
    }
    inherits(TAP13Producer, TAPProducer);
    TAP.description = "TAP-compatible output";
  }
});

// node_modules/node-stdlib-browser/esm/mock/empty.js
var empty_exports = {};
__export(empty_exports, {
  default: () => empty
});
var empty;
var init_empty = __esm({
  "node_modules/node-stdlib-browser/esm/mock/empty.js"() {
    init_shim();
    empty = null;
  }
});

// node_modules/mocha/lib/reporters/json.js
var require_json2 = __commonJS({
  "node_modules/mocha/lib/reporters/json.js"(exports, module) {
    "use strict";
    init_shim();
    var Base = require_base2();
    var fs = (init_empty(), __toCommonJS(empty_exports));
    var path = require_path_browserify();
    var createUnsupportedError = require_errors().createUnsupportedError;
    var utils = require_utils();
    var constants = require_runner().constants;
    var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
    var EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;
    var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;
    var EVENT_TEST_END = constants.EVENT_TEST_END;
    var EVENT_RUN_END = constants.EVENT_RUN_END;
    exports = module.exports = JSONReporter;
    function JSONReporter(runner, options = {}) {
      Base.call(this, runner, options);
      var self2 = this;
      var tests = [];
      var pending = [];
      var failures = [];
      var passes = [];
      var output;
      if (options.reporterOption && options.reporterOption.output) {
        if (utils.isBrowser()) {
          throw createUnsupportedError("file output not supported in browser");
        }
        output = options.reporterOption.output;
      }
      runner.on(EVENT_TEST_END, function(test) {
        tests.push(test);
      });
      runner.on(EVENT_TEST_PASS, function(test) {
        passes.push(test);
      });
      runner.on(EVENT_TEST_FAIL, function(test) {
        failures.push(test);
      });
      runner.on(EVENT_TEST_PENDING, function(test) {
        pending.push(test);
      });
      runner.once(EVENT_RUN_END, function() {
        var obj = {
          stats: self2.stats,
          tests: tests.map(clean),
          pending: pending.map(clean),
          failures: failures.map(clean),
          passes: passes.map(clean)
        };
        runner.testResults = obj;
        var json = JSON.stringify(obj, null, 2);
        if (output) {
          try {
            fs.mkdirSync(path.dirname(output), { recursive: true });
            fs.writeFileSync(output, json);
          } catch (err) {
            console.error(
              `${Base.symbols.err} [mocha] writing output to "${output}" failed: ${err.message}
`
            );
            import_process.default.stdout.write(json);
          }
        } else {
          import_process.default.stdout.write(json);
        }
      });
    }
    function clean(test) {
      var err = test.err || {};
      if (err instanceof Error) {
        err = errorJSON(err);
      }
      return {
        title: test.title,
        fullTitle: test.fullTitle(),
        file: test.file,
        duration: test.duration,
        currentRetry: test.currentRetry(),
        speed: test.speed,
        err: cleanCycles(err)
      };
    }
    function cleanCycles(obj) {
      var cache = [];
      return JSON.parse(
        JSON.stringify(obj, function(key, value) {
          if (typeof value === "object" && value !== null) {
            if (cache.indexOf(value) !== -1) {
              return "" + value;
            }
            cache.push(value);
          }
          return value;
        })
      );
    }
    function errorJSON(err) {
      var res = {};
      Object.getOwnPropertyNames(err).forEach(function(key) {
        res[key] = err[key];
      }, err);
      return res;
    }
    JSONReporter.description = "single JSON object";
  }
});

// node_modules/mocha/lib/browser/progress.js
var require_progress = __commonJS({
  "node_modules/mocha/lib/browser/progress.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = Progress;
    function Progress() {
      this.percent = 0;
      this.size(0);
      this.fontSize(11);
      this.font("helvetica, arial, sans-serif");
    }
    Progress.prototype.size = function(size) {
      this._size = size;
      return this;
    };
    Progress.prototype.text = function(text) {
      this._text = text;
      return this;
    };
    Progress.prototype.fontSize = function(size) {
      this._fontSize = size;
      return this;
    };
    Progress.prototype.font = function(family) {
      this._font = family;
      return this;
    };
    Progress.prototype.update = function(n) {
      this.percent = n;
      return this;
    };
    Progress.prototype.draw = function(ctx) {
      try {
        var darkMatcher = window.matchMedia("(prefers-color-scheme: dark)");
        var isDarkMode = !!darkMatcher.matches;
        var lightColors = {
          outerCircle: "#9f9f9f",
          innerCircle: "#eee",
          text: "#000"
        };
        var darkColors = {
          outerCircle: "#888",
          innerCircle: "#444",
          text: "#fff"
        };
        var colors = isDarkMode ? darkColors : lightColors;
        var percent = Math.min(this.percent, 100);
        var size = this._size;
        var half = size / 2;
        var x = half;
        var y = half;
        var rad = half - 1;
        var fontSize = this._fontSize;
        ctx.font = fontSize + "px " + this._font;
        var angle = Math.PI * 2 * (percent / 100);
        ctx.clearRect(0, 0, size, size);
        ctx.strokeStyle = colors.outerCircle;
        ctx.beginPath();
        ctx.arc(x, y, rad, 0, angle, false);
        ctx.stroke();
        ctx.strokeStyle = colors.innerCircle;
        ctx.beginPath();
        ctx.arc(x, y, rad - 1, 0, angle, true);
        ctx.stroke();
        var text = this._text || (percent | 0) + "%";
        var w = ctx.measureText(text).width;
        ctx.fillStyle = colors.text;
        ctx.fillText(text, x - w / 2 + 1, y + fontSize / 2 - 1);
      } catch (ignore) {
      }
      return this;
    };
  }
});

// node_modules/mocha/lib/reporters/html.js
var require_html = __commonJS({
  "node_modules/mocha/lib/reporters/html.js"(exports, module) {
    "use strict";
    init_shim();
    var Base = require_base2();
    var utils = require_utils();
    var Progress = require_progress();
    var escapeRe = require_escape_string_regexp();
    var constants = require_runner().constants;
    var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
    var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;
    var EVENT_SUITE_BEGIN = constants.EVENT_SUITE_BEGIN;
    var EVENT_SUITE_END = constants.EVENT_SUITE_END;
    var EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;
    var escape = utils.escape;
    var Date2 = _global.Date;
    exports = module.exports = HTML;
    var statsTemplate = '<ul id="mocha-stats"><li class="progress"><canvas width="40" height="40"></canvas></li><li class="passes"><a href="javascript:void(0);">passes:</a> <em>0</em></li><li class="failures"><a href="javascript:void(0);">failures:</a> <em>0</em></li><li class="duration">duration: <em>0</em>s</li></ul>';
    var playIcon = "&#x2023;";
    function HTML(runner, options) {
      Base.call(this, runner, options);
      var self2 = this;
      var stats = this.stats;
      var stat = fragment(statsTemplate);
      var items = stat.getElementsByTagName("li");
      var passes = items[1].getElementsByTagName("em")[0];
      var passesLink = items[1].getElementsByTagName("a")[0];
      var failures = items[2].getElementsByTagName("em")[0];
      var failuresLink = items[2].getElementsByTagName("a")[0];
      var duration = items[3].getElementsByTagName("em")[0];
      var canvas = stat.getElementsByTagName("canvas")[0];
      var report = fragment('<ul id="mocha-report"></ul>');
      var stack = [report];
      var progress;
      var ctx;
      var root = document.getElementById("mocha");
      if (canvas.getContext) {
        var ratio = window.devicePixelRatio || 1;
        canvas.style.width = canvas.width;
        canvas.style.height = canvas.height;
        canvas.width *= ratio;
        canvas.height *= ratio;
        ctx = canvas.getContext("2d");
        ctx.scale(ratio, ratio);
        progress = new Progress();
      }
      if (!root) {
        return error("#mocha div missing, add it to your document");
      }
      on(passesLink, "click", function(evt) {
        evt.preventDefault();
        unhide();
        var name = /pass/.test(report.className) ? "" : " pass";
        report.className = report.className.replace(/fail|pass/g, "") + name;
        if (report.className.trim()) {
          hideSuitesWithout("test pass");
        }
      });
      on(failuresLink, "click", function(evt) {
        evt.preventDefault();
        unhide();
        var name = /fail/.test(report.className) ? "" : " fail";
        report.className = report.className.replace(/fail|pass/g, "") + name;
        if (report.className.trim()) {
          hideSuitesWithout("test fail");
        }
      });
      root.appendChild(stat);
      root.appendChild(report);
      if (progress) {
        progress.size(40);
      }
      runner.on(EVENT_SUITE_BEGIN, function(suite) {
        if (suite.root) {
          return;
        }
        var url = self2.suiteURL(suite);
        var el = fragment(
          '<li class="suite"><h1><a href="%s">%s</a></h1></li>',
          url,
          escape(suite.title)
        );
        stack[0].appendChild(el);
        stack.unshift(document.createElement("ul"));
        el.appendChild(stack[0]);
      });
      runner.on(EVENT_SUITE_END, function(suite) {
        if (suite.root) {
          updateStats();
          return;
        }
        stack.shift();
      });
      runner.on(EVENT_TEST_PASS, function(test) {
        var url = self2.testURL(test);
        var markup = '<li class="test pass %e"><h2>%e<span class="duration">%ems</span> <a href="%s" class="replay">' + playIcon + "</a></h2></li>";
        var el = fragment(markup, test.speed, test.title, test.duration, url);
        self2.addCodeToggle(el, test.body);
        appendToStack(el);
        updateStats();
      });
      runner.on(EVENT_TEST_FAIL, function(test) {
        var el = fragment(
          '<li class="test fail"><h2>%e <a href="%e" class="replay">' + playIcon + "</a></h2></li>",
          test.title,
          self2.testURL(test)
        );
        var stackString;
        var message = test.err.toString();
        if (message === "[object Error]") {
          message = test.err.message;
        }
        if (test.err.stack) {
          var indexOfMessage = test.err.stack.indexOf(test.err.message);
          if (indexOfMessage === -1) {
            stackString = test.err.stack;
          } else {
            stackString = test.err.stack.slice(
              test.err.message.length + indexOfMessage
            );
          }
        } else if (test.err.sourceURL && test.err.line !== void 0) {
          stackString = "\n(" + test.err.sourceURL + ":" + test.err.line + ")";
        }
        stackString = stackString || "";
        if (test.err.htmlMessage && stackString) {
          el.appendChild(
            fragment(
              '<div class="html-error">%s\n<pre class="error">%e</pre></div>',
              test.err.htmlMessage,
              stackString
            )
          );
        } else if (test.err.htmlMessage) {
          el.appendChild(
            fragment('<div class="html-error">%s</div>', test.err.htmlMessage)
          );
        } else {
          el.appendChild(
            fragment('<pre class="error">%e%e</pre>', message, stackString)
          );
        }
        self2.addCodeToggle(el, test.body);
        appendToStack(el);
        updateStats();
      });
      runner.on(EVENT_TEST_PENDING, function(test) {
        var el = fragment(
          '<li class="test pass pending"><h2>%e</h2></li>',
          test.title
        );
        appendToStack(el);
        updateStats();
      });
      function appendToStack(el) {
        if (stack[0]) {
          stack[0].appendChild(el);
        }
      }
      function updateStats() {
        var percent = stats.tests / runner.total * 100 | 0;
        if (progress) {
          progress.update(percent).draw(ctx);
        }
        var ms = new Date2() - stats.start;
        text(passes, stats.passes);
        text(failures, stats.failures);
        text(duration, (ms / 1e3).toFixed(2));
      }
    }
    function makeUrl(s) {
      var search = window.location.search;
      if (search) {
        search = search.replace(/[?&]grep=[^&\s]*/g, "").replace(/^&/, "?");
      }
      return window.location.pathname + (search ? search + "&" : "?") + "grep=" + encodeURIComponent(escapeRe(s));
    }
    HTML.prototype.suiteURL = function(suite) {
      return makeUrl(suite.fullTitle());
    };
    HTML.prototype.testURL = function(test) {
      return makeUrl(test.fullTitle());
    };
    HTML.prototype.addCodeToggle = function(el, contents) {
      var h2 = el.getElementsByTagName("h2")[0];
      on(h2, "click", function() {
        pre.style.display = pre.style.display === "none" ? "block" : "none";
      });
      var pre = fragment("<pre><code>%e</code></pre>", utils.clean(contents));
      el.appendChild(pre);
      pre.style.display = "none";
    };
    function error(msg) {
      document.body.appendChild(fragment('<div id="mocha-error">%s</div>', msg));
    }
    function fragment(html) {
      var args = arguments;
      var div = document.createElement("div");
      var i = 1;
      div.innerHTML = html.replace(/%([se])/g, function(_, type) {
        switch (type) {
          case "s":
            return String(args[i++]);
          case "e":
            return escape(args[i++]);
        }
      });
      return div.firstChild;
    }
    function hideSuitesWithout(classname) {
      var suites = document.getElementsByClassName("suite");
      for (var i = 0; i < suites.length; i++) {
        var els = suites[i].getElementsByClassName(classname);
        if (!els.length) {
          suites[i].className += " hidden";
        }
      }
    }
    function unhide() {
      var els = document.getElementsByClassName("suite hidden");
      while (els.length > 0) {
        els[0].className = els[0].className.replace("suite hidden", "suite");
      }
    }
    function text(el, contents) {
      if (el.textContent) {
        el.textContent = contents;
      } else {
        el.innerText = contents;
      }
    }
    function on(el, event, fn) {
      if (el.addEventListener) {
        el.addEventListener(event, fn, false);
      } else {
        el.attachEvent("on" + event, fn);
      }
    }
    HTML.browserOnly = true;
  }
});

// node_modules/mocha/lib/reporters/list.js
var require_list = __commonJS({
  "node_modules/mocha/lib/reporters/list.js"(exports, module) {
    "use strict";
    init_shim();
    var Base = require_base2();
    var inherits = require_utils().inherits;
    var constants = require_runner().constants;
    var EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;
    var EVENT_RUN_END = constants.EVENT_RUN_END;
    var EVENT_TEST_BEGIN = constants.EVENT_TEST_BEGIN;
    var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;
    var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
    var EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;
    var color = Base.color;
    var cursor = Base.cursor;
    exports = module.exports = List;
    function List(runner, options) {
      Base.call(this, runner, options);
      var self2 = this;
      var n = 0;
      runner.on(EVENT_RUN_BEGIN, function() {
        Base.consoleLog();
      });
      runner.on(EVENT_TEST_BEGIN, function(test) {
        import_process.default.stdout.write(color("pass", "    " + test.fullTitle() + ": "));
      });
      runner.on(EVENT_TEST_PENDING, function(test) {
        var fmt = color("checkmark", "  -") + color("pending", " %s");
        Base.consoleLog(fmt, test.fullTitle());
      });
      runner.on(EVENT_TEST_PASS, function(test) {
        var fmt = color("checkmark", "  " + Base.symbols.ok) + color("pass", " %s: ") + color(test.speed, "%dms");
        cursor.CR();
        Base.consoleLog(fmt, test.fullTitle(), test.duration);
      });
      runner.on(EVENT_TEST_FAIL, function(test) {
        cursor.CR();
        Base.consoleLog(color("fail", "  %d) %s"), ++n, test.fullTitle());
      });
      runner.once(EVENT_RUN_END, self2.epilogue.bind(self2));
    }
    inherits(List, Base);
    List.description = 'like "spec" reporter but flat';
  }
});

// node_modules/mocha/lib/reporters/min.js
var require_min = __commonJS({
  "node_modules/mocha/lib/reporters/min.js"(exports, module) {
    "use strict";
    init_shim();
    var Base = require_base2();
    var inherits = require_utils().inherits;
    var constants = require_runner().constants;
    var EVENT_RUN_END = constants.EVENT_RUN_END;
    var EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;
    exports = module.exports = Min;
    function Min(runner, options) {
      Base.call(this, runner, options);
      runner.on(EVENT_RUN_BEGIN, function() {
        import_process.default.stdout.write("\x1B[2J");
        import_process.default.stdout.write("\x1B[1;3H");
      });
      runner.once(EVENT_RUN_END, this.epilogue.bind(this));
    }
    inherits(Min, Base);
    Min.description = "essentially just a summary";
  }
});

// node_modules/mocha/lib/reporters/spec.js
var require_spec = __commonJS({
  "node_modules/mocha/lib/reporters/spec.js"(exports, module) {
    "use strict";
    init_shim();
    var Base = require_base2();
    var constants = require_runner().constants;
    var EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;
    var EVENT_RUN_END = constants.EVENT_RUN_END;
    var EVENT_SUITE_BEGIN = constants.EVENT_SUITE_BEGIN;
    var EVENT_SUITE_END = constants.EVENT_SUITE_END;
    var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;
    var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
    var EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;
    var inherits = require_utils().inherits;
    var color = Base.color;
    exports = module.exports = Spec;
    function Spec(runner, options) {
      Base.call(this, runner, options);
      var self2 = this;
      var indents = 0;
      var n = 0;
      function indent() {
        return Array(indents).join("  ");
      }
      runner.on(EVENT_RUN_BEGIN, function() {
        Base.consoleLog();
      });
      runner.on(EVENT_SUITE_BEGIN, function(suite) {
        ++indents;
        Base.consoleLog(color("suite", "%s%s"), indent(), suite.title);
      });
      runner.on(EVENT_SUITE_END, function() {
        --indents;
        if (indents === 1) {
          Base.consoleLog();
        }
      });
      runner.on(EVENT_TEST_PENDING, function(test) {
        var fmt = indent() + color("pending", "  - %s");
        Base.consoleLog(fmt, test.title);
      });
      runner.on(EVENT_TEST_PASS, function(test) {
        var fmt;
        if (test.speed === "fast") {
          fmt = indent() + color("checkmark", "  " + Base.symbols.ok) + color("pass", " %s");
          Base.consoleLog(fmt, test.title);
        } else {
          fmt = indent() + color("checkmark", "  " + Base.symbols.ok) + color("pass", " %s") + color(test.speed, " (%dms)");
          Base.consoleLog(fmt, test.title, test.duration);
        }
      });
      runner.on(EVENT_TEST_FAIL, function(test) {
        Base.consoleLog(indent() + color("fail", "  %d) %s"), ++n, test.title);
      });
      runner.once(EVENT_RUN_END, self2.epilogue.bind(self2));
    }
    inherits(Spec, Base);
    Spec.description = "hierarchical & verbose [default]";
  }
});

// node_modules/mocha/lib/reporters/nyan.js
var require_nyan = __commonJS({
  "node_modules/mocha/lib/reporters/nyan.js"(exports, module) {
    "use strict";
    init_shim();
    var Base = require_base2();
    var constants = require_runner().constants;
    var inherits = require_utils().inherits;
    var EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;
    var EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;
    var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
    var EVENT_RUN_END = constants.EVENT_RUN_END;
    var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;
    exports = module.exports = NyanCat;
    function NyanCat(runner, options) {
      Base.call(this, runner, options);
      var self2 = this;
      var width = Base.window.width * 0.75 | 0;
      var nyanCatWidth = this.nyanCatWidth = 11;
      this.colorIndex = 0;
      this.numberOfLines = 4;
      this.rainbowColors = self2.generateColors();
      this.scoreboardWidth = 5;
      this.tick = 0;
      this.trajectories = [[], [], [], []];
      this.trajectoryWidthMax = width - nyanCatWidth;
      runner.on(EVENT_RUN_BEGIN, function() {
        Base.cursor.hide();
        self2.draw();
      });
      runner.on(EVENT_TEST_PENDING, function() {
        self2.draw();
      });
      runner.on(EVENT_TEST_PASS, function() {
        self2.draw();
      });
      runner.on(EVENT_TEST_FAIL, function() {
        self2.draw();
      });
      runner.once(EVENT_RUN_END, function() {
        Base.cursor.show();
        for (var i = 0; i < self2.numberOfLines; i++) {
          write("\n");
        }
        self2.epilogue();
      });
    }
    inherits(NyanCat, Base);
    NyanCat.prototype.draw = function() {
      this.appendRainbow();
      this.drawScoreboard();
      this.drawRainbow();
      this.drawNyanCat();
      this.tick = !this.tick;
    };
    NyanCat.prototype.drawScoreboard = function() {
      var stats = this.stats;
      function draw(type, n) {
        write(" ");
        write(Base.color(type, n));
        write("\n");
      }
      draw("green", stats.passes);
      draw("fail", stats.failures);
      draw("pending", stats.pending);
      write("\n");
      this.cursorUp(this.numberOfLines);
    };
    NyanCat.prototype.appendRainbow = function() {
      var segment = this.tick ? "_" : "-";
      var rainbowified = this.rainbowify(segment);
      for (var index = 0; index < this.numberOfLines; index++) {
        var trajectory = this.trajectories[index];
        if (trajectory.length >= this.trajectoryWidthMax) {
          trajectory.shift();
        }
        trajectory.push(rainbowified);
      }
    };
    NyanCat.prototype.drawRainbow = function() {
      var self2 = this;
      this.trajectories.forEach(function(line) {
        write("\x1B[" + self2.scoreboardWidth + "C");
        write(line.join(""));
        write("\n");
      });
      this.cursorUp(this.numberOfLines);
    };
    NyanCat.prototype.drawNyanCat = function() {
      var self2 = this;
      var startWidth = this.scoreboardWidth + this.trajectories[0].length;
      var dist = "\x1B[" + startWidth + "C";
      var padding = "";
      write(dist);
      write("_,------,");
      write("\n");
      write(dist);
      padding = self2.tick ? "  " : "   ";
      write("_|" + padding + "/\\_/\\ ");
      write("\n");
      write(dist);
      padding = self2.tick ? "_" : "__";
      var tail = self2.tick ? "~" : "^";
      write(tail + "|" + padding + this.face() + " ");
      write("\n");
      write(dist);
      padding = self2.tick ? " " : "  ";
      write(padding + '""  "" ');
      write("\n");
      this.cursorUp(this.numberOfLines);
    };
    NyanCat.prototype.face = function() {
      var stats = this.stats;
      if (stats.failures) {
        return "( x .x)";
      } else if (stats.pending) {
        return "( o .o)";
      } else if (stats.passes) {
        return "( ^ .^)";
      }
      return "( - .-)";
    };
    NyanCat.prototype.cursorUp = function(n) {
      write("\x1B[" + n + "A");
    };
    NyanCat.prototype.cursorDown = function(n) {
      write("\x1B[" + n + "B");
    };
    NyanCat.prototype.generateColors = function() {
      var colors = [];
      for (var i = 0; i < 6 * 7; i++) {
        var pi3 = Math.floor(Math.PI / 3);
        var n = i * (1 / 6);
        var r = Math.floor(3 * Math.sin(n) + 3);
        var g = Math.floor(3 * Math.sin(n + 2 * pi3) + 3);
        var b = Math.floor(3 * Math.sin(n + 4 * pi3) + 3);
        colors.push(36 * r + 6 * g + b + 16);
      }
      return colors;
    };
    NyanCat.prototype.rainbowify = function(str) {
      if (!Base.useColors) {
        return str;
      }
      var color = this.rainbowColors[this.colorIndex % this.rainbowColors.length];
      this.colorIndex += 1;
      return "\x1B[38;5;" + color + "m" + str + "\x1B[0m";
    };
    function write(string) {
      import_process.default.stdout.write(string);
    }
    NyanCat.description = '"nyan cat"';
  }
});

// node_modules/mocha/lib/reporters/xunit.js
var require_xunit = __commonJS({
  "node_modules/mocha/lib/reporters/xunit.js"(exports, module) {
    "use strict";
    init_shim();
    var Base = require_base2();
    var utils = require_utils();
    var fs = (init_empty(), __toCommonJS(empty_exports));
    var path = require_path_browserify();
    var errors = require_errors();
    var createUnsupportedError = errors.createUnsupportedError;
    var constants = require_runner().constants;
    var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
    var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;
    var EVENT_RUN_END = constants.EVENT_RUN_END;
    var EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;
    var STATE_FAILED = require_runnable().constants.STATE_FAILED;
    var inherits = utils.inherits;
    var escape = utils.escape;
    var Date2 = _global.Date;
    exports = module.exports = XUnit;
    function XUnit(runner, options) {
      Base.call(this, runner, options);
      var stats = this.stats;
      var tests = [];
      var self2 = this;
      var suiteName;
      var DEFAULT_SUITE_NAME = "Mocha Tests";
      if (options && options.reporterOptions) {
        if (options.reporterOptions.output) {
          if (!fs.createWriteStream) {
            throw createUnsupportedError("file output not supported in browser");
          }
          fs.mkdirSync(path.dirname(options.reporterOptions.output), {
            recursive: true
          });
          self2.fileStream = fs.createWriteStream(options.reporterOptions.output);
        }
        suiteName = options.reporterOptions.suiteName;
      }
      suiteName = suiteName || DEFAULT_SUITE_NAME;
      runner.on(EVENT_TEST_PENDING, function(test) {
        tests.push(test);
      });
      runner.on(EVENT_TEST_PASS, function(test) {
        tests.push(test);
      });
      runner.on(EVENT_TEST_FAIL, function(test) {
        tests.push(test);
      });
      runner.once(EVENT_RUN_END, function() {
        self2.write(
          tag(
            "testsuite",
            {
              name: suiteName,
              tests: stats.tests,
              failures: 0,
              errors: stats.failures,
              skipped: stats.tests - stats.failures - stats.passes,
              timestamp: new Date2().toUTCString(),
              time: stats.duration / 1e3 || 0
            },
            false
          )
        );
        tests.forEach(function(t) {
          self2.test(t);
        });
        self2.write("</testsuite>");
      });
    }
    inherits(XUnit, Base);
    XUnit.prototype.done = function(failures, fn) {
      if (this.fileStream) {
        this.fileStream.end(function() {
          fn(failures);
        });
      } else {
        fn(failures);
      }
    };
    XUnit.prototype.write = function(line) {
      if (this.fileStream) {
        this.fileStream.write(line + "\n");
      } else if (typeof import_process.default === "object" && import_process.default.stdout) {
        import_process.default.stdout.write(line + "\n");
      } else {
        Base.consoleLog(line);
      }
    };
    XUnit.prototype.test = function(test) {
      Base.useColors = false;
      var attrs = {
        classname: test.parent.fullTitle(),
        name: test.title,
        time: test.duration / 1e3 || 0
      };
      if (test.state === STATE_FAILED) {
        var err = test.err;
        var diff = !Base.hideDiff && Base.showDiff(err) ? "\n" + Base.generateDiff(err.actual, err.expected) : "";
        this.write(
          tag(
            "testcase",
            attrs,
            false,
            tag(
              "failure",
              {},
              false,
              escape(err.message) + escape(diff) + "\n" + escape(err.stack)
            )
          )
        );
      } else if (test.isPending()) {
        this.write(tag("testcase", attrs, false, tag("skipped", {}, true)));
      } else {
        this.write(tag("testcase", attrs, true));
      }
    };
    function tag(name, attrs, close, content) {
      var end = close ? "/>" : ">";
      var pairs = [];
      var tag2;
      for (var key in attrs) {
        if (Object.prototype.hasOwnProperty.call(attrs, key)) {
          pairs.push(key + '="' + escape(attrs[key]) + '"');
        }
      }
      tag2 = "<" + name + (pairs.length ? " " + pairs.join(" ") : "") + end;
      if (content) {
        tag2 += content + "</" + name + end;
      }
      return tag2;
    }
    XUnit.description = "XUnit-compatible XML output";
  }
});

// node_modules/mocha/lib/reporters/markdown.js
var require_markdown = __commonJS({
  "node_modules/mocha/lib/reporters/markdown.js"(exports, module) {
    "use strict";
    init_shim();
    var Base = require_base2();
    var utils = require_utils();
    var constants = require_runner().constants;
    var EVENT_RUN_END = constants.EVENT_RUN_END;
    var EVENT_SUITE_BEGIN = constants.EVENT_SUITE_BEGIN;
    var EVENT_SUITE_END = constants.EVENT_SUITE_END;
    var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
    var SUITE_PREFIX = "$";
    exports = module.exports = Markdown;
    function Markdown(runner, options) {
      Base.call(this, runner, options);
      var level = 0;
      var buf = "";
      function title(str) {
        return Array(level).join("#") + " " + str;
      }
      function mapTOC(suite, obj) {
        var ret = obj;
        var key = SUITE_PREFIX + suite.title;
        obj = obj[key] = obj[key] || { suite };
        suite.suites.forEach(function(suite2) {
          mapTOC(suite2, obj);
        });
        return ret;
      }
      function stringifyTOC(obj, level2) {
        ++level2;
        var buf2 = "";
        var link;
        for (var key in obj) {
          if (key === "suite") {
            continue;
          }
          if (key !== SUITE_PREFIX) {
            link = " - [" + key.substring(1) + "]";
            link += "(#" + utils.slug(obj[key].suite.fullTitle()) + ")\n";
            buf2 += Array(level2).join("  ") + link;
          }
          buf2 += stringifyTOC(obj[key], level2);
        }
        return buf2;
      }
      function generateTOC(suite) {
        var obj = mapTOC(suite, {});
        return stringifyTOC(obj, 0);
      }
      generateTOC(runner.suite);
      runner.on(EVENT_SUITE_BEGIN, function(suite) {
        ++level;
        var slug = utils.slug(suite.fullTitle());
        buf += '<a name="' + slug + '"></a>\n';
        buf += title(suite.title) + "\n";
      });
      runner.on(EVENT_SUITE_END, function() {
        --level;
      });
      runner.on(EVENT_TEST_PASS, function(test) {
        var code = utils.clean(test.body);
        buf += test.title + ".\n";
        buf += "\n```js\n";
        buf += code + "\n";
        buf += "```\n\n";
      });
      runner.once(EVENT_RUN_END, function() {
        import_process.default.stdout.write("# TOC\n");
        import_process.default.stdout.write(generateTOC(runner.suite));
        import_process.default.stdout.write(buf);
      });
    }
    Markdown.description = "GitHub Flavored Markdown";
  }
});

// node_modules/mocha/lib/reporters/progress.js
var require_progress2 = __commonJS({
  "node_modules/mocha/lib/reporters/progress.js"(exports, module) {
    "use strict";
    init_shim();
    var Base = require_base2();
    var constants = require_runner().constants;
    var EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;
    var EVENT_TEST_END = constants.EVENT_TEST_END;
    var EVENT_RUN_END = constants.EVENT_RUN_END;
    var inherits = require_utils().inherits;
    var color = Base.color;
    var cursor = Base.cursor;
    exports = module.exports = Progress;
    Base.colors.progress = 90;
    function Progress(runner, options) {
      Base.call(this, runner, options);
      var self2 = this;
      var width = Base.window.width * 0.5 | 0;
      var total = runner.total;
      var complete = 0;
      var lastN = -1;
      options = options || {};
      var reporterOptions = options.reporterOptions || {};
      options.open = reporterOptions.open || "[";
      options.complete = reporterOptions.complete || "▬";
      options.incomplete = reporterOptions.incomplete || Base.symbols.dot;
      options.close = reporterOptions.close || "]";
      options.verbose = reporterOptions.verbose || false;
      runner.on(EVENT_RUN_BEGIN, function() {
        import_process.default.stdout.write("\n");
        cursor.hide();
      });
      runner.on(EVENT_TEST_END, function() {
        complete++;
        var percent = complete / total;
        var n = width * percent | 0;
        var i = width - n;
        if (n === lastN && !options.verbose) {
          return;
        }
        lastN = n;
        cursor.CR();
        import_process.default.stdout.write("\x1B[J");
        import_process.default.stdout.write(color("progress", "  " + options.open));
        import_process.default.stdout.write(Array(n).join(options.complete));
        import_process.default.stdout.write(Array(i).join(options.incomplete));
        import_process.default.stdout.write(color("progress", options.close));
        if (options.verbose) {
          import_process.default.stdout.write(color("progress", " " + complete + " of " + total));
        }
      });
      runner.once(EVENT_RUN_END, function() {
        cursor.show();
        import_process.default.stdout.write("\n");
        self2.epilogue();
      });
    }
    inherits(Progress, Base);
    Progress.description = "a progress bar";
  }
});

// node_modules/mocha/lib/reporters/landing.js
var require_landing = __commonJS({
  "node_modules/mocha/lib/reporters/landing.js"(exports, module) {
    "use strict";
    init_shim();
    var Base = require_base2();
    var inherits = require_utils().inherits;
    var constants = require_runner().constants;
    var EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;
    var EVENT_RUN_END = constants.EVENT_RUN_END;
    var EVENT_TEST_END = constants.EVENT_TEST_END;
    var STATE_FAILED = require_runnable().constants.STATE_FAILED;
    var cursor = Base.cursor;
    var color = Base.color;
    exports = module.exports = Landing;
    Base.colors.plane = 0;
    Base.colors["plane crash"] = 31;
    Base.colors.runway = 90;
    function Landing(runner, options) {
      Base.call(this, runner, options);
      var self2 = this;
      var width = Base.window.width * 0.75 | 0;
      var stream = import_process.default.stdout;
      var plane = color("plane", "✈");
      var crashed = -1;
      var n = 0;
      var total = 0;
      function runway() {
        var buf = Array(width).join("-");
        return "  " + color("runway", buf);
      }
      runner.on(EVENT_RUN_BEGIN, function() {
        stream.write("\n\n\n  ");
        cursor.hide();
      });
      runner.on(EVENT_TEST_END, function(test) {
        var col = crashed === -1 ? width * ++n / ++total | 0 : crashed;
        if (test.state === STATE_FAILED) {
          plane = color("plane crash", "✈");
          crashed = col;
        }
        stream.write("\x1B[" + (width + 1) + "D\x1B[2A");
        stream.write(runway());
        stream.write("\n  ");
        stream.write(color("runway", Array(col).join("⋅")));
        stream.write(plane);
        stream.write(color("runway", Array(width - col).join("⋅") + "\n"));
        stream.write(runway());
        stream.write("\x1B[0m");
      });
      runner.once(EVENT_RUN_END, function() {
        cursor.show();
        import_process.default.stdout.write("\n");
        self2.epilogue();
      });
      import_process.default.once("SIGINT", function() {
        cursor.show();
        import_process.default.nextTick(function() {
          import_process.default.kill(import_process.default.pid, "SIGINT");
        });
      });
    }
    inherits(Landing, Base);
    Landing.description = "Unicode landing strip";
  }
});

// node_modules/mocha/lib/reporters/json-stream.js
var require_json_stream = __commonJS({
  "node_modules/mocha/lib/reporters/json-stream.js"(exports, module) {
    "use strict";
    init_shim();
    var Base = require_base2();
    var constants = require_runner().constants;
    var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
    var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;
    var EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;
    var EVENT_RUN_END = constants.EVENT_RUN_END;
    exports = module.exports = JSONStream;
    function JSONStream(runner, options) {
      Base.call(this, runner, options);
      var self2 = this;
      var total = runner.total;
      runner.once(EVENT_RUN_BEGIN, function() {
        writeEvent(["start", { total }]);
      });
      runner.on(EVENT_TEST_PASS, function(test) {
        writeEvent(["pass", clean(test)]);
      });
      runner.on(EVENT_TEST_FAIL, function(test, err) {
        test = clean(test);
        test.err = err.message;
        test.stack = err.stack || null;
        writeEvent(["fail", test]);
      });
      runner.once(EVENT_RUN_END, function() {
        writeEvent(["end", self2.stats]);
      });
    }
    function writeEvent(event) {
      import_process.default.stdout.write(JSON.stringify(event) + "\n");
    }
    function clean(test) {
      return {
        title: test.title,
        fullTitle: test.fullTitle(),
        file: test.file,
        duration: test.duration,
        currentRetry: test.currentRetry(),
        speed: test.speed
      };
    }
    JSONStream.description = "newline delimited JSON events";
  }
});

// node_modules/mocha/lib/reporters/index.js
var require_reporters = __commonJS({
  "node_modules/mocha/lib/reporters/index.js"(exports) {
    "use strict";
    init_shim();
    exports.Base = exports.base = require_base2();
    exports.Dot = exports.dot = require_dot();
    exports.Doc = exports.doc = require_doc();
    exports.TAP = exports.tap = require_tap();
    exports.JSON = exports.json = require_json2();
    exports.HTML = exports.html = require_html();
    exports.List = exports.list = require_list();
    exports.Min = exports.min = require_min();
    exports.Spec = exports.spec = require_spec();
    exports.Nyan = exports.nyan = require_nyan();
    exports.XUnit = exports.xunit = require_xunit();
    exports.Markdown = exports.markdown = require_markdown();
    exports.Progress = exports.progress = require_progress2();
    exports.Landing = exports.landing = require_landing();
    exports.JSONStream = exports["json-stream"] = require_json_stream();
  }
});

// node_modules/mocha/lib/mocharc.json
var require_mocharc = __commonJS({
  "node_modules/mocha/lib/mocharc.json"(exports, module) {
    module.exports = {
      diff: true,
      extension: ["js", "cjs", "mjs"],
      package: "./package.json",
      reporter: "spec",
      slow: 75,
      timeout: 2e3,
      ui: "bdd",
      "watch-ignore": ["node_modules", ".git"]
    };
  }
});

// (disabled):node_modules/mocha/lib/nodejs/esm-utils
var require_esm_utils = __commonJS({
  "(disabled):node_modules/mocha/lib/nodejs/esm-utils"() {
    init_shim();
  }
});

// node_modules/mocha/lib/stats-collector.js
var require_stats_collector = __commonJS({
  "node_modules/mocha/lib/stats-collector.js"(exports, module) {
    "use strict";
    init_shim();
    var constants = require_runner().constants;
    var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
    var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;
    var EVENT_SUITE_BEGIN = constants.EVENT_SUITE_BEGIN;
    var EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;
    var EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;
    var EVENT_RUN_END = constants.EVENT_RUN_END;
    var EVENT_TEST_END = constants.EVENT_TEST_END;
    var Date2 = _global.Date;
    function createStatsCollector(runner) {
      var stats = {
        suites: 0,
        tests: 0,
        passes: 0,
        pending: 0,
        failures: 0
      };
      if (!runner) {
        throw new TypeError("Missing runner argument");
      }
      runner.stats = stats;
      runner.once(EVENT_RUN_BEGIN, function() {
        stats.start = new Date2();
      });
      runner.on(EVENT_SUITE_BEGIN, function(suite) {
        suite.root || stats.suites++;
      });
      runner.on(EVENT_TEST_PASS, function() {
        stats.passes++;
      });
      runner.on(EVENT_TEST_FAIL, function() {
        stats.failures++;
      });
      runner.on(EVENT_TEST_PENDING, function() {
        stats.pending++;
      });
      runner.on(EVENT_TEST_END, function() {
        stats.tests++;
      });
      runner.once(EVENT_RUN_END, function() {
        stats.end = new Date2();
        stats.duration = stats.end - stats.start;
      });
    }
    module.exports = createStatsCollector;
  }
});

// node_modules/mocha/lib/test.js
var require_test = __commonJS({
  "node_modules/mocha/lib/test.js"(exports, module) {
    "use strict";
    init_shim();
    var Runnable = require_runnable();
    var utils = require_utils();
    var errors = require_errors();
    var createInvalidArgumentTypeError = errors.createInvalidArgumentTypeError;
    var isString = utils.isString;
    var { MOCHA_ID_PROP_NAME } = utils.constants;
    module.exports = Test;
    function Test(title, fn) {
      if (!isString(title)) {
        throw createInvalidArgumentTypeError(
          'Test argument "title" should be a string. Received type "' + typeof title + '"',
          "title",
          "string"
        );
      }
      this.type = "test";
      Runnable.call(this, title, fn);
      this.reset();
    }
    utils.inherits(Test, Runnable);
    Test.prototype.reset = function() {
      Runnable.prototype.reset.call(this);
      this.pending = !this.fn;
      delete this.state;
    };
    Test.prototype.retriedTest = function(n) {
      if (!arguments.length) {
        return this._retriedTest;
      }
      this._retriedTest = n;
    };
    Test.prototype.markOnly = function() {
      this.parent.appendOnlyTest(this);
    };
    Test.prototype.clone = function() {
      var test = new Test(this.title, this.fn);
      test.timeout(this.timeout());
      test.slow(this.slow());
      test.retries(this.retries());
      test.currentRetry(this.currentRetry());
      test.retriedTest(this.retriedTest() || this);
      test.globals(this.globals());
      test.parent = this.parent;
      test.file = this.file;
      test.ctx = this.ctx;
      return test;
    };
    Test.prototype.serialize = function serialize() {
      return {
        $$currentRetry: this._currentRetry,
        $$fullTitle: this.fullTitle(),
        $$isPending: Boolean(this.pending),
        $$retriedTest: this._retriedTest || null,
        $$slow: this._slow,
        $$titlePath: this.titlePath(),
        body: this.body,
        duration: this.duration,
        err: this.err,
        parent: {
          $$fullTitle: this.parent.fullTitle(),
          [MOCHA_ID_PROP_NAME]: this.parent.id
        },
        speed: this.speed,
        state: this.state,
        title: this.title,
        type: this.type,
        file: this.file,
        [MOCHA_ID_PROP_NAME]: this.id
      };
    };
  }
});

// node_modules/mocha/lib/interfaces/common.js
var require_common2 = __commonJS({
  "node_modules/mocha/lib/interfaces/common.js"(exports, module) {
    "use strict";
    init_shim();
    var Suite = require_suite();
    var errors = require_errors();
    var createMissingArgumentError = errors.createMissingArgumentError;
    var createUnsupportedError = errors.createUnsupportedError;
    var createForbiddenExclusivityError = errors.createForbiddenExclusivityError;
    module.exports = function(suites, context, mocha) {
      function shouldBeTested(suite) {
        return !mocha.options.grep || mocha.options.grep && mocha.options.grep.test(suite.fullTitle()) && !mocha.options.invert;
      }
      return {
        /**
         * This is only present if flag --delay is passed into Mocha. It triggers
         * root suite execution.
         *
         * @param {Suite} suite The root suite.
         * @return {Function} A function which runs the root suite
         */
        runWithSuite: function runWithSuite(suite) {
          return function run() {
            suite.run();
          };
        },
        /**
         * Execute before running tests.
         *
         * @param {string} name
         * @param {Function} fn
         */
        before: function(name, fn) {
          suites[0].beforeAll(name, fn);
        },
        /**
         * Execute after running tests.
         *
         * @param {string} name
         * @param {Function} fn
         */
        after: function(name, fn) {
          suites[0].afterAll(name, fn);
        },
        /**
         * Execute before each test case.
         *
         * @param {string} name
         * @param {Function} fn
         */
        beforeEach: function(name, fn) {
          suites[0].beforeEach(name, fn);
        },
        /**
         * Execute after each test case.
         *
         * @param {string} name
         * @param {Function} fn
         */
        afterEach: function(name, fn) {
          suites[0].afterEach(name, fn);
        },
        suite: {
          /**
           * Create an exclusive Suite; convenience function
           * See docstring for create() below.
           *
           * @param {Object} opts
           * @returns {Suite}
           */
          only: function only(opts) {
            if (mocha.options.forbidOnly) {
              throw createForbiddenExclusivityError(mocha);
            }
            opts.isOnly = true;
            return this.create(opts);
          },
          /**
           * Create a Suite, but skip it; convenience function
           * See docstring for create() below.
           *
           * @param {Object} opts
           * @returns {Suite}
           */
          skip: function skip(opts) {
            opts.pending = true;
            return this.create(opts);
          },
          /**
           * Creates a suite.
           *
           * @param {Object} opts Options
           * @param {string} opts.title Title of Suite
           * @param {Function} [opts.fn] Suite Function (not always applicable)
           * @param {boolean} [opts.pending] Is Suite pending?
           * @param {string} [opts.file] Filepath where this Suite resides
           * @param {boolean} [opts.isOnly] Is Suite exclusive?
           * @returns {Suite}
           */
          create: function create(opts) {
            var suite = Suite.create(suites[0], opts.title);
            suite.pending = Boolean(opts.pending);
            suite.file = opts.file;
            suites.unshift(suite);
            if (opts.isOnly) {
              suite.markOnly();
            }
            if (suite.pending && mocha.options.forbidPending && shouldBeTested(suite)) {
              throw createUnsupportedError("Pending test forbidden");
            }
            if (typeof opts.fn === "function") {
              opts.fn.call(suite);
              suites.shift();
            } else if (typeof opts.fn === "undefined" && !suite.pending) {
              throw createMissingArgumentError(
                'Suite "' + suite.fullTitle() + '" was defined but no callback was supplied. Supply a callback or explicitly skip the suite.',
                "callback",
                "function"
              );
            } else if (!opts.fn && suite.pending) {
              suites.shift();
            }
            return suite;
          }
        },
        test: {
          /**
           * Exclusive test-case.
           *
           * @param {Object} mocha
           * @param {Function} test
           * @returns {*}
           */
          only: function(mocha2, test) {
            if (mocha2.options.forbidOnly) {
              throw createForbiddenExclusivityError(mocha2);
            }
            test.markOnly();
            return test;
          },
          /**
           * Pending test case.
           *
           * @param {string} title
           */
          skip: function(title) {
            context.test(title);
          }
        }
      };
    };
  }
});

// node_modules/mocha/lib/interfaces/bdd.js
var require_bdd = __commonJS({
  "node_modules/mocha/lib/interfaces/bdd.js"(exports, module) {
    "use strict";
    init_shim();
    var Test = require_test();
    var EVENT_FILE_PRE_REQUIRE = require_suite().constants.EVENT_FILE_PRE_REQUIRE;
    module.exports = function bddInterface(suite) {
      var suites = [suite];
      suite.on(EVENT_FILE_PRE_REQUIRE, function(context, file, mocha) {
        var common = require_common2()(suites, context, mocha);
        context.before = common.before;
        context.after = common.after;
        context.beforeEach = common.beforeEach;
        context.afterEach = common.afterEach;
        context.run = mocha.options.delay && common.runWithSuite(suite);
        context.describe = context.context = function(title, fn) {
          return common.suite.create({
            title,
            file,
            fn
          });
        };
        context.xdescribe = context.xcontext = context.describe.skip = function(title, fn) {
          return common.suite.skip({
            title,
            file,
            fn
          });
        };
        context.describe.only = function(title, fn) {
          return common.suite.only({
            title,
            file,
            fn
          });
        };
        context.it = context.specify = function(title, fn) {
          var suite2 = suites[0];
          if (suite2.isPending()) {
            fn = null;
          }
          var test = new Test(title, fn);
          test.file = file;
          suite2.addTest(test);
          return test;
        };
        context.it.only = function(title, fn) {
          return common.test.only(mocha, context.it(title, fn));
        };
        context.xit = context.xspecify = context.it.skip = function(title) {
          return context.it(title);
        };
      });
    };
    module.exports.description = "BDD or RSpec style [default]";
  }
});

// node_modules/mocha/lib/interfaces/tdd.js
var require_tdd = __commonJS({
  "node_modules/mocha/lib/interfaces/tdd.js"(exports, module) {
    "use strict";
    init_shim();
    var Test = require_test();
    var EVENT_FILE_PRE_REQUIRE = require_suite().constants.EVENT_FILE_PRE_REQUIRE;
    module.exports = function(suite) {
      var suites = [suite];
      suite.on(EVENT_FILE_PRE_REQUIRE, function(context, file, mocha) {
        var common = require_common2()(suites, context, mocha);
        context.setup = common.beforeEach;
        context.teardown = common.afterEach;
        context.suiteSetup = common.before;
        context.suiteTeardown = common.after;
        context.run = mocha.options.delay && common.runWithSuite(suite);
        context.suite = function(title, fn) {
          return common.suite.create({
            title,
            file,
            fn
          });
        };
        context.suite.skip = function(title, fn) {
          return common.suite.skip({
            title,
            file,
            fn
          });
        };
        context.suite.only = function(title, fn) {
          return common.suite.only({
            title,
            file,
            fn
          });
        };
        context.test = function(title, fn) {
          var suite2 = suites[0];
          if (suite2.isPending()) {
            fn = null;
          }
          var test = new Test(title, fn);
          test.file = file;
          suite2.addTest(test);
          return test;
        };
        context.test.only = function(title, fn) {
          return common.test.only(mocha, context.test(title, fn));
        };
        context.test.skip = common.test.skip;
      });
    };
    module.exports.description = `traditional "suite"/"test" instead of BDD's "describe"/"it"`;
  }
});

// node_modules/mocha/lib/interfaces/qunit.js
var require_qunit = __commonJS({
  "node_modules/mocha/lib/interfaces/qunit.js"(exports, module) {
    "use strict";
    init_shim();
    var Test = require_test();
    var EVENT_FILE_PRE_REQUIRE = require_suite().constants.EVENT_FILE_PRE_REQUIRE;
    module.exports = function qUnitInterface(suite) {
      var suites = [suite];
      suite.on(EVENT_FILE_PRE_REQUIRE, function(context, file, mocha) {
        var common = require_common2()(suites, context, mocha);
        context.before = common.before;
        context.after = common.after;
        context.beforeEach = common.beforeEach;
        context.afterEach = common.afterEach;
        context.run = mocha.options.delay && common.runWithSuite(suite);
        context.suite = function(title) {
          if (suites.length > 1) {
            suites.shift();
          }
          return common.suite.create({
            title,
            file,
            fn: false
          });
        };
        context.suite.only = function(title) {
          if (suites.length > 1) {
            suites.shift();
          }
          return common.suite.only({
            title,
            file,
            fn: false
          });
        };
        context.test = function(title, fn) {
          var test = new Test(title, fn);
          test.file = file;
          suites[0].addTest(test);
          return test;
        };
        context.test.only = function(title, fn) {
          return common.test.only(mocha, context.test(title, fn));
        };
        context.test.skip = common.test.skip;
      });
    };
    module.exports.description = "QUnit style";
  }
});

// node_modules/mocha/lib/interfaces/exports.js
var require_exports = __commonJS({
  "node_modules/mocha/lib/interfaces/exports.js"(exports, module) {
    "use strict";
    init_shim();
    var Suite = require_suite();
    var Test = require_test();
    module.exports = function(suite) {
      var suites = [suite];
      suite.on(Suite.constants.EVENT_FILE_REQUIRE, visit);
      function visit(obj, file) {
        var suite2;
        for (var key in obj) {
          if (typeof obj[key] === "function") {
            var fn = obj[key];
            switch (key) {
              case "before":
                suites[0].beforeAll(fn);
                break;
              case "after":
                suites[0].afterAll(fn);
                break;
              case "beforeEach":
                suites[0].beforeEach(fn);
                break;
              case "afterEach":
                suites[0].afterEach(fn);
                break;
              default:
                var test = new Test(key, fn);
                test.file = file;
                suites[0].addTest(test);
            }
          } else {
            suite2 = Suite.create(suites[0], key);
            suites.unshift(suite2);
            visit(obj[key], file);
            suites.shift();
          }
        }
      }
    };
    module.exports.description = 'Node.js module ("exports") style';
  }
});

// node_modules/mocha/lib/interfaces/index.js
var require_interfaces = __commonJS({
  "node_modules/mocha/lib/interfaces/index.js"(exports) {
    "use strict";
    init_shim();
    exports.bdd = require_bdd();
    exports.tdd = require_tdd();
    exports.qunit = require_qunit();
    exports.exports = require_exports();
  }
});

// node_modules/mocha/lib/context.js
var require_context = __commonJS({
  "node_modules/mocha/lib/context.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = Context;
    function Context() {
    }
    Context.prototype.runnable = function(runnable) {
      if (!arguments.length) {
        return this._runnable;
      }
      this.test = this._runnable = runnable;
      return this;
    };
    Context.prototype.timeout = function(ms) {
      if (!arguments.length) {
        return this.runnable().timeout();
      }
      this.runnable().timeout(ms);
      return this;
    };
    Context.prototype.slow = function(ms) {
      if (!arguments.length) {
        return this.runnable().slow();
      }
      this.runnable().slow(ms);
      return this;
    };
    Context.prototype.skip = function() {
      this.runnable().skip();
    };
    Context.prototype.retries = function(n) {
      if (!arguments.length) {
        return this.runnable().retries();
      }
      this.runnable().retries(n);
      return this;
    };
  }
});

// (disabled):node_modules/mocha/lib/nodejs/file-unloader
var require_file_unloader = __commonJS({
  "(disabled):node_modules/mocha/lib/nodejs/file-unloader"() {
    init_shim();
  }
});

// node_modules/mocha/package.json
var require_package = __commonJS({
  "node_modules/mocha/package.json"(exports, module) {
    module.exports = {
      name: "mocha",
      version: "10.2.0",
      type: "commonjs",
      description: "simple, flexible, fun test framework",
      keywords: [
        "mocha",
        "test",
        "bdd",
        "tdd",
        "tap",
        "testing",
        "chai",
        "assertion",
        "ava",
        "jest",
        "tape",
        "jasmine",
        "karma"
      ],
      author: "TJ Holowaychuk <tj@vision-media.ca>",
      license: "MIT",
      repository: {
        type: "git",
        url: "https://github.com/mochajs/mocha.git"
      },
      bugs: {
        url: "https://github.com/mochajs/mocha/issues/"
      },
      funding: {
        type: "opencollective",
        url: "https://opencollective.com/mochajs"
      },
      gitter: "https://gitter.im/mochajs/mocha",
      homepage: "https://mochajs.org/",
      logo: "https://cldup.com/S9uQ-cOLYz.svg",
      notifyLogo: "https://ibin.co/4QuRuGjXvl36.png",
      bin: {
        mocha: "./bin/mocha.js",
        _mocha: "./bin/_mocha"
      },
      directories: {
        lib: "./lib",
        test: "./test"
      },
      engines: {
        node: ">= 14.0.0"
      },
      scripts: {
        prepublishOnly: "nps test clean build",
        start: "nps",
        test: "nps test",
        version: "nps version",
        "test:smoke": "node ./bin/mocha --no-config test/smoke/smoke.spec.js"
      },
      dependencies: {
        "ansi-colors": "4.1.1",
        "browser-stdout": "1.3.1",
        chokidar: "3.5.3",
        debug: "4.3.4",
        diff: "5.0.0",
        "escape-string-regexp": "4.0.0",
        "find-up": "5.0.0",
        glob: "7.2.0",
        he: "1.2.0",
        "js-yaml": "4.1.0",
        "log-symbols": "4.1.0",
        minimatch: "5.0.1",
        ms: "2.1.3",
        nanoid: "3.3.3",
        "serialize-javascript": "6.0.0",
        "strip-json-comments": "3.1.1",
        "supports-color": "8.1.1",
        workerpool: "6.2.1",
        yargs: "16.2.0",
        "yargs-parser": "20.2.4",
        "yargs-unparser": "2.0.0"
      },
      devDependencies: {
        "@11ty/eleventy": "^1.0.0",
        "@11ty/eleventy-plugin-inclusive-language": "^1.0.3",
        "@babel/eslint-parser": "^7.19.1",
        "@mocha/docdash": "^4.0.1",
        "@rollup/plugin-commonjs": "^21.0.2",
        "@rollup/plugin-json": "^4.1.0",
        "@rollup/plugin-multi-entry": "^4.0.1",
        "@rollup/plugin-node-resolve": "^13.1.3",
        "assetgraph-builder": "^9.0.0",
        autoprefixer: "^9.8.6",
        canvas: "^2.9.0",
        chai: "^4.3.4",
        coffeescript: "^2.6.1",
        coveralls: "^3.1.1",
        "cross-env": "^7.0.2",
        eslint: "^8.24.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-config-semistandard": "^17.0.0",
        "eslint-config-standard": "^17.0.0",
        "eslint-plugin-import": "^2.24.2",
        "eslint-plugin-node": "^11.1.0",
        "eslint-plugin-prettier": "^4.2.1",
        "eslint-plugin-promise": "^6.0.1",
        "fail-on-errors-webpack-plugin": "^3.0.0",
        "fs-extra": "^10.0.0",
        husky: "^4.2.5",
        hyperlink: "^5.0.4",
        jsdoc: "^3.6.7",
        "jsdoc-ts-utils": "^2.0.1",
        karma: "^6.3.11",
        "karma-chrome-launcher": "^3.1.0",
        "karma-mocha": "^2.0.1",
        "karma-mocha-reporter": "^2.2.5",
        "karma-sauce-launcher": "^4.3.6",
        "lint-staged": "^10.2.11",
        "markdown-it": "^12.3.2",
        "markdown-it-anchor": "^8.4.1",
        "markdown-it-attrs": "^4.1.3",
        "markdown-it-emoji": "^2.0.0",
        "markdown-it-prism": "^2.2.2",
        "markdown-toc": "^1.2.0",
        "markdownlint-cli": "^0.30.0",
        needle: "^2.5.0",
        nps: "^5.10.0",
        nyc: "^15.1.0",
        pidtree: "^0.5.0",
        prettier: "^2.4.1",
        remark: "^14.0.2",
        "remark-github": "^11.2.2",
        "remark-inline-links": "^6.0.1",
        rewiremock: "^3.14.3",
        rimraf: "^3.0.2",
        rollup: "^2.70.1",
        "rollup-plugin-node-globals": "^1.4.0",
        "rollup-plugin-polyfill-node": "^0.8.0",
        "rollup-plugin-visualizer": "^5.6.0",
        sinon: "^9.0.3",
        "strip-ansi": "^6.0.0",
        svgo: "^1.3.2",
        touch: "^3.1.0",
        unexpected: "^11.14.0",
        "unexpected-eventemitter": "^2.2.0",
        "unexpected-map": "^2.0.0",
        "unexpected-set": "^3.0.0",
        "unexpected-sinon": "^10.11.2",
        "update-notifier": "^4.1.0",
        uslug: "^1.0.4",
        uuid: "^8.3.0",
        webpack: "^5.67.0",
        "webpack-cli": "^4.9.1"
      },
      files: [
        "bin/*mocha*",
        "lib/**/*.{js,html,json}",
        "index.js",
        "mocha.css",
        "mocha.js",
        "mocha.js.map",
        "browser-entry.js"
      ],
      browser: {
        "./index.js": "./browser-entry.js",
        fs: false,
        path: false,
        "supports-color": false,
        "./lib/nodejs/buffered-worker-pool.js": false,
        "./lib/nodejs/esm-utils.js": false,
        "./lib/nodejs/file-unloader.js": false,
        "./lib/nodejs/parallel-buffered-runner.js": false,
        "./lib/nodejs/serializer.js": false,
        "./lib/nodejs/worker.js": false,
        "./lib/nodejs/reporters/parallel-buffered.js": false,
        "./lib/cli/index.js": false
      },
      prettier: {
        arrowParens: "avoid",
        bracketSpacing: false,
        endOfLine: "auto",
        singleQuote: true,
        trailingComma: "none"
      },
      husky: {
        hooks: {
          "pre-commit": "lint-staged"
        }
      }
    };
  }
});

// (disabled):node_modules/mocha/lib/nodejs/parallel-buffered-runner
var require_parallel_buffered_runner = __commonJS({
  "(disabled):node_modules/mocha/lib/nodejs/parallel-buffered-runner"() {
    init_shim();
  }
});

// node_modules/mocha/lib/mocha.js
var require_mocha = __commonJS({
  "node_modules/mocha/lib/mocha.js"(exports, module) {
    "use strict";
    init_shim();
    var escapeRe = require_escape_string_regexp();
    var path = require_path_browserify();
    var builtinReporters = require_reporters();
    var utils = require_utils();
    var mocharc = require_mocharc();
    var Suite = require_suite();
    var esmUtils = require_esm_utils();
    var createStatsCollector = require_stats_collector();
    var {
      createInvalidReporterError,
      createInvalidInterfaceError,
      createMochaInstanceAlreadyDisposedError,
      createMochaInstanceAlreadyRunningError,
      createUnsupportedError
    } = require_errors();
    var { EVENT_FILE_PRE_REQUIRE, EVENT_FILE_POST_REQUIRE, EVENT_FILE_REQUIRE } = Suite.constants;
    var debug = require_browser3()("mocha:mocha");
    exports = module.exports = Mocha;
    var mochaStates = utils.defineConstants({
      /**
       * Initial state of the mocha instance
       * @private
       */
      INIT: "init",
      /**
       * Mocha instance is running tests
       * @private
       */
      RUNNING: "running",
      /**
       * Mocha instance is done running tests and references to test functions and hooks are cleaned.
       * You can reset this state by unloading the test files.
       * @private
       */
      REFERENCES_CLEANED: "referencesCleaned",
      /**
       * Mocha instance is disposed and can no longer be used.
       * @private
       */
      DISPOSED: "disposed"
    });
    if (!utils.isBrowser() && typeof module.paths !== "undefined") {
      cwd = utils.cwd();
      module.paths.push(cwd, path.join(cwd, "node_modules"));
    }
    var cwd;
    exports.utils = utils;
    exports.interfaces = require_interfaces();
    exports.reporters = builtinReporters;
    exports.Runnable = require_runnable();
    exports.Context = require_context();
    exports.Runner = require_runner();
    exports.Suite = Suite;
    exports.Hook = require_hook();
    exports.Test = require_test();
    var currentContext;
    exports.afterEach = function(...args) {
      return (currentContext.afterEach || currentContext.teardown).apply(
        this,
        args
      );
    };
    exports.after = function(...args) {
      return (currentContext.after || currentContext.suiteTeardown).apply(
        this,
        args
      );
    };
    exports.beforeEach = function(...args) {
      return (currentContext.beforeEach || currentContext.setup).apply(this, args);
    };
    exports.before = function(...args) {
      return (currentContext.before || currentContext.suiteSetup).apply(this, args);
    };
    exports.describe = function(...args) {
      return (currentContext.describe || currentContext.suite).apply(this, args);
    };
    exports.describe.only = function(...args) {
      return (currentContext.describe || currentContext.suite).only.apply(
        this,
        args
      );
    };
    exports.describe.skip = function(...args) {
      return (currentContext.describe || currentContext.suite).skip.apply(
        this,
        args
      );
    };
    exports.it = function(...args) {
      return (currentContext.it || currentContext.test).apply(this, args);
    };
    exports.it.only = function(...args) {
      return (currentContext.it || currentContext.test).only.apply(this, args);
    };
    exports.it.skip = function(...args) {
      return (currentContext.it || currentContext.test).skip.apply(this, args);
    };
    exports.xdescribe = exports.describe.skip;
    exports.xit = exports.it.skip;
    exports.setup = exports.beforeEach;
    exports.suiteSetup = exports.before;
    exports.suiteTeardown = exports.after;
    exports.suite = exports.describe;
    exports.teardown = exports.afterEach;
    exports.test = exports.it;
    exports.run = function(...args) {
      return currentContext.run.apply(this, args);
    };
    function Mocha(options = {}) {
      options = { ...mocharc, ...options };
      this.files = [];
      this.options = options;
      this.suite = new exports.Suite("", new exports.Context(), true);
      this._cleanReferencesAfterRun = true;
      this._state = mochaStates.INIT;
      this.grep(options.grep).fgrep(options.fgrep).ui(options.ui).reporter(
        options.reporter,
        options.reporterOption || options.reporterOptions
        // for backwards compatibility
      ).slow(options.slow).global(options.global);
      if (typeof options.timeout !== "undefined") {
        this.timeout(options.timeout === false ? 0 : options.timeout);
      }
      if ("retries" in options) {
        this.retries(options.retries);
      }
      [
        "allowUncaught",
        "asyncOnly",
        "bail",
        "checkLeaks",
        "color",
        "delay",
        "diff",
        "dryRun",
        "failZero",
        "forbidOnly",
        "forbidPending",
        "fullTrace",
        "inlineDiffs",
        "invert"
      ].forEach(function(opt) {
        if (options[opt]) {
          this[opt]();
        }
      }, this);
      if (options.rootHooks) {
        this.rootHooks(options.rootHooks);
      }
      this._runnerClass = exports.Runner;
      this._lazyLoadFiles = false;
      this.isWorker = Boolean(options.isWorker);
      this.globalSetup(options.globalSetup).globalTeardown(options.globalTeardown).enableGlobalSetup(options.enableGlobalSetup).enableGlobalTeardown(options.enableGlobalTeardown);
      if (options.parallel && (typeof options.jobs === "undefined" || options.jobs > 1)) {
        debug("attempting to enable parallel mode");
        this.parallelMode(true);
      }
    }
    Mocha.prototype.bail = function(bail) {
      this.suite.bail(bail !== false);
      return this;
    };
    Mocha.prototype.addFile = function(file) {
      this.files.push(file);
      return this;
    };
    Mocha.prototype.reporter = function(reporterName, reporterOptions) {
      if (typeof reporterName === "function") {
        this._reporter = reporterName;
      } else {
        reporterName = reporterName || "spec";
        var reporter;
        if (builtinReporters[reporterName]) {
          reporter = builtinReporters[reporterName];
        }
        if (!reporter) {
          let foundReporter;
          try {
            foundReporter = __require.resolve(reporterName);
            reporter = __require(foundReporter);
          } catch (err) {
            if (foundReporter) {
              throw createInvalidReporterError(err.message, foundReporter);
            }
            try {
              reporter = __require(path.resolve(reporterName));
            } catch (e) {
              throw createInvalidReporterError(e.message, reporterName);
            }
          }
        }
        this._reporter = reporter;
      }
      this.options.reporterOption = reporterOptions;
      this.options.reporterOptions = reporterOptions;
      return this;
    };
    Mocha.prototype.ui = function(ui) {
      var bindInterface;
      if (typeof ui === "function") {
        bindInterface = ui;
      } else {
        ui = ui || "bdd";
        bindInterface = exports.interfaces[ui];
        if (!bindInterface) {
          try {
            bindInterface = __require(ui);
          } catch (err) {
            throw createInvalidInterfaceError(`invalid interface '${ui}'`, ui);
          }
        }
      }
      bindInterface(this.suite);
      this.suite.on(EVENT_FILE_PRE_REQUIRE, function(context) {
        currentContext = context;
      });
      return this;
    };
    Mocha.prototype.loadFiles = function(fn) {
      var self2 = this;
      var suite = this.suite;
      this.files.forEach(function(file) {
        file = path.resolve(file);
        suite.emit(EVENT_FILE_PRE_REQUIRE, _global, file, self2);
        suite.emit(EVENT_FILE_REQUIRE, __require(file), file, self2);
        suite.emit(EVENT_FILE_POST_REQUIRE, _global, file, self2);
      });
      fn && fn();
    };
    Mocha.prototype.loadFilesAsync = function({ esmDecorator } = {}) {
      var self2 = this;
      var suite = this.suite;
      this.lazyLoadFiles(true);
      return esmUtils.loadFilesAsync(
        this.files,
        function(file) {
          suite.emit(EVENT_FILE_PRE_REQUIRE, _global, file, self2);
        },
        function(file, resultModule) {
          suite.emit(EVENT_FILE_REQUIRE, resultModule, file, self2);
          suite.emit(EVENT_FILE_POST_REQUIRE, _global, file, self2);
        },
        esmDecorator
      );
    };
    Mocha.unloadFile = function(file) {
      if (utils.isBrowser()) {
        throw createUnsupportedError(
          "unloadFile() is only supported in a Node.js environment"
        );
      }
      return require_file_unloader().unloadFile(file);
    };
    Mocha.prototype.unloadFiles = function() {
      if (this._state === mochaStates.DISPOSED) {
        throw createMochaInstanceAlreadyDisposedError(
          "Mocha instance is already disposed, it cannot be used again.",
          this._cleanReferencesAfterRun,
          this
        );
      }
      this.files.forEach(function(file) {
        Mocha.unloadFile(file);
      });
      this._state = mochaStates.INIT;
      return this;
    };
    Mocha.prototype.fgrep = function(str) {
      if (!str) {
        return this;
      }
      return this.grep(new RegExp(escapeRe(str)));
    };
    Mocha.prototype.grep = function(re) {
      if (utils.isString(re)) {
        var arg = re.match(/^\/(.*)\/([gimy]{0,4})$|.*/);
        this.options.grep = new RegExp(arg[1] || arg[0], arg[2]);
      } else {
        this.options.grep = re;
      }
      return this;
    };
    Mocha.prototype.invert = function() {
      this.options.invert = true;
      return this;
    };
    Mocha.prototype.checkLeaks = function(checkLeaks) {
      this.options.checkLeaks = checkLeaks !== false;
      return this;
    };
    Mocha.prototype.cleanReferencesAfterRun = function(cleanReferencesAfterRun) {
      this._cleanReferencesAfterRun = cleanReferencesAfterRun !== false;
      return this;
    };
    Mocha.prototype.dispose = function() {
      if (this._state === mochaStates.RUNNING) {
        throw createMochaInstanceAlreadyRunningError(
          "Cannot dispose while the mocha instance is still running tests."
        );
      }
      this.unloadFiles();
      this._previousRunner && this._previousRunner.dispose();
      this.suite.dispose();
      this._state = mochaStates.DISPOSED;
    };
    Mocha.prototype.fullTrace = function(fullTrace) {
      this.options.fullTrace = fullTrace !== false;
      return this;
    };
    Mocha.prototype.global = function(global) {
      this.options.global = (this.options.global || []).concat(global).filter(Boolean).filter(function(elt, idx, arr) {
        return arr.indexOf(elt) === idx;
      });
      return this;
    };
    Mocha.prototype.globals = Mocha.prototype.global;
    Mocha.prototype.color = function(color) {
      this.options.color = color !== false;
      return this;
    };
    Mocha.prototype.inlineDiffs = function(inlineDiffs) {
      this.options.inlineDiffs = inlineDiffs !== false;
      return this;
    };
    Mocha.prototype.diff = function(diff) {
      this.options.diff = diff !== false;
      return this;
    };
    Mocha.prototype.timeout = function(msecs) {
      this.suite.timeout(msecs);
      return this;
    };
    Mocha.prototype.retries = function(retry) {
      this.suite.retries(retry);
      return this;
    };
    Mocha.prototype.slow = function(msecs) {
      this.suite.slow(msecs);
      return this;
    };
    Mocha.prototype.asyncOnly = function(asyncOnly) {
      this.options.asyncOnly = asyncOnly !== false;
      return this;
    };
    Mocha.prototype.noHighlighting = function() {
      this.options.noHighlighting = true;
      return this;
    };
    Mocha.prototype.allowUncaught = function(allowUncaught) {
      this.options.allowUncaught = allowUncaught !== false;
      return this;
    };
    Mocha.prototype.delay = function delay() {
      this.options.delay = true;
      return this;
    };
    Mocha.prototype.dryRun = function(dryRun) {
      this.options.dryRun = dryRun !== false;
      return this;
    };
    Mocha.prototype.failZero = function(failZero) {
      this.options.failZero = failZero !== false;
      return this;
    };
    Mocha.prototype.forbidOnly = function(forbidOnly) {
      this.options.forbidOnly = forbidOnly !== false;
      return this;
    };
    Mocha.prototype.forbidPending = function(forbidPending) {
      this.options.forbidPending = forbidPending !== false;
      return this;
    };
    Mocha.prototype._guardRunningStateTransition = function() {
      if (this._state === mochaStates.RUNNING) {
        throw createMochaInstanceAlreadyRunningError(
          "Mocha instance is currently running tests, cannot start a next test run until this one is done",
          this
        );
      }
      if (this._state === mochaStates.DISPOSED || this._state === mochaStates.REFERENCES_CLEANED) {
        throw createMochaInstanceAlreadyDisposedError(
          "Mocha instance is already disposed, cannot start a new test run. Please create a new mocha instance. Be sure to set disable `cleanReferencesAfterRun` when you want to reuse the same mocha instance for multiple test runs.",
          this._cleanReferencesAfterRun,
          this
        );
      }
    };
    Object.defineProperty(Mocha.prototype, "version", {
      value: require_package().version,
      configurable: false,
      enumerable: true,
      writable: false
    });
    Mocha.prototype.run = function(fn) {
      this._guardRunningStateTransition();
      this._state = mochaStates.RUNNING;
      if (this._previousRunner) {
        this._previousRunner.dispose();
        this.suite.reset();
      }
      if (this.files.length && !this._lazyLoadFiles) {
        this.loadFiles();
      }
      var suite = this.suite;
      var options = this.options;
      options.files = this.files;
      const runner = new this._runnerClass(suite, {
        cleanReferencesAfterRun: this._cleanReferencesAfterRun,
        delay: options.delay,
        dryRun: options.dryRun,
        failZero: options.failZero
      });
      createStatsCollector(runner);
      var reporter = new this._reporter(runner, options);
      runner.checkLeaks = options.checkLeaks === true;
      runner.fullStackTrace = options.fullTrace;
      runner.asyncOnly = options.asyncOnly;
      runner.allowUncaught = options.allowUncaught;
      runner.forbidOnly = options.forbidOnly;
      runner.forbidPending = options.forbidPending;
      if (options.grep) {
        runner.grep(options.grep, options.invert);
      }
      if (options.global) {
        runner.globals(options.global);
      }
      if (options.color !== void 0) {
        exports.reporters.Base.useColors = options.color;
      }
      exports.reporters.Base.inlineDiffs = options.inlineDiffs;
      exports.reporters.Base.hideDiff = !options.diff;
      const done = (failures) => {
        this._previousRunner = runner;
        this._state = this._cleanReferencesAfterRun ? mochaStates.REFERENCES_CLEANED : mochaStates.INIT;
        fn = fn || utils.noop;
        if (typeof reporter.done === "function") {
          reporter.done(failures, fn);
        } else {
          fn(failures);
        }
      };
      const runAsync = async (runner2) => {
        const context = this.options.enableGlobalSetup && this.hasGlobalSetupFixtures() ? await this.runGlobalSetup(runner2) : {};
        const failureCount = await runner2.runAsync({
          files: this.files,
          options
        });
        if (this.options.enableGlobalTeardown && this.hasGlobalTeardownFixtures()) {
          await this.runGlobalTeardown(runner2, { context });
        }
        return failureCount;
      };
      runAsync(runner).then(done);
      return runner;
    };
    Mocha.prototype.rootHooks = function rootHooks({
      beforeAll = [],
      beforeEach = [],
      afterAll = [],
      afterEach = []
    } = {}) {
      beforeAll = utils.castArray(beforeAll);
      beforeEach = utils.castArray(beforeEach);
      afterAll = utils.castArray(afterAll);
      afterEach = utils.castArray(afterEach);
      beforeAll.forEach((hook) => {
        this.suite.beforeAll(hook);
      });
      beforeEach.forEach((hook) => {
        this.suite.beforeEach(hook);
      });
      afterAll.forEach((hook) => {
        this.suite.afterAll(hook);
      });
      afterEach.forEach((hook) => {
        this.suite.afterEach(hook);
      });
      return this;
    };
    Mocha.prototype.parallelMode = function parallelMode(enable = true) {
      if (utils.isBrowser()) {
        throw createUnsupportedError("parallel mode is only supported in Node.js");
      }
      const parallel = Boolean(enable);
      if (parallel === this.options.parallel && this._lazyLoadFiles && this._runnerClass !== exports.Runner) {
        return this;
      }
      if (this._state !== mochaStates.INIT) {
        throw createUnsupportedError(
          "cannot change parallel mode after having called run()"
        );
      }
      this.options.parallel = parallel;
      this._runnerClass = parallel ? require_parallel_buffered_runner() : exports.Runner;
      return this.lazyLoadFiles(this._lazyLoadFiles || parallel);
    };
    Mocha.prototype.lazyLoadFiles = function lazyLoadFiles(enable) {
      this._lazyLoadFiles = enable === true;
      debug("set lazy load to %s", enable);
      return this;
    };
    Mocha.prototype.globalSetup = function globalSetup(setupFns = []) {
      setupFns = utils.castArray(setupFns);
      this.options.globalSetup = setupFns;
      debug("configured %d global setup functions", setupFns.length);
      return this;
    };
    Mocha.prototype.globalTeardown = function globalTeardown(teardownFns = []) {
      teardownFns = utils.castArray(teardownFns);
      this.options.globalTeardown = teardownFns;
      debug("configured %d global teardown functions", teardownFns.length);
      return this;
    };
    Mocha.prototype.runGlobalSetup = async function runGlobalSetup(context = {}) {
      const { globalSetup } = this.options;
      if (globalSetup && globalSetup.length) {
        debug("run(): global setup starting");
        await this._runGlobalFixtures(globalSetup, context);
        debug("run(): global setup complete");
      }
      return context;
    };
    Mocha.prototype.runGlobalTeardown = async function runGlobalTeardown(context = {}) {
      const { globalTeardown } = this.options;
      if (globalTeardown && globalTeardown.length) {
        debug("run(): global teardown starting");
        await this._runGlobalFixtures(globalTeardown, context);
      }
      debug("run(): global teardown complete");
      return context;
    };
    Mocha.prototype._runGlobalFixtures = async function _runGlobalFixtures(fixtureFns = [], context = {}) {
      for await (const fixtureFn of fixtureFns) {
        await fixtureFn.call(context);
      }
      return context;
    };
    Mocha.prototype.enableGlobalSetup = function enableGlobalSetup(enabled = true) {
      this.options.enableGlobalSetup = Boolean(enabled);
      return this;
    };
    Mocha.prototype.enableGlobalTeardown = function enableGlobalTeardown(enabled = true) {
      this.options.enableGlobalTeardown = Boolean(enabled);
      return this;
    };
    Mocha.prototype.hasGlobalSetupFixtures = function hasGlobalSetupFixtures() {
      return Boolean(this.options.globalSetup.length);
    };
    Mocha.prototype.hasGlobalTeardownFixtures = function hasGlobalTeardownFixtures() {
      return Boolean(this.options.globalTeardown.length);
    };
  }
});

// node_modules/mocha/browser-entry.js
var require_browser_entry = __commonJS({
  "node_modules/mocha/browser-entry.js"(exports, module) {
    init_shim();
    import_process.default.stdout = require_browser_stdout()({ label: false });
    var parseQuery = require_parse_query();
    var highlightTags = require_highlight_tags();
    var Mocha = require_mocha();
    var mocha = new Mocha({ reporter: "html" });
    var Date2 = _global.Date;
    var setTimeout2 = _global.setTimeout;
    var setInterval = _global.setInterval;
    var clearTimeout = _global.clearTimeout;
    var clearInterval = _global.clearInterval;
    var uncaughtExceptionHandlers = [];
    var originalOnerrorHandler = _global.onerror;
    import_process.default.removeListener = function(e, fn) {
      if (e === "uncaughtException") {
        if (originalOnerrorHandler) {
          _global.onerror = originalOnerrorHandler;
        } else {
          _global.onerror = function() {
          };
        }
        var i = uncaughtExceptionHandlers.indexOf(fn);
        if (i !== -1) {
          uncaughtExceptionHandlers.splice(i, 1);
        }
      }
    };
    import_process.default.listenerCount = function(name) {
      if (name === "uncaughtException") {
        return uncaughtExceptionHandlers.length;
      }
      return 0;
    };
    import_process.default.on = function(e, fn) {
      if (e === "uncaughtException") {
        _global.onerror = function(err, url, line) {
          fn(new Error(err + " (" + url + ":" + line + ")"));
          return !mocha.options.allowUncaught;
        };
        uncaughtExceptionHandlers.push(fn);
      }
    };
    import_process.default.listeners = function(e) {
      if (e === "uncaughtException") {
        return uncaughtExceptionHandlers;
      }
      return [];
    };
    mocha.suite.removeAllListeners("pre-require");
    var immediateQueue = [];
    var immediateTimeout;
    function timeslice() {
      var immediateStart = new Date2().getTime();
      while (immediateQueue.length && new Date2().getTime() - immediateStart < 100) {
        immediateQueue.shift()();
      }
      if (immediateQueue.length) {
        immediateTimeout = setTimeout2(timeslice, 0);
      } else {
        immediateTimeout = null;
      }
    }
    Mocha.Runner.immediately = function(callback) {
      immediateQueue.push(callback);
      if (!immediateTimeout) {
        immediateTimeout = setTimeout2(timeslice, 0);
      }
    };
    mocha.throwError = function(err) {
      uncaughtExceptionHandlers.forEach(function(fn) {
        fn(err);
      });
      throw err;
    };
    mocha.ui = function(ui) {
      Mocha.prototype.ui.call(this, ui);
      this.suite.emit("pre-require", _global, null, this);
      return this;
    };
    mocha.setup = function(opts) {
      if (typeof opts === "string") {
        opts = { ui: opts };
      }
      if (opts.delay === true) {
        this.delay();
      }
      var self2 = this;
      Object.keys(opts).filter(function(opt) {
        return opt !== "delay";
      }).forEach(function(opt) {
        if (Object.prototype.hasOwnProperty.call(opts, opt)) {
          self2[opt](opts[opt]);
        }
      });
      return this;
    };
    mocha.run = function(fn) {
      var options = mocha.options;
      mocha.globals("location");
      var query = parseQuery(_global.location.search || "");
      if (query.grep) {
        mocha.grep(query.grep);
      }
      if (query.fgrep) {
        mocha.fgrep(query.fgrep);
      }
      if (query.invert) {
        mocha.invert();
      }
      return Mocha.prototype.run.call(mocha, function(err) {
        var document2 = _global.document;
        if (document2 && document2.getElementById("mocha") && options.noHighlighting !== true) {
          highlightTags("code");
        }
        if (fn) {
          fn(err);
        }
      });
    };
    Mocha.process = import_process.default;
    _global.Mocha = Mocha;
    _global.mocha = mocha;
    [
      "describe",
      "context",
      "it",
      "specify",
      "xdescribe",
      "xcontext",
      "xit",
      "xspecify",
      "before",
      "beforeEach",
      "afterEach",
      "after"
    ].forEach(function(key) {
      mocha[key] = _global[key];
    });
    module.exports = mocha;
  }
});
export default require_browser_entry();
/*! Bundled license information:

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

he/he.js:
  (*! https://mths.be/he v1.2.0 by @mathias | MIT license *)

mocha/lib/mocha.js:
  (*!
   * mocha
   * Copyright(c) 2011 TJ Holowaychuk <tj@vision-media.ca>
   * MIT Licensed
   *)
*/
//# sourceMappingURL=mocha.js.map
