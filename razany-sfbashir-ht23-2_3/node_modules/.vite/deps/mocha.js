import {
  require_inherits_browser,
  require_util
} from "./chunk-TF4JMVY6.js";
import "./chunk-T33LG35T.js";
import {
  __commonJS,
  __esm,
  __export,
  __require,
  __toCommonJS,
  _global,
  import_buffer,
  import_process,
  init_shim,
  require_buffer
} from "./chunk-ERV56XPB.js";

// node_modules/events/events.js
var require_events = __commonJS({
  "node_modules/events/events.js"(exports, module) {
    "use strict";
    init_shim();
    var R = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R && typeof R.ownKeys === "function") {
      ReflectOwnKeys = R.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn)
        console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter() {
      EventEmitter.init.call(this);
    }
    module.exports = EventEmitter;
    module.exports.once = once;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._eventsCount = 0;
    EventEmitter.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
      }
      this._maxListeners = n;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter.prototype.emit = function emit(type) {
      var args = [];
      for (var i = 1; i < arguments.length; i++)
        args.push(arguments[i]);
      var doError = type === "error";
      var events = this._events;
      if (events !== void 0)
        doError = doError && events.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          ReflectApply(listeners[i], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m;
      var events;
      var existing;
      checkListener(listener);
      events = target._events;
      if (events === void 0) {
        events = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events = target._events;
        }
        existing = events[type];
      }
      if (existing === void 0) {
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          ProcessEmitWarning(w);
        }
      }
      return target;
    }
    EventEmitter.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.removeListener = function removeListener(type, listener) {
      var list, events, position, i, originalListener;
      checkListener(listener);
      events = this._events;
      if (events === void 0)
        return this;
      list = events[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events[type] = list[0];
        if (events.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events, i;
      events = this._events;
      if (events === void 0)
        return this;
      if (events.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === "removeListener")
            continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap) {
      var events = target._events;
      if (events === void 0)
        return [];
      var evlistener = events[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;
      if (events !== void 0) {
        var evlistener = events[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n) {
      var copy = new Array(n);
      for (var i = 0; i < n; ++i)
        copy[i] = arr[i];
      return copy;
    }
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }
    function once(emitter, name) {
      return new Promise(function(resolve, reject) {
        function errorListener(err) {
          emitter.removeListener(name, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
        if (name !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name, listener);
        } else {
          emitter.on(name, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/stream-browser.js
var require_stream_browser = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports, module) {
    init_shim();
    module.exports = require_events().EventEmitter;
  }
});

// node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module) {
    "use strict";
    init_shim();
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var _require = require_buffer();
    var Buffer2 = _require.Buffer;
    var _require2 = require_util();
    var inspect = _require2.inspect;
    var custom = inspect && inspect.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer2.prototype.copy.call(src, target, offset);
    }
    module.exports = function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList, [{
        key: "push",
        value: function push(v) {
          var entry = {
            data: v,
            next: null
          };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v) {
          var entry = {
            data: v,
            next: this.head
          };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0)
            return;
          var ret = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join(s) {
          if (this.length === 0)
            return "";
          var p = this.head;
          var ret = "" + p.data;
          while (p = p.next)
            ret += s + p.data;
          return ret;
        }
      }, {
        key: "concat",
        value: function concat(n) {
          if (this.length === 0)
            return Buffer2.alloc(0);
          var ret = Buffer2.allocUnsafe(n >>> 0);
          var p = this.head;
          var i = 0;
          while (p) {
            copyBuffer(p.data, ret, i);
            i += p.data.length;
            p = p.next;
          }
          return ret;
        }
        // Consumes a specified amount of bytes or characters from the buffered data.
      }, {
        key: "consume",
        value: function consume(n, hasStrings) {
          var ret;
          if (n < this.head.data.length) {
            ret = this.head.data.slice(0, n);
            this.head.data = this.head.data.slice(n);
          } else if (n === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n) : this._getBuffer(n);
          }
          return ret;
        }
      }, {
        key: "first",
        value: function first() {
          return this.head.data;
        }
        // Consumes a specified amount of characters from the buffered data.
      }, {
        key: "_getString",
        value: function _getString(n) {
          var p = this.head;
          var c = 1;
          var ret = p.data;
          n -= ret.length;
          while (p = p.next) {
            var str = p.data;
            var nb = n > str.length ? str.length : n;
            if (nb === str.length)
              ret += str;
            else
              ret += str.slice(0, n);
            n -= nb;
            if (n === 0) {
              if (nb === str.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = str.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        // Consumes a specified amount of bytes from the buffered data.
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n) {
          var ret = Buffer2.allocUnsafe(n);
          var p = this.head;
          var c = 1;
          p.data.copy(ret);
          n -= p.data.length;
          while (p = p.next) {
            var buf = p.data;
            var nb = n > buf.length ? buf.length : n;
            buf.copy(ret, ret.length - n, 0, nb);
            n -= nb;
            if (n === 0) {
              if (nb === buf.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = buf.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        // Make sure the linked list only shows the minimal necessary information.
      }, {
        key: custom,
        value: function value(_, options) {
          return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        }
      }]);
      return BufferList;
    }();
  }
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
    "use strict";
    init_shim();
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            import_process.default.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            import_process.default.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            import_process.default.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            import_process.default.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            import_process.default.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          import_process.default.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          import_process.default.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose)
        return;
      if (self2._readableState && !self2._readableState.emitClose)
        return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy)
        stream.destroy(err);
      else
        stream.emit("error", err);
    }
    module.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// node_modules/readable-stream/errors-browser.js
var require_errors_browser = __commonJS({
  "node_modules/readable-stream/errors-browser.js"(exports, module) {
    "use strict";
    init_shim();
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    var codes = {};
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      var NodeError = function(_Base) {
        _inheritsLoose(NodeError2, _Base);
        function NodeError2(arg1, arg2, arg3) {
          return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
        }
        return NodeError2;
      }(Base);
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        var len = expected.length;
        expected = expected.map(function(i) {
          return String(i);
        });
        if (len > 2) {
          return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
        } else if (len === 2) {
          return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        } else {
          return "of ".concat(thing, " ").concat(expected[0]);
        }
      } else {
        return "of ".concat(thing, " ").concat(String(expected));
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      var determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      var msg;
      if (endsWith(name, " argument")) {
        msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      } else {
        var type = includes(name, ".") ? "property" : "argument";
        msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      }
      msg += ". Received type ".concat(typeof actual);
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
      return "The " + name + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name) {
      return "Cannot call " + name + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module.exports.codes = codes;
  }
});

// node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/state.js"(exports, module) {
    "use strict";
    init_shim();
    var ERR_INVALID_OPT_VALUE = require_errors_browser().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module.exports = {
      getHighWaterMark
    };
  }
});

// node_modules/util-deprecate/browser.js
var require_browser = __commonJS({
  "node_modules/util-deprecate/browser.js"(exports, module) {
    init_shim();
    module.exports = deprecate;
    function deprecate(fn, msg) {
      if (config("noDeprecation")) {
        return fn;
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (config("throwDeprecation")) {
            throw new Error(msg);
          } else if (config("traceDeprecation")) {
            console.trace(msg);
          } else {
            console.warn(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    }
    function config(name) {
      try {
        if (!_global.localStorage)
          return false;
      } catch (_) {
        return false;
      }
      var val = _global.localStorage[name];
      if (null == val)
        return false;
      return String(val).toLowerCase() === "true";
    }
  }
});

// node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/readable-stream/lib/_stream_writable.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex;
    Writable.WritableState = WritableState;
    var internalUtil = {
      deprecate: require_browser()
    };
    var Stream = require_stream_browser();
    var Buffer2 = require_buffer().Buffer;
    var OurUint8Array = (typeof _global !== "undefined" ? _global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits_browser()(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex();
      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this))
        return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er);
      import_process.default.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream, er);
        import_process.default.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ending)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        import_process.default.nextTick(cb, er);
        import_process.default.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function")
        throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          import_process.default.nextTick(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          import_process.default.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
          if (state.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          import_process.default.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/readable-stream/lib/_stream_duplex.js"(exports, module) {
    "use strict";
    init_shim();
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj)
        keys2.push(key);
      return keys2;
    };
    module.exports = Duplex;
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    require_inherits_browser()(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false)
          this.readable = false;
        if (options.writable === false)
          this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended)
        return;
      import_process.default.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports, module) {
    init_shim();
    var buffer = require_buffer();
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "node_modules/string_decoder/lib/string_decoder.js"(exports) {
    "use strict";
    init_shim();
    var Buffer2 = require_safe_buffer().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0)
          return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length)
        return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed)
        return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0)
        return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module) {
    "use strict";
    init_shim();
    var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once(callback || noop);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable)
          onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable)
          callback.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable)
          callback.call(stream);
      };
      var onerror = function onerror2(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    module.exports = eos;
  }
});

// node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports, module) {
    "use strict";
    init_shim();
    var _Object$setPrototypeO;
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var finished = require_end_of_stream();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done) {
      return {
        value,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve = iter[kLastResolve];
      if (resolve !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve(createIterResult(data, false));
        }
      }
    }
    function onReadable(iter) {
      import_process.default.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve, reject) {
            import_process.default.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve, reject) {
          var data = iterator[kStream].read();
          if (data) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(data, false));
          } else {
            iterator[kLastResolve] = resolve;
            iterator[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator[kLastReject];
          if (reject !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject(err);
          }
          iterator[kError] = err;
          return;
        }
        var resolve = iterator[kLastResolve];
        if (resolve !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator));
      return iterator;
    };
    module.exports = createReadableStreamAsyncIterator;
  }
});

// node_modules/readable-stream/lib/internal/streams/from-browser.js
var require_from_browser = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports, module) {
    init_shim();
    module.exports = function() {
      throw new Error("Readable.from is not available in the browser");
    };
  }
});

// node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/readable-stream/lib/_stream_readable.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = Readable;
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require_events().EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream_browser();
    var Buffer2 = require_buffer().Buffer;
    var OurUint8Array = (typeof _global !== "undefined" ? _global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = require_util();
    var debug;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function debug2() {
      };
    }
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from;
    require_inherits_browser()(Readable, Stream);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable))
        return new Readable(options);
      var isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          errorOrDestroy(stream, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p = this._readableState.buffer.head;
      var content = "";
      while (p !== null) {
        content += decoder.write(p.data);
        p = p.next;
      }
      this._readableState.buffer.clear();
      if (content !== "")
        this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        import_process.default.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      var state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        import_process.default.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== import_process.default.stdout && dest !== import_process.default.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        import_process.default.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        var ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          errorOrDestroy(dest, er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++)
          dests[i].emit("unpipe", this, {
            hasUnpiped: false
          });
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            import_process.default.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn) {
      var res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        import_process.default.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.removeAllListeners = function(ev) {
      var res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        import_process.default.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        import_process.default.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null)
        ;
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.flowing;
      },
      set: function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable._fromList = fromList;
    Object.defineProperty(Readable.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.length;
      }
    });
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.first();
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        import_process.default.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable.from = function(iterable, opts) {
        if (from === void 0) {
          from = require_from_browser();
        }
        return from(Readable, iterable, opts);
      };
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/readable-stream/lib/_stream_transform.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = Transform;
    var _require$codes = require_errors_browser().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex = require_stream_duplex();
    require_inherits_browser()(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming)
        throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
  }
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = PassThrough;
    var Transform = require_stream_transform();
    require_inherits_browser()(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module) {
    "use strict";
    init_shim();
    var eos;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = require_errors_browser().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop(err) {
      if (err)
        throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos === void 0)
        eos = require_end_of_stream();
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isRequest(stream))
          return stream.abort();
        if (typeof stream.destroy === "function")
          return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn) {
      fn();
    }
    function pipe(from, to) {
      return from.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length)
        return noop;
      if (typeof streams[streams.length - 1] !== "function")
        return noop;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error)
            error = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    }
    module.exports = pipeline;
  }
});

// node_modules/stream-browserify/index.js
var require_stream_browserify = __commonJS({
  "node_modules/stream-browserify/index.js"(exports, module) {
    init_shim();
    module.exports = Stream;
    var EE = require_events().EventEmitter;
    var inherits = require_inherits_browser();
    inherits(Stream, EE);
    Stream.Readable = require_stream_readable();
    Stream.Writable = require_stream_writable();
    Stream.Duplex = require_stream_duplex();
    Stream.Transform = require_stream_transform();
    Stream.PassThrough = require_stream_passthrough();
    Stream.finished = require_end_of_stream();
    Stream.pipeline = require_pipeline();
    Stream.Stream = Stream;
    function Stream() {
      EE.call(this);
    }
    Stream.prototype.pipe = function(dest, options) {
      var source = this;
      function ondata(chunk) {
        if (dest.writable) {
          if (false === dest.write(chunk) && source.pause) {
            source.pause();
          }
        }
      }
      source.on("data", ondata);
      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }
      dest.on("drain", ondrain);
      if (!dest._isStdio && (!options || options.end !== false)) {
        source.on("end", onend);
        source.on("close", onclose);
      }
      var didOnEnd = false;
      function onend() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        dest.end();
      }
      function onclose() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        if (typeof dest.destroy === "function")
          dest.destroy();
      }
      function onerror(er) {
        cleanup();
        if (EE.listenerCount(this, "error") === 0) {
          throw er;
        }
      }
      source.on("error", onerror);
      dest.on("error", onerror);
      function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
      }
      source.on("end", cleanup);
      source.on("close", cleanup);
      dest.on("close", cleanup);
      dest.emit("pipe", source);
      return dest;
    };
  }
});

// node_modules/browser-stdout/index.js
var require_browser_stdout = __commonJS({
  "node_modules/browser-stdout/index.js"(exports, module) {
    init_shim();
    var WritableStream = require_stream_browserify().Writable;
    var inherits = require_util().inherits;
    module.exports = BrowserStdout;
    inherits(BrowserStdout, WritableStream);
    function BrowserStdout(opts) {
      if (!(this instanceof BrowserStdout))
        return new BrowserStdout(opts);
      opts = opts || {};
      WritableStream.call(this, opts);
      this.label = opts.label !== void 0 ? opts.label : "stdout";
    }
    BrowserStdout.prototype._write = function(chunks, encoding, cb) {
      var output = chunks.toString ? chunks.toString() : chunks;
      if (this.label === false) {
        console.log(output);
      } else {
        console.log(this.label + ":", output);
      }
      import_process.default.nextTick(cb);
    };
  }
});

// node_modules/mocha/lib/browser/parse-query.js
var require_parse_query = __commonJS({
  "node_modules/mocha/lib/browser/parse-query.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = function parseQuery(qs) {
      return qs.replace("?", "").split("&").reduce(function(obj, pair) {
        var i = pair.indexOf("=");
        var key = pair.slice(0, i);
        var val = pair.slice(++i);
        obj[key] = decodeURIComponent(val.replace(/\+/g, "%20"));
        return obj;
      }, {});
    };
  }
});

// node_modules/mocha/lib/browser/highlight-tags.js
var require_highlight_tags = __commonJS({
  "node_modules/mocha/lib/browser/highlight-tags.js"(exports, module) {
    "use strict";
    init_shim();
    function highlight(js) {
      return js.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\/\/(.*)/gm, '<span class="comment">//$1</span>').replace(/('.*?')/gm, '<span class="string">$1</span>').replace(/(\d+\.\d+)/gm, '<span class="number">$1</span>').replace(/(\d+)/gm, '<span class="number">$1</span>').replace(
        /\bnew[ \t]+(\w+)/gm,
        '<span class="keyword">new</span> <span class="init">$1</span>'
      ).replace(
        /\b(function|new|throw|return|var|if|else)\b/gm,
        '<span class="keyword">$1</span>'
      );
    }
    module.exports = function highlightTags(name) {
      var code = document.getElementById("mocha").getElementsByTagName(name);
      for (var i = 0, len = code.length; i < len; ++i) {
        code[i].innerHTML = highlight(code[i].innerHTML);
      }
    };
  }
});

// node_modules/mocha/node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS({
  "node_modules/mocha/node_modules/escape-string-regexp/index.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = (string) => {
      if (typeof string !== "string") {
        throw new TypeError("Expected a string");
      }
      return string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
    };
  }
});

// node_modules/path-browserify/index.js
var require_path_browserify = __commonJS({
  "node_modules/path-browserify/index.js"(exports, module) {
    "use strict";
    init_shim();
    function assertPath(path) {
      if (typeof path !== "string") {
        throw new TypeError("Path must be a string. Received " + JSON.stringify(path));
      }
    }
    function normalizeStringPosix(path, allowAboveRoot) {
      var res = "";
      var lastSegmentLength = 0;
      var lastSlash = -1;
      var dots = 0;
      var code;
      for (var i = 0; i <= path.length; ++i) {
        if (i < path.length)
          code = path.charCodeAt(i);
        else if (code === 47)
          break;
        else
          code = 47;
        if (code === 47) {
          if (lastSlash === i - 1 || dots === 1) {
          } else if (lastSlash !== i - 1 && dots === 2) {
            if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
              if (res.length > 2) {
                var lastSlashIndex = res.lastIndexOf("/");
                if (lastSlashIndex !== res.length - 1) {
                  if (lastSlashIndex === -1) {
                    res = "";
                    lastSegmentLength = 0;
                  } else {
                    res = res.slice(0, lastSlashIndex);
                    lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                  }
                  lastSlash = i;
                  dots = 0;
                  continue;
                }
              } else if (res.length === 2 || res.length === 1) {
                res = "";
                lastSegmentLength = 0;
                lastSlash = i;
                dots = 0;
                continue;
              }
            }
            if (allowAboveRoot) {
              if (res.length > 0)
                res += "/..";
              else
                res = "..";
              lastSegmentLength = 2;
            }
          } else {
            if (res.length > 0)
              res += "/" + path.slice(lastSlash + 1, i);
            else
              res = path.slice(lastSlash + 1, i);
            lastSegmentLength = i - lastSlash - 1;
          }
          lastSlash = i;
          dots = 0;
        } else if (code === 46 && dots !== -1) {
          ++dots;
        } else {
          dots = -1;
        }
      }
      return res;
    }
    function _format(sep, pathObject) {
      var dir = pathObject.dir || pathObject.root;
      var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
      if (!dir) {
        return base;
      }
      if (dir === pathObject.root) {
        return dir + base;
      }
      return dir + sep + base;
    }
    var posix = {
      // path.resolve([from ...], to)
      resolve: function resolve() {
        var resolvedPath = "";
        var resolvedAbsolute = false;
        var cwd;
        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path;
          if (i >= 0)
            path = arguments[i];
          else {
            if (cwd === void 0)
              cwd = import_process.default.cwd();
            path = cwd;
          }
          assertPath(path);
          if (path.length === 0) {
            continue;
          }
          resolvedPath = path + "/" + resolvedPath;
          resolvedAbsolute = path.charCodeAt(0) === 47;
        }
        resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
        if (resolvedAbsolute) {
          if (resolvedPath.length > 0)
            return "/" + resolvedPath;
          else
            return "/";
        } else if (resolvedPath.length > 0) {
          return resolvedPath;
        } else {
          return ".";
        }
      },
      normalize: function normalize(path) {
        assertPath(path);
        if (path.length === 0)
          return ".";
        var isAbsolute = path.charCodeAt(0) === 47;
        var trailingSeparator = path.charCodeAt(path.length - 1) === 47;
        path = normalizeStringPosix(path, !isAbsolute);
        if (path.length === 0 && !isAbsolute)
          path = ".";
        if (path.length > 0 && trailingSeparator)
          path += "/";
        if (isAbsolute)
          return "/" + path;
        return path;
      },
      isAbsolute: function isAbsolute(path) {
        assertPath(path);
        return path.length > 0 && path.charCodeAt(0) === 47;
      },
      join: function join() {
        if (arguments.length === 0)
          return ".";
        var joined;
        for (var i = 0; i < arguments.length; ++i) {
          var arg = arguments[i];
          assertPath(arg);
          if (arg.length > 0) {
            if (joined === void 0)
              joined = arg;
            else
              joined += "/" + arg;
          }
        }
        if (joined === void 0)
          return ".";
        return posix.normalize(joined);
      },
      relative: function relative(from, to) {
        assertPath(from);
        assertPath(to);
        if (from === to)
          return "";
        from = posix.resolve(from);
        to = posix.resolve(to);
        if (from === to)
          return "";
        var fromStart = 1;
        for (; fromStart < from.length; ++fromStart) {
          if (from.charCodeAt(fromStart) !== 47)
            break;
        }
        var fromEnd = from.length;
        var fromLen = fromEnd - fromStart;
        var toStart = 1;
        for (; toStart < to.length; ++toStart) {
          if (to.charCodeAt(toStart) !== 47)
            break;
        }
        var toEnd = to.length;
        var toLen = toEnd - toStart;
        var length = fromLen < toLen ? fromLen : toLen;
        var lastCommonSep = -1;
        var i = 0;
        for (; i <= length; ++i) {
          if (i === length) {
            if (toLen > length) {
              if (to.charCodeAt(toStart + i) === 47) {
                return to.slice(toStart + i + 1);
              } else if (i === 0) {
                return to.slice(toStart + i);
              }
            } else if (fromLen > length) {
              if (from.charCodeAt(fromStart + i) === 47) {
                lastCommonSep = i;
              } else if (i === 0) {
                lastCommonSep = 0;
              }
            }
            break;
          }
          var fromCode = from.charCodeAt(fromStart + i);
          var toCode = to.charCodeAt(toStart + i);
          if (fromCode !== toCode)
            break;
          else if (fromCode === 47)
            lastCommonSep = i;
        }
        var out = "";
        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
          if (i === fromEnd || from.charCodeAt(i) === 47) {
            if (out.length === 0)
              out += "..";
            else
              out += "/..";
          }
        }
        if (out.length > 0)
          return out + to.slice(toStart + lastCommonSep);
        else {
          toStart += lastCommonSep;
          if (to.charCodeAt(toStart) === 47)
            ++toStart;
          return to.slice(toStart);
        }
      },
      _makeLong: function _makeLong(path) {
        return path;
      },
      dirname: function dirname(path) {
        assertPath(path);
        if (path.length === 0)
          return ".";
        var code = path.charCodeAt(0);
        var hasRoot = code === 47;
        var end = -1;
        var matchedSlash = true;
        for (var i = path.length - 1; i >= 1; --i) {
          code = path.charCodeAt(i);
          if (code === 47) {
            if (!matchedSlash) {
              end = i;
              break;
            }
          } else {
            matchedSlash = false;
          }
        }
        if (end === -1)
          return hasRoot ? "/" : ".";
        if (hasRoot && end === 1)
          return "//";
        return path.slice(0, end);
      },
      basename: function basename(path, ext) {
        if (ext !== void 0 && typeof ext !== "string")
          throw new TypeError('"ext" argument must be a string');
        assertPath(path);
        var start = 0;
        var end = -1;
        var matchedSlash = true;
        var i;
        if (ext !== void 0 && ext.length > 0 && ext.length <= path.length) {
          if (ext.length === path.length && ext === path)
            return "";
          var extIdx = ext.length - 1;
          var firstNonSlashEnd = -1;
          for (i = path.length - 1; i >= 0; --i) {
            var code = path.charCodeAt(i);
            if (code === 47) {
              if (!matchedSlash) {
                start = i + 1;
                break;
              }
            } else {
              if (firstNonSlashEnd === -1) {
                matchedSlash = false;
                firstNonSlashEnd = i + 1;
              }
              if (extIdx >= 0) {
                if (code === ext.charCodeAt(extIdx)) {
                  if (--extIdx === -1) {
                    end = i;
                  }
                } else {
                  extIdx = -1;
                  end = firstNonSlashEnd;
                }
              }
            }
          }
          if (start === end)
            end = firstNonSlashEnd;
          else if (end === -1)
            end = path.length;
          return path.slice(start, end);
        } else {
          for (i = path.length - 1; i >= 0; --i) {
            if (path.charCodeAt(i) === 47) {
              if (!matchedSlash) {
                start = i + 1;
                break;
              }
            } else if (end === -1) {
              matchedSlash = false;
              end = i + 1;
            }
          }
          if (end === -1)
            return "";
          return path.slice(start, end);
        }
      },
      extname: function extname(path) {
        assertPath(path);
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var preDotState = 0;
        for (var i = path.length - 1; i >= 0; --i) {
          var code = path.charCodeAt(i);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          return "";
        }
        return path.slice(startDot, end);
      },
      format: function format(pathObject) {
        if (pathObject === null || typeof pathObject !== "object") {
          throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
        }
        return _format("/", pathObject);
      },
      parse: function parse(path) {
        assertPath(path);
        var ret = { root: "", dir: "", base: "", ext: "", name: "" };
        if (path.length === 0)
          return ret;
        var code = path.charCodeAt(0);
        var isAbsolute = code === 47;
        var start;
        if (isAbsolute) {
          ret.root = "/";
          start = 1;
        } else {
          start = 0;
        }
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var i = path.length - 1;
        var preDotState = 0;
        for (; i >= start; --i) {
          code = path.charCodeAt(i);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          if (end !== -1) {
            if (startPart === 0 && isAbsolute)
              ret.base = ret.name = path.slice(1, end);
            else
              ret.base = ret.name = path.slice(startPart, end);
          }
        } else {
          if (startPart === 0 && isAbsolute) {
            ret.name = path.slice(1, startDot);
            ret.base = path.slice(1, end);
          } else {
            ret.name = path.slice(startPart, startDot);
            ret.base = path.slice(startPart, end);
          }
          ret.ext = path.slice(startDot, end);
        }
        if (startPart > 0)
          ret.dir = path.slice(0, startPart - 1);
        else if (isAbsolute)
          ret.dir = "/";
        return ret;
      },
      sep: "/",
      delimiter: ":",
      win32: null,
      posix: null
    };
    posix.posix = posix;
    module.exports = posix;
  }
});

// node_modules/diff/lib/diff/base.js
var require_base = __commonJS({
  "node_modules/diff/lib/diff/base.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = Diff;
    function Diff() {
    }
    Diff.prototype = {
      /*istanbul ignore start*/
      /*istanbul ignore end*/
      diff: function diff(oldString, newString) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var callback = options.callback;
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        this.options = options;
        var self2 = this;
        function done(value) {
          if (callback) {
            setTimeout(function() {
              callback(void 0, value);
            }, 0);
            return true;
          } else {
            return value;
          }
        }
        oldString = this.castInput(oldString);
        newString = this.castInput(newString);
        oldString = this.removeEmpty(this.tokenize(oldString));
        newString = this.removeEmpty(this.tokenize(newString));
        var newLen = newString.length, oldLen = oldString.length;
        var editLength = 1;
        var maxEditLength = newLen + oldLen;
        var bestPath = [{
          newPos: -1,
          components: []
        }];
        var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);
        if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
          return done([{
            value: this.join(newString),
            count: newString.length
          }]);
        }
        function execEditLength() {
          for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
            var basePath = (
              /*istanbul ignore start*/
              void 0
            );
            var addPath = bestPath[diagonalPath - 1], removePath = bestPath[diagonalPath + 1], _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;
            if (addPath) {
              bestPath[diagonalPath - 1] = void 0;
            }
            var canAdd = addPath && addPath.newPos + 1 < newLen, canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;
            if (!canAdd && !canRemove) {
              bestPath[diagonalPath] = void 0;
              continue;
            }
            if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {
              basePath = clonePath(removePath);
              self2.pushComponent(basePath.components, void 0, true);
            } else {
              basePath = addPath;
              basePath.newPos++;
              self2.pushComponent(basePath.components, true, void 0);
            }
            _oldPos = self2.extractCommon(basePath, newString, oldString, diagonalPath);
            if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {
              return done(buildValues(self2, basePath.components, newString, oldString, self2.useLongestToken));
            } else {
              bestPath[diagonalPath] = basePath;
            }
          }
          editLength++;
        }
        if (callback) {
          (function exec() {
            setTimeout(function() {
              if (editLength > maxEditLength) {
                return callback();
              }
              if (!execEditLength()) {
                exec();
              }
            }, 0);
          })();
        } else {
          while (editLength <= maxEditLength) {
            var ret = execEditLength();
            if (ret) {
              return ret;
            }
          }
        }
      },
      /*istanbul ignore start*/
      /*istanbul ignore end*/
      pushComponent: function pushComponent(components, added, removed) {
        var last = components[components.length - 1];
        if (last && last.added === added && last.removed === removed) {
          components[components.length - 1] = {
            count: last.count + 1,
            added,
            removed
          };
        } else {
          components.push({
            count: 1,
            added,
            removed
          });
        }
      },
      /*istanbul ignore start*/
      /*istanbul ignore end*/
      extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {
        var newLen = newString.length, oldLen = oldString.length, newPos = basePath.newPos, oldPos = newPos - diagonalPath, commonCount = 0;
        while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
          newPos++;
          oldPos++;
          commonCount++;
        }
        if (commonCount) {
          basePath.components.push({
            count: commonCount
          });
        }
        basePath.newPos = newPos;
        return oldPos;
      },
      /*istanbul ignore start*/
      /*istanbul ignore end*/
      equals: function equals(left, right) {
        if (this.options.comparator) {
          return this.options.comparator(left, right);
        } else {
          return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();
        }
      },
      /*istanbul ignore start*/
      /*istanbul ignore end*/
      removeEmpty: function removeEmpty(array) {
        var ret = [];
        for (var i = 0; i < array.length; i++) {
          if (array[i]) {
            ret.push(array[i]);
          }
        }
        return ret;
      },
      /*istanbul ignore start*/
      /*istanbul ignore end*/
      castInput: function castInput(value) {
        return value;
      },
      /*istanbul ignore start*/
      /*istanbul ignore end*/
      tokenize: function tokenize(value) {
        return value.split("");
      },
      /*istanbul ignore start*/
      /*istanbul ignore end*/
      join: function join(chars) {
        return chars.join("");
      }
    };
    function buildValues(diff, components, newString, oldString, useLongestToken) {
      var componentPos = 0, componentLen = components.length, newPos = 0, oldPos = 0;
      for (; componentPos < componentLen; componentPos++) {
        var component = components[componentPos];
        if (!component.removed) {
          if (!component.added && useLongestToken) {
            var value = newString.slice(newPos, newPos + component.count);
            value = value.map(function(value2, i) {
              var oldValue = oldString[oldPos + i];
              return oldValue.length > value2.length ? oldValue : value2;
            });
            component.value = diff.join(value);
          } else {
            component.value = diff.join(newString.slice(newPos, newPos + component.count));
          }
          newPos += component.count;
          if (!component.added) {
            oldPos += component.count;
          }
        } else {
          component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));
          oldPos += component.count;
          if (componentPos && components[componentPos - 1].added) {
            var tmp = components[componentPos - 1];
            components[componentPos - 1] = components[componentPos];
            components[componentPos] = tmp;
          }
        }
      }
      var lastComponent = components[componentLen - 1];
      if (componentLen > 1 && typeof lastComponent.value === "string" && (lastComponent.added || lastComponent.removed) && diff.equals("", lastComponent.value)) {
        components[componentLen - 2].value += lastComponent.value;
        components.pop();
      }
      return components;
    }
    function clonePath(path) {
      return {
        newPos: path.newPos,
        components: path.components.slice(0)
      };
    }
  }
});

// node_modules/diff/lib/diff/character.js
var require_character = __commonJS({
  "node_modules/diff/lib/diff/character.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.diffChars = diffChars;
    exports.characterDiff = void 0;
    var _base = _interopRequireDefault(require_base());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var characterDiff = new /*istanbul ignore start*/
    _base[
      /*istanbul ignore start*/
      "default"
      /*istanbul ignore end*/
    ]();
    exports.characterDiff = characterDiff;
    function diffChars(oldStr, newStr, options) {
      return characterDiff.diff(oldStr, newStr, options);
    }
  }
});

// node_modules/diff/lib/util/params.js
var require_params = __commonJS({
  "node_modules/diff/lib/util/params.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.generateOptions = generateOptions;
    function generateOptions(options, defaults) {
      if (typeof options === "function") {
        defaults.callback = options;
      } else if (options) {
        for (var name in options) {
          if (options.hasOwnProperty(name)) {
            defaults[name] = options[name];
          }
        }
      }
      return defaults;
    }
  }
});

// node_modules/diff/lib/diff/word.js
var require_word = __commonJS({
  "node_modules/diff/lib/diff/word.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.diffWords = diffWords;
    exports.diffWordsWithSpace = diffWordsWithSpace;
    exports.wordDiff = void 0;
    var _base = _interopRequireDefault(require_base());
    var _params = require_params();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var extendedWordChars = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/;
    var reWhitespace = /\S/;
    var wordDiff = new /*istanbul ignore start*/
    _base[
      /*istanbul ignore start*/
      "default"
      /*istanbul ignore end*/
    ]();
    exports.wordDiff = wordDiff;
    wordDiff.equals = function(left, right) {
      if (this.options.ignoreCase) {
        left = left.toLowerCase();
        right = right.toLowerCase();
      }
      return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);
    };
    wordDiff.tokenize = function(value) {
      var tokens = value.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/);
      for (var i = 0; i < tokens.length - 1; i++) {
        if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {
          tokens[i] += tokens[i + 2];
          tokens.splice(i + 1, 2);
          i--;
        }
      }
      return tokens;
    };
    function diffWords(oldStr, newStr, options) {
      options = /*istanbul ignore start*/
      (0, /*istanbul ignore end*/
      /*istanbul ignore start*/
      _params.generateOptions)(options, {
        ignoreWhitespace: true
      });
      return wordDiff.diff(oldStr, newStr, options);
    }
    function diffWordsWithSpace(oldStr, newStr, options) {
      return wordDiff.diff(oldStr, newStr, options);
    }
  }
});

// node_modules/diff/lib/diff/line.js
var require_line = __commonJS({
  "node_modules/diff/lib/diff/line.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.diffLines = diffLines;
    exports.diffTrimmedLines = diffTrimmedLines;
    exports.lineDiff = void 0;
    var _base = _interopRequireDefault(require_base());
    var _params = require_params();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var lineDiff = new /*istanbul ignore start*/
    _base[
      /*istanbul ignore start*/
      "default"
      /*istanbul ignore end*/
    ]();
    exports.lineDiff = lineDiff;
    lineDiff.tokenize = function(value) {
      var retLines = [], linesAndNewlines = value.split(/(\n|\r\n)/);
      if (!linesAndNewlines[linesAndNewlines.length - 1]) {
        linesAndNewlines.pop();
      }
      for (var i = 0; i < linesAndNewlines.length; i++) {
        var line = linesAndNewlines[i];
        if (i % 2 && !this.options.newlineIsToken) {
          retLines[retLines.length - 1] += line;
        } else {
          if (this.options.ignoreWhitespace) {
            line = line.trim();
          }
          retLines.push(line);
        }
      }
      return retLines;
    };
    function diffLines(oldStr, newStr, callback) {
      return lineDiff.diff(oldStr, newStr, callback);
    }
    function diffTrimmedLines(oldStr, newStr, callback) {
      var options = (
        /*istanbul ignore start*/
        (0, /*istanbul ignore end*/
        /*istanbul ignore start*/
        _params.generateOptions)(callback, {
          ignoreWhitespace: true
        })
      );
      return lineDiff.diff(oldStr, newStr, options);
    }
  }
});

// node_modules/diff/lib/diff/sentence.js
var require_sentence = __commonJS({
  "node_modules/diff/lib/diff/sentence.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.diffSentences = diffSentences;
    exports.sentenceDiff = void 0;
    var _base = _interopRequireDefault(require_base());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var sentenceDiff = new /*istanbul ignore start*/
    _base[
      /*istanbul ignore start*/
      "default"
      /*istanbul ignore end*/
    ]();
    exports.sentenceDiff = sentenceDiff;
    sentenceDiff.tokenize = function(value) {
      return value.split(/(\S.+?[.!?])(?=\s+|$)/);
    };
    function diffSentences(oldStr, newStr, callback) {
      return sentenceDiff.diff(oldStr, newStr, callback);
    }
  }
});

// node_modules/diff/lib/diff/css.js
var require_css = __commonJS({
  "node_modules/diff/lib/diff/css.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.diffCss = diffCss;
    exports.cssDiff = void 0;
    var _base = _interopRequireDefault(require_base());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var cssDiff = new /*istanbul ignore start*/
    _base[
      /*istanbul ignore start*/
      "default"
      /*istanbul ignore end*/
    ]();
    exports.cssDiff = cssDiff;
    cssDiff.tokenize = function(value) {
      return value.split(/([{}:;,]|\s+)/);
    };
    function diffCss(oldStr, newStr, callback) {
      return cssDiff.diff(oldStr, newStr, callback);
    }
  }
});

// node_modules/diff/lib/diff/json.js
var require_json = __commonJS({
  "node_modules/diff/lib/diff/json.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.diffJson = diffJson;
    exports.canonicalize = canonicalize;
    exports.jsonDiff = void 0;
    var _base = _interopRequireDefault(require_base());
    var _line = require_line();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    var objectPrototypeToString = Object.prototype.toString;
    var jsonDiff = new /*istanbul ignore start*/
    _base[
      /*istanbul ignore start*/
      "default"
      /*istanbul ignore end*/
    ]();
    exports.jsonDiff = jsonDiff;
    jsonDiff.useLongestToken = true;
    jsonDiff.tokenize = /*istanbul ignore start*/
    _line.lineDiff.tokenize;
    jsonDiff.castInput = function(value) {
      var _this$options = (
        /*istanbul ignore end*/
        this.options
      ), undefinedReplacement = _this$options.undefinedReplacement, _this$options$stringi = _this$options.stringifyReplacer, stringifyReplacer = _this$options$stringi === void 0 ? function(k, v) {
        return (
          /*istanbul ignore end*/
          typeof v === "undefined" ? undefinedReplacement : v
        );
      } : _this$options$stringi;
      return typeof value === "string" ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, "  ");
    };
    jsonDiff.equals = function(left, right) {
      return (
        /*istanbul ignore start*/
        _base[
          /*istanbul ignore start*/
          "default"
          /*istanbul ignore end*/
        ].prototype.equals.call(jsonDiff, left.replace(/,([\r\n])/g, "$1"), right.replace(/,([\r\n])/g, "$1"))
      );
    };
    function diffJson(oldObj, newObj, options) {
      return jsonDiff.diff(oldObj, newObj, options);
    }
    function canonicalize(obj, stack, replacementStack, replacer, key) {
      stack = stack || [];
      replacementStack = replacementStack || [];
      if (replacer) {
        obj = replacer(key, obj);
      }
      var i;
      for (i = 0; i < stack.length; i += 1) {
        if (stack[i] === obj) {
          return replacementStack[i];
        }
      }
      var canonicalizedObj;
      if ("[object Array]" === objectPrototypeToString.call(obj)) {
        stack.push(obj);
        canonicalizedObj = new Array(obj.length);
        replacementStack.push(canonicalizedObj);
        for (i = 0; i < obj.length; i += 1) {
          canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);
        }
        stack.pop();
        replacementStack.pop();
        return canonicalizedObj;
      }
      if (obj && obj.toJSON) {
        obj = obj.toJSON();
      }
      if (
        /*istanbul ignore start*/
        _typeof(
          /*istanbul ignore end*/
          obj
        ) === "object" && obj !== null
      ) {
        stack.push(obj);
        canonicalizedObj = {};
        replacementStack.push(canonicalizedObj);
        var sortedKeys = [], _key;
        for (_key in obj) {
          if (obj.hasOwnProperty(_key)) {
            sortedKeys.push(_key);
          }
        }
        sortedKeys.sort();
        for (i = 0; i < sortedKeys.length; i += 1) {
          _key = sortedKeys[i];
          canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);
        }
        stack.pop();
        replacementStack.pop();
      } else {
        canonicalizedObj = obj;
      }
      return canonicalizedObj;
    }
  }
});

// node_modules/diff/lib/diff/array.js
var require_array = __commonJS({
  "node_modules/diff/lib/diff/array.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.diffArrays = diffArrays;
    exports.arrayDiff = void 0;
    var _base = _interopRequireDefault(require_base());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var arrayDiff = new /*istanbul ignore start*/
    _base[
      /*istanbul ignore start*/
      "default"
      /*istanbul ignore end*/
    ]();
    exports.arrayDiff = arrayDiff;
    arrayDiff.tokenize = function(value) {
      return value.slice();
    };
    arrayDiff.join = arrayDiff.removeEmpty = function(value) {
      return value;
    };
    function diffArrays(oldArr, newArr, callback) {
      return arrayDiff.diff(oldArr, newArr, callback);
    }
  }
});

// node_modules/diff/lib/patch/parse.js
var require_parse = __commonJS({
  "node_modules/diff/lib/patch/parse.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.parsePatch = parsePatch;
    function parsePatch(uniDiff) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var diffstr = uniDiff.split(/\r\n|[\n\v\f\r\x85]/), delimiters = uniDiff.match(/\r\n|[\n\v\f\r\x85]/g) || [], list = [], i = 0;
      function parseIndex() {
        var index = {};
        list.push(index);
        while (i < diffstr.length) {
          var line = diffstr[i];
          if (/^(\-\-\-|\+\+\+|@@)\s/.test(line)) {
            break;
          }
          var header = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(line);
          if (header) {
            index.index = header[1];
          }
          i++;
        }
        parseFileHeader(index);
        parseFileHeader(index);
        index.hunks = [];
        while (i < diffstr.length) {
          var _line = diffstr[i];
          if (/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(_line)) {
            break;
          } else if (/^@@/.test(_line)) {
            index.hunks.push(parseHunk());
          } else if (_line && options.strict) {
            throw new Error("Unknown line " + (i + 1) + " " + JSON.stringify(_line));
          } else {
            i++;
          }
        }
      }
      function parseFileHeader(index) {
        var fileHeader = /^(---|\+\+\+)\s+(.*)$/.exec(diffstr[i]);
        if (fileHeader) {
          var keyPrefix = fileHeader[1] === "---" ? "old" : "new";
          var data = fileHeader[2].split("	", 2);
          var fileName = data[0].replace(/\\\\/g, "\\");
          if (/^".*"$/.test(fileName)) {
            fileName = fileName.substr(1, fileName.length - 2);
          }
          index[keyPrefix + "FileName"] = fileName;
          index[keyPrefix + "Header"] = (data[1] || "").trim();
          i++;
        }
      }
      function parseHunk() {
        var chunkHeaderIndex = i, chunkHeaderLine = diffstr[i++], chunkHeader = chunkHeaderLine.split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/);
        var hunk = {
          oldStart: +chunkHeader[1],
          oldLines: typeof chunkHeader[2] === "undefined" ? 1 : +chunkHeader[2],
          newStart: +chunkHeader[3],
          newLines: typeof chunkHeader[4] === "undefined" ? 1 : +chunkHeader[4],
          lines: [],
          linedelimiters: []
        };
        if (hunk.oldLines === 0) {
          hunk.oldStart += 1;
        }
        if (hunk.newLines === 0) {
          hunk.newStart += 1;
        }
        var addCount = 0, removeCount = 0;
        for (; i < diffstr.length; i++) {
          if (diffstr[i].indexOf("--- ") === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf("+++ ") === 0 && diffstr[i + 2].indexOf("@@") === 0) {
            break;
          }
          var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? " " : diffstr[i][0];
          if (operation === "+" || operation === "-" || operation === " " || operation === "\\") {
            hunk.lines.push(diffstr[i]);
            hunk.linedelimiters.push(delimiters[i] || "\n");
            if (operation === "+") {
              addCount++;
            } else if (operation === "-") {
              removeCount++;
            } else if (operation === " ") {
              addCount++;
              removeCount++;
            }
          } else {
            break;
          }
        }
        if (!addCount && hunk.newLines === 1) {
          hunk.newLines = 0;
        }
        if (!removeCount && hunk.oldLines === 1) {
          hunk.oldLines = 0;
        }
        if (options.strict) {
          if (addCount !== hunk.newLines) {
            throw new Error("Added line count did not match for hunk at line " + (chunkHeaderIndex + 1));
          }
          if (removeCount !== hunk.oldLines) {
            throw new Error("Removed line count did not match for hunk at line " + (chunkHeaderIndex + 1));
          }
        }
        return hunk;
      }
      while (i < diffstr.length) {
        parseIndex();
      }
      return list;
    }
  }
});

// node_modules/diff/lib/util/distance-iterator.js
var require_distance_iterator = __commonJS({
  "node_modules/diff/lib/util/distance-iterator.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = _default;
    function _default(start, minLine, maxLine) {
      var wantForward = true, backwardExhausted = false, forwardExhausted = false, localOffset = 1;
      return function iterator() {
        if (wantForward && !forwardExhausted) {
          if (backwardExhausted) {
            localOffset++;
          } else {
            wantForward = false;
          }
          if (start + localOffset <= maxLine) {
            return localOffset;
          }
          forwardExhausted = true;
        }
        if (!backwardExhausted) {
          if (!forwardExhausted) {
            wantForward = true;
          }
          if (minLine <= start - localOffset) {
            return -localOffset++;
          }
          backwardExhausted = true;
          return iterator();
        }
      };
    }
  }
});

// node_modules/diff/lib/patch/apply.js
var require_apply = __commonJS({
  "node_modules/diff/lib/patch/apply.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.applyPatch = applyPatch;
    exports.applyPatches = applyPatches;
    var _parse = require_parse();
    var _distanceIterator = _interopRequireDefault(require_distance_iterator());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function applyPatch(source, uniDiff) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      if (typeof uniDiff === "string") {
        uniDiff = /*istanbul ignore start*/
        (0, /*istanbul ignore end*/
        /*istanbul ignore start*/
        _parse.parsePatch)(uniDiff);
      }
      if (Array.isArray(uniDiff)) {
        if (uniDiff.length > 1) {
          throw new Error("applyPatch only works with a single input.");
        }
        uniDiff = uniDiff[0];
      }
      var lines = source.split(/\r\n|[\n\v\f\r\x85]/), delimiters = source.match(/\r\n|[\n\v\f\r\x85]/g) || [], hunks = uniDiff.hunks, compareLine = options.compareLine || function(lineNumber, line2, operation2, patchContent) {
        return (
          /*istanbul ignore end*/
          line2 === patchContent
        );
      }, errorCount = 0, fuzzFactor = options.fuzzFactor || 0, minLine = 0, offset = 0, removeEOFNL, addEOFNL;
      function hunkFits(hunk2, toPos2) {
        for (var j2 = 0; j2 < hunk2.lines.length; j2++) {
          var line2 = hunk2.lines[j2], operation2 = line2.length > 0 ? line2[0] : " ", content2 = line2.length > 0 ? line2.substr(1) : line2;
          if (operation2 === " " || operation2 === "-") {
            if (!compareLine(toPos2 + 1, lines[toPos2], operation2, content2)) {
              errorCount++;
              if (errorCount > fuzzFactor) {
                return false;
              }
            }
            toPos2++;
          }
        }
        return true;
      }
      for (var i = 0; i < hunks.length; i++) {
        var hunk = hunks[i], maxLine = lines.length - hunk.oldLines, localOffset = 0, toPos = offset + hunk.oldStart - 1;
        var iterator = (
          /*istanbul ignore start*/
          (0, /*istanbul ignore end*/
          /*istanbul ignore start*/
          _distanceIterator[
            /*istanbul ignore start*/
            "default"
            /*istanbul ignore end*/
          ])(toPos, minLine, maxLine)
        );
        for (; localOffset !== void 0; localOffset = iterator()) {
          if (hunkFits(hunk, toPos + localOffset)) {
            hunk.offset = offset += localOffset;
            break;
          }
        }
        if (localOffset === void 0) {
          return false;
        }
        minLine = hunk.offset + hunk.oldStart + hunk.oldLines;
      }
      var diffOffset = 0;
      for (var _i = 0; _i < hunks.length; _i++) {
        var _hunk = hunks[_i], _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;
        diffOffset += _hunk.newLines - _hunk.oldLines;
        for (var j = 0; j < _hunk.lines.length; j++) {
          var line = _hunk.lines[j], operation = line.length > 0 ? line[0] : " ", content = line.length > 0 ? line.substr(1) : line, delimiter = _hunk.linedelimiters[j];
          if (operation === " ") {
            _toPos++;
          } else if (operation === "-") {
            lines.splice(_toPos, 1);
            delimiters.splice(_toPos, 1);
          } else if (operation === "+") {
            lines.splice(_toPos, 0, content);
            delimiters.splice(_toPos, 0, delimiter);
            _toPos++;
          } else if (operation === "\\") {
            var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;
            if (previousOperation === "+") {
              removeEOFNL = true;
            } else if (previousOperation === "-") {
              addEOFNL = true;
            }
          }
        }
      }
      if (removeEOFNL) {
        while (!lines[lines.length - 1]) {
          lines.pop();
          delimiters.pop();
        }
      } else if (addEOFNL) {
        lines.push("");
        delimiters.push("\n");
      }
      for (var _k = 0; _k < lines.length - 1; _k++) {
        lines[_k] = lines[_k] + delimiters[_k];
      }
      return lines.join("");
    }
    function applyPatches(uniDiff, options) {
      if (typeof uniDiff === "string") {
        uniDiff = /*istanbul ignore start*/
        (0, /*istanbul ignore end*/
        /*istanbul ignore start*/
        _parse.parsePatch)(uniDiff);
      }
      var currentIndex = 0;
      function processIndex() {
        var index = uniDiff[currentIndex++];
        if (!index) {
          return options.complete();
        }
        options.loadFile(index, function(err, data) {
          if (err) {
            return options.complete(err);
          }
          var updatedContent = applyPatch(data, index, options);
          options.patched(index, updatedContent, function(err2) {
            if (err2) {
              return options.complete(err2);
            }
            processIndex();
          });
        });
      }
      processIndex();
    }
  }
});

// node_modules/diff/lib/patch/create.js
var require_create = __commonJS({
  "node_modules/diff/lib/patch/create.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.structuredPatch = structuredPatch;
    exports.formatPatch = formatPatch;
    exports.createTwoFilesPatch = createTwoFilesPatch;
    exports.createPatch = createPatch;
    var _line = require_line();
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
        return Array.from(iter);
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
      if (!options) {
        options = {};
      }
      if (typeof options.context === "undefined") {
        options.context = 4;
      }
      var diff = (
        /*istanbul ignore start*/
        (0, /*istanbul ignore end*/
        /*istanbul ignore start*/
        _line.diffLines)(oldStr, newStr, options)
      );
      diff.push({
        value: "",
        lines: []
      });
      function contextLines(lines) {
        return lines.map(function(entry) {
          return " " + entry;
        });
      }
      var hunks = [];
      var oldRangeStart = 0, newRangeStart = 0, curRange = [], oldLine = 1, newLine = 1;
      var _loop = function _loop2(i2) {
        var current = diff[i2], lines = current.lines || current.value.replace(/\n$/, "").split("\n");
        current.lines = lines;
        if (current.added || current.removed) {
          var _curRange;
          if (!oldRangeStart) {
            var prev = diff[i2 - 1];
            oldRangeStart = oldLine;
            newRangeStart = newLine;
            if (prev) {
              curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];
              oldRangeStart -= curRange.length;
              newRangeStart -= curRange.length;
            }
          }
          (_curRange = /*istanbul ignore end*/
          curRange).push.apply(
            /*istanbul ignore start*/
            _curRange,
            /*istanbul ignore start*/
            _toConsumableArray(
              /*istanbul ignore end*/
              lines.map(function(entry) {
                return (current.added ? "+" : "-") + entry;
              })
            )
          );
          if (current.added) {
            newLine += lines.length;
          } else {
            oldLine += lines.length;
          }
        } else {
          if (oldRangeStart) {
            if (lines.length <= options.context * 2 && i2 < diff.length - 2) {
              var _curRange2;
              (_curRange2 = /*istanbul ignore end*/
              curRange).push.apply(
                /*istanbul ignore start*/
                _curRange2,
                /*istanbul ignore start*/
                _toConsumableArray(
                  /*istanbul ignore end*/
                  contextLines(lines)
                )
              );
            } else {
              var _curRange3;
              var contextSize = Math.min(lines.length, options.context);
              (_curRange3 = /*istanbul ignore end*/
              curRange).push.apply(
                /*istanbul ignore start*/
                _curRange3,
                /*istanbul ignore start*/
                _toConsumableArray(
                  /*istanbul ignore end*/
                  contextLines(lines.slice(0, contextSize))
                )
              );
              var hunk = {
                oldStart: oldRangeStart,
                oldLines: oldLine - oldRangeStart + contextSize,
                newStart: newRangeStart,
                newLines: newLine - newRangeStart + contextSize,
                lines: curRange
              };
              if (i2 >= diff.length - 2 && lines.length <= options.context) {
                var oldEOFNewline = /\n$/.test(oldStr);
                var newEOFNewline = /\n$/.test(newStr);
                var noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;
                if (!oldEOFNewline && noNlBeforeAdds && oldStr.length > 0) {
                  curRange.splice(hunk.oldLines, 0, "\\ No newline at end of file");
                }
                if (!oldEOFNewline && !noNlBeforeAdds || !newEOFNewline) {
                  curRange.push("\\ No newline at end of file");
                }
              }
              hunks.push(hunk);
              oldRangeStart = 0;
              newRangeStart = 0;
              curRange = [];
            }
          }
          oldLine += lines.length;
          newLine += lines.length;
        }
      };
      for (var i = 0; i < diff.length; i++) {
        _loop(
          /*istanbul ignore end*/
          i
        );
      }
      return {
        oldFileName,
        newFileName,
        oldHeader,
        newHeader,
        hunks
      };
    }
    function formatPatch(diff) {
      var ret = [];
      if (diff.oldFileName == diff.newFileName) {
        ret.push("Index: " + diff.oldFileName);
      }
      ret.push("===================================================================");
      ret.push("--- " + diff.oldFileName + (typeof diff.oldHeader === "undefined" ? "" : "	" + diff.oldHeader));
      ret.push("+++ " + diff.newFileName + (typeof diff.newHeader === "undefined" ? "" : "	" + diff.newHeader));
      for (var i = 0; i < diff.hunks.length; i++) {
        var hunk = diff.hunks[i];
        if (hunk.oldLines === 0) {
          hunk.oldStart -= 1;
        }
        if (hunk.newLines === 0) {
          hunk.newStart -= 1;
        }
        ret.push("@@ -" + hunk.oldStart + "," + hunk.oldLines + " +" + hunk.newStart + "," + hunk.newLines + " @@");
        ret.push.apply(ret, hunk.lines);
      }
      return ret.join("\n") + "\n";
    }
    function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
      return formatPatch(structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options));
    }
    function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {
      return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);
    }
  }
});

// node_modules/diff/lib/util/array.js
var require_array2 = __commonJS({
  "node_modules/diff/lib/util/array.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.arrayEqual = arrayEqual;
    exports.arrayStartsWith = arrayStartsWith;
    function arrayEqual(a, b) {
      if (a.length !== b.length) {
        return false;
      }
      return arrayStartsWith(a, b);
    }
    function arrayStartsWith(array, start) {
      if (start.length > array.length) {
        return false;
      }
      for (var i = 0; i < start.length; i++) {
        if (start[i] !== array[i]) {
          return false;
        }
      }
      return true;
    }
  }
});

// node_modules/diff/lib/patch/merge.js
var require_merge = __commonJS({
  "node_modules/diff/lib/patch/merge.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.calcLineCount = calcLineCount;
    exports.merge = merge;
    var _create = require_create();
    var _parse = require_parse();
    var _array = require_array2();
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
        return Array.from(iter);
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function calcLineCount(hunk) {
      var _calcOldNewLineCount = (
        /*istanbul ignore end*/
        calcOldNewLineCount(hunk.lines)
      ), oldLines = _calcOldNewLineCount.oldLines, newLines = _calcOldNewLineCount.newLines;
      if (oldLines !== void 0) {
        hunk.oldLines = oldLines;
      } else {
        delete hunk.oldLines;
      }
      if (newLines !== void 0) {
        hunk.newLines = newLines;
      } else {
        delete hunk.newLines;
      }
    }
    function merge(mine, theirs, base) {
      mine = loadPatch(mine, base);
      theirs = loadPatch(theirs, base);
      var ret = {};
      if (mine.index || theirs.index) {
        ret.index = mine.index || theirs.index;
      }
      if (mine.newFileName || theirs.newFileName) {
        if (!fileNameChanged(mine)) {
          ret.oldFileName = theirs.oldFileName || mine.oldFileName;
          ret.newFileName = theirs.newFileName || mine.newFileName;
          ret.oldHeader = theirs.oldHeader || mine.oldHeader;
          ret.newHeader = theirs.newHeader || mine.newHeader;
        } else if (!fileNameChanged(theirs)) {
          ret.oldFileName = mine.oldFileName;
          ret.newFileName = mine.newFileName;
          ret.oldHeader = mine.oldHeader;
          ret.newHeader = mine.newHeader;
        } else {
          ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);
          ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);
          ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);
          ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);
        }
      }
      ret.hunks = [];
      var mineIndex = 0, theirsIndex = 0, mineOffset = 0, theirsOffset = 0;
      while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {
        var mineCurrent = mine.hunks[mineIndex] || {
          oldStart: Infinity
        }, theirsCurrent = theirs.hunks[theirsIndex] || {
          oldStart: Infinity
        };
        if (hunkBefore(mineCurrent, theirsCurrent)) {
          ret.hunks.push(cloneHunk(mineCurrent, mineOffset));
          mineIndex++;
          theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;
        } else if (hunkBefore(theirsCurrent, mineCurrent)) {
          ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));
          theirsIndex++;
          mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;
        } else {
          var mergedHunk = {
            oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),
            oldLines: 0,
            newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),
            newLines: 0,
            lines: []
          };
          mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);
          theirsIndex++;
          mineIndex++;
          ret.hunks.push(mergedHunk);
        }
      }
      return ret;
    }
    function loadPatch(param, base) {
      if (typeof param === "string") {
        if (/^@@/m.test(param) || /^Index:/m.test(param)) {
          return (
            /*istanbul ignore start*/
            (0, /*istanbul ignore end*/
            /*istanbul ignore start*/
            _parse.parsePatch)(param)[0]
          );
        }
        if (!base) {
          throw new Error("Must provide a base reference or pass in a patch");
        }
        return (
          /*istanbul ignore start*/
          (0, /*istanbul ignore end*/
          /*istanbul ignore start*/
          _create.structuredPatch)(void 0, void 0, base, param)
        );
      }
      return param;
    }
    function fileNameChanged(patch) {
      return patch.newFileName && patch.newFileName !== patch.oldFileName;
    }
    function selectField(index, mine, theirs) {
      if (mine === theirs) {
        return mine;
      } else {
        index.conflict = true;
        return {
          mine,
          theirs
        };
      }
    }
    function hunkBefore(test, check) {
      return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;
    }
    function cloneHunk(hunk, offset) {
      return {
        oldStart: hunk.oldStart,
        oldLines: hunk.oldLines,
        newStart: hunk.newStart + offset,
        newLines: hunk.newLines,
        lines: hunk.lines
      };
    }
    function mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {
      var mine = {
        offset: mineOffset,
        lines: mineLines,
        index: 0
      }, their = {
        offset: theirOffset,
        lines: theirLines,
        index: 0
      };
      insertLeading(hunk, mine, their);
      insertLeading(hunk, their, mine);
      while (mine.index < mine.lines.length && their.index < their.lines.length) {
        var mineCurrent = mine.lines[mine.index], theirCurrent = their.lines[their.index];
        if ((mineCurrent[0] === "-" || mineCurrent[0] === "+") && (theirCurrent[0] === "-" || theirCurrent[0] === "+")) {
          mutualChange(hunk, mine, their);
        } else if (mineCurrent[0] === "+" && theirCurrent[0] === " ") {
          var _hunk$lines;
          (_hunk$lines = /*istanbul ignore end*/
          hunk.lines).push.apply(
            /*istanbul ignore start*/
            _hunk$lines,
            /*istanbul ignore start*/
            _toConsumableArray(
              /*istanbul ignore end*/
              collectChange(mine)
            )
          );
        } else if (theirCurrent[0] === "+" && mineCurrent[0] === " ") {
          var _hunk$lines2;
          (_hunk$lines2 = /*istanbul ignore end*/
          hunk.lines).push.apply(
            /*istanbul ignore start*/
            _hunk$lines2,
            /*istanbul ignore start*/
            _toConsumableArray(
              /*istanbul ignore end*/
              collectChange(their)
            )
          );
        } else if (mineCurrent[0] === "-" && theirCurrent[0] === " ") {
          removal(hunk, mine, their);
        } else if (theirCurrent[0] === "-" && mineCurrent[0] === " ") {
          removal(hunk, their, mine, true);
        } else if (mineCurrent === theirCurrent) {
          hunk.lines.push(mineCurrent);
          mine.index++;
          their.index++;
        } else {
          conflict(hunk, collectChange(mine), collectChange(their));
        }
      }
      insertTrailing(hunk, mine);
      insertTrailing(hunk, their);
      calcLineCount(hunk);
    }
    function mutualChange(hunk, mine, their) {
      var myChanges = collectChange(mine), theirChanges = collectChange(their);
      if (allRemoves(myChanges) && allRemoves(theirChanges)) {
        if (
          /*istanbul ignore start*/
          (0, /*istanbul ignore end*/
          /*istanbul ignore start*/
          _array.arrayStartsWith)(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)
        ) {
          var _hunk$lines3;
          (_hunk$lines3 = /*istanbul ignore end*/
          hunk.lines).push.apply(
            /*istanbul ignore start*/
            _hunk$lines3,
            /*istanbul ignore start*/
            _toConsumableArray(
              /*istanbul ignore end*/
              myChanges
            )
          );
          return;
        } else if (
          /*istanbul ignore start*/
          (0, /*istanbul ignore end*/
          /*istanbul ignore start*/
          _array.arrayStartsWith)(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)
        ) {
          var _hunk$lines4;
          (_hunk$lines4 = /*istanbul ignore end*/
          hunk.lines).push.apply(
            /*istanbul ignore start*/
            _hunk$lines4,
            /*istanbul ignore start*/
            _toConsumableArray(
              /*istanbul ignore end*/
              theirChanges
            )
          );
          return;
        }
      } else if (
        /*istanbul ignore start*/
        (0, /*istanbul ignore end*/
        /*istanbul ignore start*/
        _array.arrayEqual)(myChanges, theirChanges)
      ) {
        var _hunk$lines5;
        (_hunk$lines5 = /*istanbul ignore end*/
        hunk.lines).push.apply(
          /*istanbul ignore start*/
          _hunk$lines5,
          /*istanbul ignore start*/
          _toConsumableArray(
            /*istanbul ignore end*/
            myChanges
          )
        );
        return;
      }
      conflict(hunk, myChanges, theirChanges);
    }
    function removal(hunk, mine, their, swap) {
      var myChanges = collectChange(mine), theirChanges = collectContext(their, myChanges);
      if (theirChanges.merged) {
        var _hunk$lines6;
        (_hunk$lines6 = /*istanbul ignore end*/
        hunk.lines).push.apply(
          /*istanbul ignore start*/
          _hunk$lines6,
          /*istanbul ignore start*/
          _toConsumableArray(
            /*istanbul ignore end*/
            theirChanges.merged
          )
        );
      } else {
        conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);
      }
    }
    function conflict(hunk, mine, their) {
      hunk.conflict = true;
      hunk.lines.push({
        conflict: true,
        mine,
        theirs: their
      });
    }
    function insertLeading(hunk, insert, their) {
      while (insert.offset < their.offset && insert.index < insert.lines.length) {
        var line = insert.lines[insert.index++];
        hunk.lines.push(line);
        insert.offset++;
      }
    }
    function insertTrailing(hunk, insert) {
      while (insert.index < insert.lines.length) {
        var line = insert.lines[insert.index++];
        hunk.lines.push(line);
      }
    }
    function collectChange(state) {
      var ret = [], operation = state.lines[state.index][0];
      while (state.index < state.lines.length) {
        var line = state.lines[state.index];
        if (operation === "-" && line[0] === "+") {
          operation = "+";
        }
        if (operation === line[0]) {
          ret.push(line);
          state.index++;
        } else {
          break;
        }
      }
      return ret;
    }
    function collectContext(state, matchChanges) {
      var changes = [], merged = [], matchIndex = 0, contextChanges = false, conflicted = false;
      while (matchIndex < matchChanges.length && state.index < state.lines.length) {
        var change = state.lines[state.index], match = matchChanges[matchIndex];
        if (match[0] === "+") {
          break;
        }
        contextChanges = contextChanges || change[0] !== " ";
        merged.push(match);
        matchIndex++;
        if (change[0] === "+") {
          conflicted = true;
          while (change[0] === "+") {
            changes.push(change);
            change = state.lines[++state.index];
          }
        }
        if (match.substr(1) === change.substr(1)) {
          changes.push(change);
          state.index++;
        } else {
          conflicted = true;
        }
      }
      if ((matchChanges[matchIndex] || "")[0] === "+" && contextChanges) {
        conflicted = true;
      }
      if (conflicted) {
        return changes;
      }
      while (matchIndex < matchChanges.length) {
        merged.push(matchChanges[matchIndex++]);
      }
      return {
        merged,
        changes
      };
    }
    function allRemoves(changes) {
      return changes.reduce(function(prev, change) {
        return prev && change[0] === "-";
      }, true);
    }
    function skipRemoveSuperset(state, removeChanges, delta) {
      for (var i = 0; i < delta; i++) {
        var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);
        if (state.lines[state.index + i] !== " " + changeContent) {
          return false;
        }
      }
      state.index += delta;
      return true;
    }
    function calcOldNewLineCount(lines) {
      var oldLines = 0;
      var newLines = 0;
      lines.forEach(function(line) {
        if (typeof line !== "string") {
          var myCount = calcOldNewLineCount(line.mine);
          var theirCount = calcOldNewLineCount(line.theirs);
          if (oldLines !== void 0) {
            if (myCount.oldLines === theirCount.oldLines) {
              oldLines += myCount.oldLines;
            } else {
              oldLines = void 0;
            }
          }
          if (newLines !== void 0) {
            if (myCount.newLines === theirCount.newLines) {
              newLines += myCount.newLines;
            } else {
              newLines = void 0;
            }
          }
        } else {
          if (newLines !== void 0 && (line[0] === "+" || line[0] === " ")) {
            newLines++;
          }
          if (oldLines !== void 0 && (line[0] === "-" || line[0] === " ")) {
            oldLines++;
          }
        }
      });
      return {
        oldLines,
        newLines
      };
    }
  }
});

// node_modules/diff/lib/convert/dmp.js
var require_dmp = __commonJS({
  "node_modules/diff/lib/convert/dmp.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.convertChangesToDMP = convertChangesToDMP;
    function convertChangesToDMP(changes) {
      var ret = [], change, operation;
      for (var i = 0; i < changes.length; i++) {
        change = changes[i];
        if (change.added) {
          operation = 1;
        } else if (change.removed) {
          operation = -1;
        } else {
          operation = 0;
        }
        ret.push([operation, change.value]);
      }
      return ret;
    }
  }
});

// node_modules/diff/lib/convert/xml.js
var require_xml = __commonJS({
  "node_modules/diff/lib/convert/xml.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.convertChangesToXML = convertChangesToXML;
    function convertChangesToXML(changes) {
      var ret = [];
      for (var i = 0; i < changes.length; i++) {
        var change = changes[i];
        if (change.added) {
          ret.push("<ins>");
        } else if (change.removed) {
          ret.push("<del>");
        }
        ret.push(escapeHTML(change.value));
        if (change.added) {
          ret.push("</ins>");
        } else if (change.removed) {
          ret.push("</del>");
        }
      }
      return ret.join("");
    }
    function escapeHTML(s) {
      var n = s;
      n = n.replace(/&/g, "&amp;");
      n = n.replace(/</g, "&lt;");
      n = n.replace(/>/g, "&gt;");
      n = n.replace(/"/g, "&quot;");
      return n;
    }
  }
});

// node_modules/diff/lib/index.js
var require_lib = __commonJS({
  "node_modules/diff/lib/index.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "Diff", {
      enumerable: true,
      get: function get() {
        return _base["default"];
      }
    });
    Object.defineProperty(exports, "diffChars", {
      enumerable: true,
      get: function get() {
        return _character.diffChars;
      }
    });
    Object.defineProperty(exports, "diffWords", {
      enumerable: true,
      get: function get() {
        return _word.diffWords;
      }
    });
    Object.defineProperty(exports, "diffWordsWithSpace", {
      enumerable: true,
      get: function get() {
        return _word.diffWordsWithSpace;
      }
    });
    Object.defineProperty(exports, "diffLines", {
      enumerable: true,
      get: function get() {
        return _line.diffLines;
      }
    });
    Object.defineProperty(exports, "diffTrimmedLines", {
      enumerable: true,
      get: function get() {
        return _line.diffTrimmedLines;
      }
    });
    Object.defineProperty(exports, "diffSentences", {
      enumerable: true,
      get: function get() {
        return _sentence.diffSentences;
      }
    });
    Object.defineProperty(exports, "diffCss", {
      enumerable: true,
      get: function get() {
        return _css.diffCss;
      }
    });
    Object.defineProperty(exports, "diffJson", {
      enumerable: true,
      get: function get() {
        return _json.diffJson;
      }
    });
    Object.defineProperty(exports, "canonicalize", {
      enumerable: true,
      get: function get() {
        return _json.canonicalize;
      }
    });
    Object.defineProperty(exports, "diffArrays", {
      enumerable: true,
      get: function get() {
        return _array.diffArrays;
      }
    });
    Object.defineProperty(exports, "applyPatch", {
      enumerable: true,
      get: function get() {
        return _apply.applyPatch;
      }
    });
    Object.defineProperty(exports, "applyPatches", {
      enumerable: true,
      get: function get() {
        return _apply.applyPatches;
      }
    });
    Object.defineProperty(exports, "parsePatch", {
      enumerable: true,
      get: function get() {
        return _parse.parsePatch;
      }
    });
    Object.defineProperty(exports, "merge", {
      enumerable: true,
      get: function get() {
        return _merge.merge;
      }
    });
    Object.defineProperty(exports, "structuredPatch", {
      enumerable: true,
      get: function get() {
        return _create.structuredPatch;
      }
    });
    Object.defineProperty(exports, "createTwoFilesPatch", {
      enumerable: true,
      get: function get() {
        return _create.createTwoFilesPatch;
      }
    });
    Object.defineProperty(exports, "createPatch", {
      enumerable: true,
      get: function get() {
        return _create.createPatch;
      }
    });
    Object.defineProperty(exports, "convertChangesToDMP", {
      enumerable: true,
      get: function get() {
        return _dmp.convertChangesToDMP;
      }
    });
    Object.defineProperty(exports, "convertChangesToXML", {
      enumerable: true,
      get: function get() {
        return _xml.convertChangesToXML;
      }
    });
    var _base = _interopRequireDefault(require_base());
    var _character = require_character();
    var _word = require_word();
    var _line = require_line();
    var _sentence = require_sentence();
    var _css = require_css();
    var _json = require_json();
    var _array = require_array();
    var _apply = require_apply();
    var _parse = require_parse();
    var _merge = require_merge();
    var _create = require_create();
    var _dmp = require_dmp();
    var _xml = require_xml();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
  }
});

// node_modules/mocha/node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/mocha/node_modules/ms/index.js"(exports, module) {
    init_shim();
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/nanoid/non-secure/index.cjs
var require_non_secure = __commonJS({
  "node_modules/nanoid/non-secure/index.cjs"(exports, module) {
    init_shim();
    var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
    var customAlphabet = (alphabet, defaultSize = 21) => {
      return (size = defaultSize) => {
        let id = "";
        let i = size;
        while (i--) {
          id += alphabet[Math.random() * alphabet.length | 0];
        }
        return id;
      };
    };
    var nanoid = (size = 21) => {
      let id = "";
      let i = size;
      while (i--) {
        id += urlAlphabet[Math.random() * 64 | 0];
      }
      return id;
    };
    module.exports = { nanoid, customAlphabet };
  }
});

// node_modules/he/he.js
var require_he = __commonJS({
  "node_modules/he/he.js"(exports, module) {
    init_shim();
    (function(root) {
      var freeExports = typeof exports == "object" && exports;
      var freeModule = typeof module == "object" && module && module.exports == freeExports && module;
      var freeGlobal = typeof _global == "object" && _global;
      if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
        root = freeGlobal;
      }
      var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
      var regexAsciiWhitelist = /[\x01-\x7F]/g;
      var regexBmpWhitelist = /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g;
      var regexEncodeNonAscii = /<\u20D2|=\u20E5|>\u20D2|\u205F\u200A|\u219D\u0338|\u2202\u0338|\u2220\u20D2|\u2229\uFE00|\u222A\uFE00|\u223C\u20D2|\u223D\u0331|\u223E\u0333|\u2242\u0338|\u224B\u0338|\u224D\u20D2|\u224E\u0338|\u224F\u0338|\u2250\u0338|\u2261\u20E5|\u2264\u20D2|\u2265\u20D2|\u2266\u0338|\u2267\u0338|\u2268\uFE00|\u2269\uFE00|\u226A\u0338|\u226A\u20D2|\u226B\u0338|\u226B\u20D2|\u227F\u0338|\u2282\u20D2|\u2283\u20D2|\u228A\uFE00|\u228B\uFE00|\u228F\u0338|\u2290\u0338|\u2293\uFE00|\u2294\uFE00|\u22B4\u20D2|\u22B5\u20D2|\u22D8\u0338|\u22D9\u0338|\u22DA\uFE00|\u22DB\uFE00|\u22F5\u0338|\u22F9\u0338|\u2933\u0338|\u29CF\u0338|\u29D0\u0338|\u2A6D\u0338|\u2A70\u0338|\u2A7D\u0338|\u2A7E\u0338|\u2AA1\u0338|\u2AA2\u0338|\u2AAC\uFE00|\u2AAD\uFE00|\u2AAF\u0338|\u2AB0\u0338|\u2AC5\u0338|\u2AC6\u0338|\u2ACB\uFE00|\u2ACC\uFE00|\u2AFD\u20E5|[\xA0-\u0113\u0116-\u0122\u0124-\u012B\u012E-\u014D\u0150-\u017E\u0192\u01B5\u01F5\u0237\u02C6\u02C7\u02D8-\u02DD\u0311\u0391-\u03A1\u03A3-\u03A9\u03B1-\u03C9\u03D1\u03D2\u03D5\u03D6\u03DC\u03DD\u03F0\u03F1\u03F5\u03F6\u0401-\u040C\u040E-\u044F\u0451-\u045C\u045E\u045F\u2002-\u2005\u2007-\u2010\u2013-\u2016\u2018-\u201A\u201C-\u201E\u2020-\u2022\u2025\u2026\u2030-\u2035\u2039\u203A\u203E\u2041\u2043\u2044\u204F\u2057\u205F-\u2063\u20AC\u20DB\u20DC\u2102\u2105\u210A-\u2113\u2115-\u211E\u2122\u2124\u2127-\u2129\u212C\u212D\u212F-\u2131\u2133-\u2138\u2145-\u2148\u2153-\u215E\u2190-\u219B\u219D-\u21A7\u21A9-\u21AE\u21B0-\u21B3\u21B5-\u21B7\u21BA-\u21DB\u21DD\u21E4\u21E5\u21F5\u21FD-\u2205\u2207-\u2209\u220B\u220C\u220F-\u2214\u2216-\u2218\u221A\u221D-\u2238\u223A-\u2257\u2259\u225A\u225C\u225F-\u2262\u2264-\u228B\u228D-\u229B\u229D-\u22A5\u22A7-\u22B0\u22B2-\u22BB\u22BD-\u22DB\u22DE-\u22E3\u22E6-\u22F7\u22F9-\u22FE\u2305\u2306\u2308-\u2310\u2312\u2313\u2315\u2316\u231C-\u231F\u2322\u2323\u232D\u232E\u2336\u233D\u233F\u237C\u23B0\u23B1\u23B4-\u23B6\u23DC-\u23DF\u23E2\u23E7\u2423\u24C8\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2550-\u256C\u2580\u2584\u2588\u2591-\u2593\u25A1\u25AA\u25AB\u25AD\u25AE\u25B1\u25B3-\u25B5\u25B8\u25B9\u25BD-\u25BF\u25C2\u25C3\u25CA\u25CB\u25EC\u25EF\u25F8-\u25FC\u2605\u2606\u260E\u2640\u2642\u2660\u2663\u2665\u2666\u266A\u266D-\u266F\u2713\u2717\u2720\u2736\u2758\u2772\u2773\u27C8\u27C9\u27E6-\u27ED\u27F5-\u27FA\u27FC\u27FF\u2902-\u2905\u290C-\u2913\u2916\u2919-\u2920\u2923-\u292A\u2933\u2935-\u2939\u293C\u293D\u2945\u2948-\u294B\u294E-\u2976\u2978\u2979\u297B-\u297F\u2985\u2986\u298B-\u2996\u299A\u299C\u299D\u29A4-\u29B7\u29B9\u29BB\u29BC\u29BE-\u29C5\u29C9\u29CD-\u29D0\u29DC-\u29DE\u29E3-\u29E5\u29EB\u29F4\u29F6\u2A00-\u2A02\u2A04\u2A06\u2A0C\u2A0D\u2A10-\u2A17\u2A22-\u2A27\u2A29\u2A2A\u2A2D-\u2A31\u2A33-\u2A3C\u2A3F\u2A40\u2A42-\u2A4D\u2A50\u2A53-\u2A58\u2A5A-\u2A5D\u2A5F\u2A66\u2A6A\u2A6D-\u2A75\u2A77-\u2A9A\u2A9D-\u2AA2\u2AA4-\u2AB0\u2AB3-\u2AC8\u2ACB\u2ACC\u2ACF-\u2ADB\u2AE4\u2AE6-\u2AE9\u2AEB-\u2AF3\u2AFD\uFB00-\uFB04]|\uD835[\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDD6B]/g;
      var encodeMap = { "": "shy", "": "zwnj", "": "zwj", "": "lrm", "": "ic", "": "it", "": "af", "": "rlm", "": "ZeroWidthSpace", "": "NoBreak", "": "DownBreve", "": "tdot", "": "DotDot", "	": "Tab", "\n": "NewLine", "": "puncsp", "": "MediumSpace", "": "thinsp", "": "hairsp", "": "emsp13", "": "ensp", "": "emsp14", "": "emsp", "": "numsp", "": "nbsp", "": "ThickSpace", "": "oline", "_": "lowbar", "": "dash", "": "ndash", "": "mdash", "": "horbar", ",": "comma", ";": "semi", "": "bsemi", ":": "colon", "": "Colone", "!": "excl", "": "iexcl", "?": "quest", "": "iquest", ".": "period", "": "nldr", "": "mldr", "": "middot", "'": "apos", "": "lsquo", "": "rsquo", "": "sbquo", "": "lsaquo", "": "rsaquo", '"': "quot", "": "ldquo", "": "rdquo", "": "bdquo", "": "laquo", "": "raquo", "(": "lpar", ")": "rpar", "[": "lsqb", "]": "rsqb", "{": "lcub", "}": "rcub", "": "lceil", "": "rceil", "": "lfloor", "": "rfloor", "": "lopar", "": "ropar", "": "lbrke", "": "rbrke", "": "lbrkslu", "": "rbrksld", "": "lbrksld", "": "rbrkslu", "": "langd", "": "rangd", "": "lparlt", "": "rpargt", "": "gtlPar", "": "ltrPar", "": "lobrk", "": "robrk", "": "lang", "": "rang", "": "Lang", "": "Rang", "": "loang", "": "roang", "": "lbbrk", "": "rbbrk", "": "Vert", "": "sect", "": "para", "@": "commat", "*": "ast", "/": "sol", "undefined": null, "&": "amp", "#": "num", "%": "percnt", "": "permil", "": "pertenk", "": "dagger", "": "Dagger", "": "bull", "": "hybull", "": "prime", "": "Prime", "": "tprime", "": "qprime", "": "bprime", "": "caret", "`": "grave", "": "acute", "": "tilde", "^": "Hat", "": "macr", "": "breve", "": "dot", "": "die", "": "ring", "": "dblac", "": "cedil", "": "ogon", "": "circ", "": "caron", "": "deg", "": "copy", "": "reg", "": "copysr", "": "wp", "": "rx", "": "mho", "": "iiota", "": "larr", "": "nlarr", "": "rarr", "": "nrarr", "": "uarr", "": "darr", "": "harr", "": "nharr", "": "varr", "": "nwarr", "": "nearr", "": "searr", "": "swarr", "": "rarrw", "": "nrarrw", "": "Larr", "": "Uarr", "": "Rarr", "": "Darr", "": "larrtl", "": "rarrtl", "": "mapstoleft", "": "mapstoup", "": "map", "": "mapstodown", "": "larrhk", "": "rarrhk", "": "larrlp", "": "rarrlp", "": "harrw", "": "lsh", "": "rsh", "": "ldsh", "": "rdsh", "": "crarr", "": "cularr", "": "curarr", "": "olarr", "": "orarr", "": "lharu", "": "lhard", "": "uharr", "": "uharl", "": "rharu", "": "rhard", "": "dharr", "": "dharl", "": "rlarr", "": "udarr", "": "lrarr", "": "llarr", "": "uuarr", "": "rrarr", "": "ddarr", "": "lrhar", "": "rlhar", "": "lArr", "": "nlArr", "": "uArr", "": "rArr", "": "nrArr", "": "dArr", "": "iff", "": "nhArr", "": "vArr", "": "nwArr", "": "neArr", "": "seArr", "": "swArr", "": "lAarr", "": "rAarr", "": "zigrarr", "": "larrb", "": "rarrb", "": "duarr", "": "loarr", "": "roarr", "": "hoarr", "": "forall", "": "comp", "": "part", "": "npart", "": "exist", "": "nexist", "": "empty", "": "Del", "": "in", "": "notin", "": "ni", "": "notni", "": "bepsi", "": "prod", "": "coprod", "": "sum", "+": "plus", "": "pm", "": "div", "": "times", "<": "lt", "": "nlt", "<": "nvlt", "=": "equals", "": "ne", "=": "bne", "": "Equal", ">": "gt", "": "ngt", ">": "nvgt", "": "not", "|": "vert", "": "brvbar", "": "minus", "": "mp", "": "plusdo", "": "frasl", "": "setmn", "": "lowast", "": "compfn", "": "Sqrt", "": "prop", "": "infin", "": "angrt", "": "ang", "": "nang", "": "angmsd", "": "angsph", "": "mid", "": "nmid", "": "par", "": "npar", "": "and", "": "or", "": "cap", "": "caps", "": "cup", "": "cups", "": "int", "": "Int", "": "tint", "": "qint", "": "oint", "": "Conint", "": "Cconint", "": "cwint", "": "cwconint", "": "awconint", "": "there4", "": "becaus", "": "ratio", "": "Colon", "": "minusd", "": "mDDot", "": "homtht", "": "sim", "": "nsim", "": "nvsim", "": "bsim", "": "race", "": "ac", "": "acE", "": "acd", "": "wr", "": "esim", "": "nesim", "": "sime", "": "nsime", "": "cong", "": "ncong", "": "simne", "": "ap", "": "nap", "": "ape", "": "apid", "": "napid", "": "bcong", "": "CupCap", "": "NotCupCap", "": "nvap", "": "bump", "": "nbump", "": "bumpe", "": "nbumpe", "": "doteq", "": "nedot", "": "eDot", "": "efDot", "": "erDot", "": "colone", "": "ecolon", "": "ecir", "": "cire", "": "wedgeq", "": "veeeq", "": "trie", "": "equest", "": "equiv", "": "nequiv", "": "bnequiv", "": "le", "": "nle", "": "nvle", "": "ge", "": "nge", "": "nvge", "": "lE", "": "nlE", "": "gE", "": "ngE", "": "lvnE", "": "lnE", "": "gnE", "": "gvnE", "": "ll", "": "nLtv", "": "nLt", "": "gg", "": "nGtv", "": "nGt", "": "twixt", "": "lsim", "": "nlsim", "": "gsim", "": "ngsim", "": "lg", "": "ntlg", "": "gl", "": "ntgl", "": "pr", "": "npr", "": "sc", "": "nsc", "": "prcue", "": "nprcue", "": "sccue", "": "nsccue", "": "prsim", "": "scsim", "": "NotSucceedsTilde", "": "sub", "": "nsub", "": "vnsub", "": "sup", "": "nsup", "": "vnsup", "": "sube", "": "nsube", "": "supe", "": "nsupe", "": "vsubne", "": "subne", "": "vsupne", "": "supne", "": "cupdot", "": "uplus", "": "sqsub", "": "NotSquareSubset", "": "sqsup", "": "NotSquareSuperset", "": "sqsube", "": "nsqsube", "": "sqsupe", "": "nsqsupe", "": "sqcap", "": "sqcaps", "": "sqcup", "": "sqcups", "": "oplus", "": "ominus", "": "otimes", "": "osol", "": "odot", "": "ocir", "": "oast", "": "odash", "": "plusb", "": "minusb", "": "timesb", "": "sdotb", "": "vdash", "": "nvdash", "": "dashv", "": "top", "": "bot", "": "models", "": "vDash", "": "nvDash", "": "Vdash", "": "nVdash", "": "Vvdash", "": "VDash", "": "nVDash", "": "prurel", "": "vltri", "": "nltri", "": "vrtri", "": "nrtri", "": "ltrie", "": "nltrie", "": "nvltrie", "": "rtrie", "": "nrtrie", "": "nvrtrie", "": "origof", "": "imof", "": "mumap", "": "hercon", "": "intcal", "": "veebar", "": "barvee", "": "angrtvb", "": "lrtri", "": "Wedge", "": "Vee", "": "xcap", "": "xcup", "": "diam", "": "sdot", "": "Star", "": "divonx", "": "bowtie", "": "ltimes", "": "rtimes", "": "lthree", "": "rthree", "": "bsime", "": "cuvee", "": "cuwed", "": "Sub", "": "Sup", "": "Cap", "": "Cup", "": "fork", "": "epar", "": "ltdot", "": "gtdot", "": "Ll", "": "nLl", "": "Gg", "": "nGg", "": "lesg", "": "leg", "": "gel", "": "gesl", "": "cuepr", "": "cuesc", "": "lnsim", "": "gnsim", "": "prnsim", "": "scnsim", "": "vellip", "": "ctdot", "": "utdot", "": "dtdot", "": "disin", "": "isinsv", "": "isins", "": "isindot", "": "notindot", "": "notinvc", "": "notinvb", "": "isinE", "": "notinE", "": "nisd", "": "xnis", "": "nis", "": "notnivc", "": "notnivb", "": "barwed", "": "Barwed", "": "drcrop", "": "dlcrop", "": "urcrop", "": "ulcrop", "": "bnot", "": "profline", "": "profsurf", "": "telrec", "": "target", "": "ulcorn", "": "urcorn", "": "dlcorn", "": "drcorn", "": "frown", "": "smile", "": "cylcty", "": "profalar", "": "topbot", "": "ovbar", "": "solbar", "": "angzarr", "": "lmoust", "": "rmoust", "": "tbrk", "": "bbrk", "": "bbrktbrk", "": "OverParenthesis", "": "UnderParenthesis", "": "OverBrace", "": "UnderBrace", "": "trpezium", "": "elinters", "": "blank", "": "boxh", "": "boxv", "": "boxdr", "": "boxdl", "": "boxur", "": "boxul", "": "boxvr", "": "boxvl", "": "boxhd", "": "boxhu", "": "boxvh", "": "boxH", "": "boxV", "": "boxdR", "": "boxDr", "": "boxDR", "": "boxdL", "": "boxDl", "": "boxDL", "": "boxuR", "": "boxUr", "": "boxUR", "": "boxuL", "": "boxUl", "": "boxUL", "": "boxvR", "": "boxVr", "": "boxVR", "": "boxvL", "": "boxVl", "": "boxVL", "": "boxHd", "": "boxhD", "": "boxHD", "": "boxHu", "": "boxhU", "": "boxHU", "": "boxvH", "": "boxVh", "": "boxVH", "": "uhblk", "": "lhblk", "": "block", "": "blk14", "": "blk12", "": "blk34", "": "squ", "": "squf", "": "EmptyVerySmallSquare", "": "rect", "": "marker", "": "fltns", "": "xutri", "": "utrif", "": "utri", "": "rtrif", "": "rtri", "": "xdtri", "": "dtrif", "": "dtri", "": "ltrif", "": "ltri", "": "loz", "": "cir", "": "tridot", "": "xcirc", "": "ultri", "": "urtri", "": "lltri", "": "EmptySmallSquare", "": "FilledSmallSquare", "": "starf", "": "star", "": "phone", "": "female", "": "male", "": "spades", "": "clubs", "": "hearts", "": "diams", "": "sung", "": "check", "": "cross", "": "malt", "": "sext", "": "VerticalSeparator", "": "bsolhsub", "": "suphsol", "": "xlarr", "": "xrarr", "": "xharr", "": "xlArr", "": "xrArr", "": "xhArr", "": "xmap", "": "dzigrarr", "": "nvlArr", "": "nvrArr", "": "nvHarr", "": "Map", "": "lbarr", "": "rbarr", "": "lBarr", "": "rBarr", "": "RBarr", "": "DDotrahd", "": "UpArrowBar", "": "DownArrowBar", "": "Rarrtl", "": "latail", "": "ratail", "": "lAtail", "": "rAtail", "": "larrfs", "": "rarrfs", "": "larrbfs", "": "rarrbfs", "": "nwarhk", "": "nearhk", "": "searhk", "": "swarhk", "": "nwnear", "": "toea", "": "tosa", "": "swnwar", "": "rarrc", "": "nrarrc", "": "cudarrr", "": "ldca", "": "rdca", "": "cudarrl", "": "larrpl", "": "curarrm", "": "cularrp", "": "rarrpl", "": "harrcir", "": "Uarrocir", "": "lurdshar", "": "ldrushar", "": "LeftRightVector", "": "RightUpDownVector", "": "DownLeftRightVector", "": "LeftUpDownVector", "": "LeftVectorBar", "": "RightVectorBar", "": "RightUpVectorBar", "": "RightDownVectorBar", "": "DownLeftVectorBar", "": "DownRightVectorBar", "": "LeftUpVectorBar", "": "LeftDownVectorBar", "": "LeftTeeVector", "": "RightTeeVector", "": "RightUpTeeVector", "": "RightDownTeeVector", "": "DownLeftTeeVector", "": "DownRightTeeVector", "": "LeftUpTeeVector", "": "LeftDownTeeVector", "": "lHar", "": "uHar", "": "rHar", "": "dHar", "": "luruhar", "": "ldrdhar", "": "ruluhar", "": "rdldhar", "": "lharul", "": "llhard", "": "rharul", "": "lrhard", "": "udhar", "": "duhar", "": "RoundImplies", "": "erarr", "": "simrarr", "": "larrsim", "": "rarrsim", "": "rarrap", "": "ltlarr", "": "gtrarr", "": "subrarr", "": "suplarr", "": "lfisht", "": "rfisht", "": "ufisht", "": "dfisht", "": "vzigzag", "": "vangrt", "": "angrtvbd", "": "ange", "": "range", "": "dwangle", "": "uwangle", "": "angmsdaa", "": "angmsdab", "": "angmsdac", "": "angmsdad", "": "angmsdae", "": "angmsdaf", "": "angmsdag", "": "angmsdah", "": "bemptyv", "": "demptyv", "": "cemptyv", "": "raemptyv", "": "laemptyv", "": "ohbar", "": "omid", "": "opar", "": "operp", "": "olcross", "": "odsold", "": "olcir", "": "ofcir", "": "olt", "": "ogt", "": "cirscir", "": "cirE", "": "solb", "": "bsolb", "": "boxbox", "": "trisb", "": "rtriltri", "": "LeftTriangleBar", "": "NotLeftTriangleBar", "": "RightTriangleBar", "": "NotRightTriangleBar", "": "iinfin", "": "infintie", "": "nvinfin", "": "eparsl", "": "smeparsl", "": "eqvparsl", "": "lozf", "": "RuleDelayed", "": "dsol", "": "xodot", "": "xoplus", "": "xotime", "": "xuplus", "": "xsqcup", "": "fpartint", "": "cirfnint", "": "awint", "": "rppolint", "": "scpolint", "": "npolint", "": "pointint", "": "quatint", "": "intlarhk", "": "pluscir", "": "plusacir", "": "simplus", "": "plusdu", "": "plussim", "": "plustwo", "": "mcomma", "": "minusdu", "": "loplus", "": "roplus", "": "Cross", "": "timesd", "": "timesbar", "": "smashp", "": "lotimes", "": "rotimes", "": "otimesas", "": "Otimes", "": "odiv", "": "triplus", "": "triminus", "": "tritime", "": "iprod", "": "amalg", "": "capdot", "": "ncup", "": "ncap", "": "capand", "": "cupor", "": "cupcap", "": "capcup", "": "cupbrcap", "": "capbrcup", "": "cupcup", "": "capcap", "": "ccups", "": "ccaps", "": "ccupssm", "": "And", "": "Or", "": "andand", "": "oror", "": "orslope", "": "andslope", "": "andv", "": "orv", "": "andd", "": "ord", "": "wedbar", "": "sdote", "": "simdot", "": "congdot", "": "ncongdot", "": "easter", "": "apacir", "": "apE", "": "napE", "": "eplus", "": "pluse", "": "Esim", "": "eDDot", "": "equivDD", "": "ltcir", "": "gtcir", "": "ltquest", "": "gtquest", "": "les", "": "nles", "": "ges", "": "nges", "": "lesdot", "": "gesdot", "": "lesdoto", "": "gesdoto", "": "lesdotor", "": "gesdotol", "": "lap", "": "gap", "": "lne", "": "gne", "": "lnap", "": "gnap", "": "lEg", "": "gEl", "": "lsime", "": "gsime", "": "lsimg", "": "gsiml", "": "lgE", "": "glE", "": "lesges", "": "gesles", "": "els", "": "egs", "": "elsdot", "": "egsdot", "": "el", "": "eg", "": "siml", "": "simg", "": "simlE", "": "simgE", "": "LessLess", "": "NotNestedLessLess", "": "GreaterGreater", "": "NotNestedGreaterGreater", "": "glj", "": "gla", "": "ltcc", "": "gtcc", "": "lescc", "": "gescc", "": "smt", "": "lat", "": "smte", "": "smtes", "": "late", "": "lates", "": "bumpE", "": "pre", "": "npre", "": "sce", "": "nsce", "": "prE", "": "scE", "": "prnE", "": "scnE", "": "prap", "": "scap", "": "prnap", "": "scnap", "": "Pr", "": "Sc", "": "subdot", "": "supdot", "": "subplus", "": "supplus", "": "submult", "": "supmult", "": "subedot", "": "supedot", "": "subE", "": "nsubE", "": "supE", "": "nsupE", "": "subsim", "": "supsim", "": "vsubnE", "": "subnE", "": "vsupnE", "": "supnE", "": "csub", "": "csup", "": "csube", "": "csupe", "": "subsup", "": "supsub", "": "subsub", "": "supsup", "": "suphsub", "": "supdsub", "": "forkv", "": "topfork", "": "mlcp", "": "Dashv", "": "Vdashl", "": "Barv", "": "vBar", "": "vBarv", "": "Vbar", "": "Not", "": "bNot", "": "rnmid", "": "cirmid", "": "midcir", "": "topcir", "": "nhpar", "": "parsim", "": "parsl", "": "nparsl", "": "flat", "": "natur", "": "sharp", "": "curren", "": "cent", "$": "dollar", "": "pound", "": "yen", "": "euro", "": "sup1", "": "half", "": "frac13", "": "frac14", "": "frac15", "": "frac16", "": "frac18", "": "sup2", "": "frac23", "": "frac25", "": "sup3", "": "frac34", "": "frac35", "": "frac38", "": "frac45", "": "frac56", "": "frac58", "": "frac78", "": "ascr", "": "aopf", "": "afr", "": "Aopf", "": "Afr", "": "Ascr", "": "ordf", "": "aacute", "": "Aacute", "": "agrave", "": "Agrave", "": "abreve", "": "Abreve", "": "acirc", "": "Acirc", "": "aring", "": "angst", "": "auml", "": "Auml", "": "atilde", "": "Atilde", "": "aogon", "": "Aogon", "": "amacr", "": "Amacr", "": "aelig", "": "AElig", "": "bscr", "": "bopf", "": "bfr", "": "Bopf", "": "Bscr", "": "Bfr", "": "cfr", "": "cscr", "": "copf", "": "Cfr", "": "Cscr", "": "Copf", "": "cacute", "": "Cacute", "": "ccirc", "": "Ccirc", "": "ccaron", "": "Ccaron", "": "cdot", "": "Cdot", "": "ccedil", "": "Ccedil", "": "incare", "": "dfr", "": "dd", "": "dopf", "": "dscr", "": "Dscr", "": "Dfr", "": "DD", "": "Dopf", "": "dcaron", "": "Dcaron", "": "dstrok", "": "Dstrok", "": "eth", "": "ETH", "": "ee", "": "escr", "": "efr", "": "eopf", "": "Escr", "": "Efr", "": "Eopf", "": "eacute", "": "Eacute", "": "egrave", "": "Egrave", "": "ecirc", "": "Ecirc", "": "ecaron", "": "Ecaron", "": "euml", "": "Euml", "": "edot", "": "Edot", "": "eogon", "": "Eogon", "": "emacr", "": "Emacr", "": "ffr", "": "fopf", "": "fscr", "": "Ffr", "": "Fopf", "": "Fscr", "": "fflig", "": "ffilig", "": "ffllig", "": "filig", "fj": "fjlig", "": "fllig", "": "fnof", "": "gscr", "": "gopf", "": "gfr", "": "Gscr", "": "Gopf", "": "Gfr", "": "gacute", "": "gbreve", "": "Gbreve", "": "gcirc", "": "Gcirc", "": "gdot", "": "Gdot", "": "Gcedil", "": "hfr", "": "planckh", "": "hscr", "": "hopf", "": "Hscr", "": "Hfr", "": "Hopf", "": "hcirc", "": "Hcirc", "": "hbar", "": "hstrok", "": "Hstrok", "": "iopf", "": "ifr", "": "iscr", "": "ii", "": "Iopf", "": "Iscr", "": "Im", "": "iacute", "": "Iacute", "": "igrave", "": "Igrave", "": "icirc", "": "Icirc", "": "iuml", "": "Iuml", "": "itilde", "": "Itilde", "": "Idot", "": "iogon", "": "Iogon", "": "imacr", "": "Imacr", "": "ijlig", "": "IJlig", "": "imath", "": "jscr", "": "jopf", "": "jfr", "": "Jscr", "": "Jfr", "": "Jopf", "": "jcirc", "": "Jcirc", "": "jmath", "": "kopf", "": "kscr", "": "kfr", "": "Kscr", "": "Kopf", "": "Kfr", "": "kcedil", "": "Kcedil", "": "lfr", "": "lscr", "": "ell", "": "lopf", "": "Lscr", "": "Lfr", "": "Lopf", "": "lacute", "": "Lacute", "": "lcaron", "": "Lcaron", "": "lcedil", "": "Lcedil", "": "lstrok", "": "Lstrok", "": "lmidot", "": "Lmidot", "": "mfr", "": "mopf", "": "mscr", "": "Mfr", "": "Mopf", "": "Mscr", "": "nfr", "": "nopf", "": "nscr", "": "Nopf", "": "Nscr", "": "Nfr", "": "nacute", "": "Nacute", "": "ncaron", "": "Ncaron", "": "ntilde", "": "Ntilde", "": "ncedil", "": "Ncedil", "": "numero", "": "eng", "": "ENG", "": "oopf", "": "ofr", "": "oscr", "": "Oscr", "": "Ofr", "": "Oopf", "": "ordm", "": "oacute", "": "Oacute", "": "ograve", "": "Ograve", "": "ocirc", "": "Ocirc", "": "ouml", "": "Ouml", "": "odblac", "": "Odblac", "": "otilde", "": "Otilde", "": "oslash", "": "Oslash", "": "omacr", "": "Omacr", "": "oelig", "": "OElig", "": "pfr", "": "pscr", "": "popf", "": "Popf", "": "Pfr", "": "Pscr", "": "qopf", "": "qfr", "": "qscr", "": "Qscr", "": "Qfr", "": "Qopf", "": "kgreen", "": "rfr", "": "ropf", "": "rscr", "": "Rscr", "": "Re", "": "Ropf", "": "racute", "": "Racute", "": "rcaron", "": "Rcaron", "": "rcedil", "": "Rcedil", "": "sopf", "": "sscr", "": "sfr", "": "Sopf", "": "Sfr", "": "Sscr", "": "oS", "": "sacute", "": "Sacute", "": "scirc", "": "Scirc", "": "scaron", "": "Scaron", "": "scedil", "": "Scedil", "": "szlig", "": "tfr", "": "tscr", "": "topf", "": "Tscr", "": "Tfr", "": "Topf", "": "tcaron", "": "Tcaron", "": "tcedil", "": "Tcedil", "": "trade", "": "tstrok", "": "Tstrok", "": "uscr", "": "uopf", "": "ufr", "": "Uopf", "": "Ufr", "": "Uscr", "": "uacute", "": "Uacute", "": "ugrave", "": "Ugrave", "": "ubreve", "": "Ubreve", "": "ucirc", "": "Ucirc", "": "uring", "": "Uring", "": "uuml", "": "Uuml", "": "udblac", "": "Udblac", "": "utilde", "": "Utilde", "": "uogon", "": "Uogon", "": "umacr", "": "Umacr", "": "vfr", "": "vopf", "": "vscr", "": "Vfr", "": "Vopf", "": "Vscr", "": "wopf", "": "wscr", "": "wfr", "": "Wscr", "": "Wopf", "": "Wfr", "": "wcirc", "": "Wcirc", "": "xfr", "": "xscr", "": "xopf", "": "Xopf", "": "Xfr", "": "Xscr", "": "yfr", "": "yscr", "": "yopf", "": "Yscr", "": "Yfr", "": "Yopf", "": "yacute", "": "Yacute", "": "ycirc", "": "Ycirc", "": "yuml", "": "Yuml", "": "zscr", "": "zfr", "": "zopf", "": "Zfr", "": "Zopf", "": "Zscr", "": "zacute", "": "Zacute", "": "zcaron", "": "Zcaron", "": "zdot", "": "Zdot", "": "imped", "": "thorn", "": "THORN", "": "napos", "": "alpha", "": "Alpha", "": "beta", "": "Beta", "": "gamma", "": "Gamma", "": "delta", "": "Delta", "": "epsi", "": "epsiv", "": "Epsilon", "": "gammad", "": "Gammad", "": "zeta", "": "Zeta", "": "eta", "": "Eta", "": "theta", "": "thetav", "": "Theta", "": "iota", "": "Iota", "": "kappa", "": "kappav", "": "Kappa", "": "lambda", "": "Lambda", "": "mu", "": "micro", "": "Mu", "": "nu", "": "Nu", "": "xi", "": "Xi", "": "omicron", "": "Omicron", "": "pi", "": "piv", "": "Pi", "": "rho", "": "rhov", "": "Rho", "": "sigma", "": "Sigma", "": "sigmaf", "": "tau", "": "Tau", "": "upsi", "": "Upsilon", "": "Upsi", "": "phi", "": "phiv", "": "Phi", "": "chi", "": "Chi", "": "psi", "": "Psi", "": "omega", "": "ohm", "": "acy", "": "Acy", "": "bcy", "": "Bcy", "": "vcy", "": "Vcy", "": "gcy", "": "Gcy", "": "gjcy", "": "GJcy", "": "dcy", "": "Dcy", "": "djcy", "": "DJcy", "": "iecy", "": "IEcy", "": "iocy", "": "IOcy", "": "jukcy", "": "Jukcy", "": "zhcy", "": "ZHcy", "": "zcy", "": "Zcy", "": "dscy", "": "DScy", "": "icy", "": "Icy", "": "iukcy", "": "Iukcy", "": "yicy", "": "YIcy", "": "jcy", "": "Jcy", "": "jsercy", "": "Jsercy", "": "kcy", "": "Kcy", "": "kjcy", "": "KJcy", "": "lcy", "": "Lcy", "": "ljcy", "": "LJcy", "": "mcy", "": "Mcy", "": "ncy", "": "Ncy", "": "njcy", "": "NJcy", "": "ocy", "": "Ocy", "": "pcy", "": "Pcy", "": "rcy", "": "Rcy", "": "scy", "": "Scy", "": "tcy", "": "Tcy", "": "tshcy", "": "TSHcy", "": "ucy", "": "Ucy", "": "ubrcy", "": "Ubrcy", "": "fcy", "": "Fcy", "": "khcy", "": "KHcy", "": "tscy", "": "TScy", "": "chcy", "": "CHcy", "": "dzcy", "": "DZcy", "": "shcy", "": "SHcy", "": "shchcy", "": "SHCHcy", "": "hardcy", "": "HARDcy", "": "ycy", "": "Ycy", "": "softcy", "": "SOFTcy", "": "ecy", "": "Ecy", "": "yucy", "": "YUcy", "": "yacy", "": "YAcy", "": "aleph", "": "beth", "": "gimel", "": "daleth" };
      var regexEscape = /["&'<>`]/g;
      var escapeMap = {
        '"': "&quot;",
        "&": "&amp;",
        "'": "&#x27;",
        "<": "&lt;",
        // See https://mathiasbynens.be/notes/ambiguous-ampersands: in HTML, the
        // following is not strictly necessary unless its part of a tag or an
        // unquoted attribute value. Were only escaping it to support those
        // situations, and for XML support.
        ">": "&gt;",
        // In Internet Explorer  8, the backtick character can be used
        // to break out of (un)quoted attribute values or HTML comments.
        // See http://html5sec.org/#102, http://html5sec.org/#108, and
        // http://html5sec.org/#133.
        "`": "&#x60;"
      };
      var regexInvalidEntity = /&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/;
      var regexInvalidRawCodePoint = /[\0-\x08\x0B\x0E-\x1F\x7F-\x9F\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
      var regexDecode = /&(CounterClockwiseContourIntegral|DoubleLongLeftRightArrow|ClockwiseContourIntegral|NotNestedGreaterGreater|NotSquareSupersetEqual|DiacriticalDoubleAcute|NotRightTriangleEqual|NotSucceedsSlantEqual|NotPrecedesSlantEqual|CloseCurlyDoubleQuote|NegativeVeryThinSpace|DoubleContourIntegral|FilledVerySmallSquare|CapitalDifferentialD|OpenCurlyDoubleQuote|EmptyVerySmallSquare|NestedGreaterGreater|DoubleLongRightArrow|NotLeftTriangleEqual|NotGreaterSlantEqual|ReverseUpEquilibrium|DoubleLeftRightArrow|NotSquareSubsetEqual|NotDoubleVerticalBar|RightArrowLeftArrow|NotGreaterFullEqual|NotRightTriangleBar|SquareSupersetEqual|DownLeftRightVector|DoubleLongLeftArrow|leftrightsquigarrow|LeftArrowRightArrow|NegativeMediumSpace|blacktriangleright|RightDownVectorBar|PrecedesSlantEqual|RightDoubleBracket|SucceedsSlantEqual|NotLeftTriangleBar|RightTriangleEqual|SquareIntersection|RightDownTeeVector|ReverseEquilibrium|NegativeThickSpace|longleftrightarrow|Longleftrightarrow|LongLeftRightArrow|DownRightTeeVector|DownRightVectorBar|GreaterSlantEqual|SquareSubsetEqual|LeftDownVectorBar|LeftDoubleBracket|VerticalSeparator|rightleftharpoons|NotGreaterGreater|NotSquareSuperset|blacktriangleleft|blacktriangledown|NegativeThinSpace|LeftDownTeeVector|NotLessSlantEqual|leftrightharpoons|DoubleUpDownArrow|DoubleVerticalBar|LeftTriangleEqual|FilledSmallSquare|twoheadrightarrow|NotNestedLessLess|DownLeftTeeVector|DownLeftVectorBar|RightAngleBracket|NotTildeFullEqual|NotReverseElement|RightUpDownVector|DiacriticalTilde|NotSucceedsTilde|circlearrowright|NotPrecedesEqual|rightharpoondown|DoubleRightArrow|NotSucceedsEqual|NonBreakingSpace|NotRightTriangle|LessEqualGreater|RightUpTeeVector|LeftAngleBracket|GreaterFullEqual|DownArrowUpArrow|RightUpVectorBar|twoheadleftarrow|GreaterEqualLess|downharpoonright|RightTriangleBar|ntrianglerighteq|NotSupersetEqual|LeftUpDownVector|DiacriticalAcute|rightrightarrows|vartriangleright|UpArrowDownArrow|DiacriticalGrave|UnderParenthesis|EmptySmallSquare|LeftUpVectorBar|leftrightarrows|DownRightVector|downharpoonleft|trianglerighteq|ShortRightArrow|OverParenthesis|DoubleLeftArrow|DoubleDownArrow|NotSquareSubset|bigtriangledown|ntrianglelefteq|UpperRightArrow|curvearrowright|vartriangleleft|NotLeftTriangle|nleftrightarrow|LowerRightArrow|NotHumpDownHump|NotGreaterTilde|rightthreetimes|LeftUpTeeVector|NotGreaterEqual|straightepsilon|LeftTriangleBar|rightsquigarrow|ContourIntegral|rightleftarrows|CloseCurlyQuote|RightDownVector|LeftRightVector|nLeftrightarrow|leftharpoondown|circlearrowleft|SquareSuperset|OpenCurlyQuote|hookrightarrow|HorizontalLine|DiacriticalDot|NotLessGreater|ntriangleright|DoubleRightTee|InvisibleComma|InvisibleTimes|LowerLeftArrow|DownLeftVector|NotSubsetEqual|curvearrowleft|trianglelefteq|NotVerticalBar|TildeFullEqual|downdownarrows|NotGreaterLess|RightTeeVector|ZeroWidthSpace|looparrowright|LongRightArrow|doublebarwedge|ShortLeftArrow|ShortDownArrow|RightVectorBar|GreaterGreater|ReverseElement|rightharpoonup|LessSlantEqual|leftthreetimes|upharpoonright|rightarrowtail|LeftDownVector|Longrightarrow|NestedLessLess|UpperLeftArrow|nshortparallel|leftleftarrows|leftrightarrow|Leftrightarrow|LeftRightArrow|longrightarrow|upharpoonleft|RightArrowBar|ApplyFunction|LeftTeeVector|leftarrowtail|NotEqualTilde|varsubsetneqq|varsupsetneqq|RightTeeArrow|SucceedsEqual|SucceedsTilde|LeftVectorBar|SupersetEqual|hookleftarrow|DifferentialD|VerticalTilde|VeryThinSpace|blacktriangle|bigtriangleup|LessFullEqual|divideontimes|leftharpoonup|UpEquilibrium|ntriangleleft|RightTriangle|measuredangle|shortparallel|longleftarrow|Longleftarrow|LongLeftArrow|DoubleLeftTee|Poincareplane|PrecedesEqual|triangleright|DoubleUpArrow|RightUpVector|fallingdotseq|looparrowleft|PrecedesTilde|NotTildeEqual|NotTildeTilde|smallsetminus|Proportional|triangleleft|triangledown|UnderBracket|NotHumpEqual|exponentiale|ExponentialE|NotLessTilde|HilbertSpace|RightCeiling|blacklozenge|varsupsetneq|HumpDownHump|GreaterEqual|VerticalLine|LeftTeeArrow|NotLessEqual|DownTeeArrow|LeftTriangle|varsubsetneq|Intersection|NotCongruent|DownArrowBar|LeftUpVector|LeftArrowBar|risingdotseq|GreaterTilde|RoundImplies|SquareSubset|ShortUpArrow|NotSuperset|quaternions|precnapprox|backepsilon|preccurlyeq|OverBracket|blacksquare|MediumSpace|VerticalBar|circledcirc|circleddash|CircleMinus|CircleTimes|LessGreater|curlyeqprec|curlyeqsucc|diamondsuit|UpDownArrow|Updownarrow|RuleDelayed|Rrightarrow|updownarrow|RightVector|nRightarrow|nrightarrow|eqslantless|LeftCeiling|Equilibrium|SmallCircle|expectation|NotSucceeds|thickapprox|GreaterLess|SquareUnion|NotPrecedes|NotLessLess|straightphi|succnapprox|succcurlyeq|SubsetEqual|sqsupseteq|Proportion|Laplacetrf|ImaginaryI|supsetneqq|NotGreater|gtreqqless|NotElement|ThickSpace|TildeEqual|TildeTilde|Fouriertrf|rmoustache|EqualTilde|eqslantgtr|UnderBrace|LeftVector|UpArrowBar|nLeftarrow|nsubseteqq|subsetneqq|nsupseteqq|nleftarrow|succapprox|lessapprox|UpTeeArrow|upuparrows|curlywedge|lesseqqgtr|varepsilon|varnothing|RightFloor|complement|CirclePlus|sqsubseteq|Lleftarrow|circledast|RightArrow|Rightarrow|rightarrow|lmoustache|Bernoullis|precapprox|mapstoleft|mapstodown|longmapsto|dotsquare|downarrow|DoubleDot|nsubseteq|supsetneq|leftarrow|nsupseteq|subsetneq|ThinSpace|ngeqslant|subseteqq|HumpEqual|NotSubset|triangleq|NotCupCap|lesseqgtr|heartsuit|TripleDot|Leftarrow|Coproduct|Congruent|varpropto|complexes|gvertneqq|LeftArrow|LessTilde|supseteqq|MinusPlus|CircleDot|nleqslant|NotExists|gtreqless|nparallel|UnionPlus|LeftFloor|checkmark|CenterDot|centerdot|Mellintrf|gtrapprox|bigotimes|OverBrace|spadesuit|therefore|pitchfork|rationals|PlusMinus|Backslash|Therefore|DownBreve|backsimeq|backprime|DownArrow|nshortmid|Downarrow|lvertneqq|eqvparsl|imagline|imagpart|infintie|integers|Integral|intercal|LessLess|Uarrocir|intlarhk|sqsupset|angmsdaf|sqsubset|llcorner|vartheta|cupbrcap|lnapprox|Superset|SuchThat|succnsim|succneqq|angmsdag|biguplus|curlyvee|trpezium|Succeeds|NotTilde|bigwedge|angmsdah|angrtvbd|triminus|cwconint|fpartint|lrcorner|smeparsl|subseteq|urcorner|lurdshar|laemptyv|DDotrahd|approxeq|ldrushar|awconint|mapstoup|backcong|shortmid|triangle|geqslant|gesdotol|timesbar|circledR|circledS|setminus|multimap|naturals|scpolint|ncongdot|RightTee|boxminus|gnapprox|boxtimes|andslope|thicksim|angmsdaa|varsigma|cirfnint|rtriltri|angmsdab|rppolint|angmsdac|barwedge|drbkarow|clubsuit|thetasym|bsolhsub|capbrcup|dzigrarr|doteqdot|DotEqual|dotminus|UnderBar|NotEqual|realpart|otimesas|ulcorner|hksearow|hkswarow|parallel|PartialD|elinters|emptyset|plusacir|bbrktbrk|angmsdad|pointint|bigoplus|angmsdae|Precedes|bigsqcup|varkappa|notindot|supseteq|precneqq|precnsim|profalar|profline|profsurf|leqslant|lesdotor|raemptyv|subplus|notnivb|notnivc|subrarr|zigrarr|vzigzag|submult|subedot|Element|between|cirscir|larrbfs|larrsim|lotimes|lbrksld|lbrkslu|lozenge|ldrdhar|dbkarow|bigcirc|epsilon|simrarr|simplus|ltquest|Epsilon|luruhar|gtquest|maltese|npolint|eqcolon|npreceq|bigodot|ddagger|gtrless|bnequiv|harrcir|ddotseq|equivDD|backsim|demptyv|nsqsube|nsqsupe|Upsilon|nsubset|upsilon|minusdu|nsucceq|swarrow|nsupset|coloneq|searrow|boxplus|napprox|natural|asympeq|alefsym|congdot|nearrow|bigstar|diamond|supplus|tritime|LeftTee|nvinfin|triplus|NewLine|nvltrie|nvrtrie|nwarrow|nexists|Diamond|ruluhar|Implies|supmult|angzarr|suplarr|suphsub|questeq|because|digamma|Because|olcross|bemptyv|omicron|Omicron|rotimes|NoBreak|intprod|angrtvb|orderof|uwangle|suphsol|lesdoto|orslope|DownTee|realine|cudarrl|rdldhar|OverBar|supedot|lessdot|supdsub|topfork|succsim|rbrkslu|rbrksld|pertenk|cudarrr|isindot|planckh|lessgtr|pluscir|gesdoto|plussim|plustwo|lesssim|cularrp|rarrsim|Cayleys|notinva|notinvb|notinvc|UpArrow|Uparrow|uparrow|NotLess|dwangle|precsim|Product|curarrm|Cconint|dotplus|rarrbfs|ccupssm|Cedilla|cemptyv|notniva|quatint|frac35|frac38|frac45|frac56|frac58|frac78|tridot|xoplus|gacute|gammad|Gammad|lfisht|lfloor|bigcup|sqsupe|gbreve|Gbreve|lharul|sqsube|sqcups|Gcedil|apacir|llhard|lmidot|Lmidot|lmoust|andand|sqcaps|approx|Abreve|spades|circeq|tprime|divide|topcir|Assign|topbot|gesdot|divonx|xuplus|timesd|gesles|atilde|solbar|SOFTcy|loplus|timesb|lowast|lowbar|dlcorn|dlcrop|softcy|dollar|lparlt|thksim|lrhard|Atilde|lsaquo|smashp|bigvee|thinsp|wreath|bkarow|lsquor|lstrok|Lstrok|lthree|ltimes|ltlarr|DotDot|simdot|ltrPar|weierp|xsqcup|angmsd|sigmav|sigmaf|zeetrf|Zcaron|zcaron|mapsto|vsupne|thetav|cirmid|marker|mcomma|Zacute|vsubnE|there4|gtlPar|vsubne|bottom|gtrarr|SHCHcy|shchcy|midast|midcir|middot|minusb|minusd|gtrdot|bowtie|sfrown|mnplus|models|colone|seswar|Colone|mstpos|searhk|gtrsim|nacute|Nacute|boxbox|telrec|hairsp|Tcedil|nbumpe|scnsim|ncaron|Ncaron|ncedil|Ncedil|hamilt|Scedil|nearhk|hardcy|HARDcy|tcedil|Tcaron|commat|nequiv|nesear|tcaron|target|hearts|nexist|varrho|scedil|Scaron|scaron|hellip|Sacute|sacute|hercon|swnwar|compfn|rtimes|rthree|rsquor|rsaquo|zacute|wedgeq|homtht|barvee|barwed|Barwed|rpargt|horbar|conint|swarhk|roplus|nltrie|hslash|hstrok|Hstrok|rmoust|Conint|bprime|hybull|hyphen|iacute|Iacute|supsup|supsub|supsim|varphi|coprod|brvbar|agrave|Supset|supset|igrave|Igrave|notinE|Agrave|iiiint|iinfin|copysr|wedbar|Verbar|vangrt|becaus|incare|verbar|inodot|bullet|drcorn|intcal|drcrop|cularr|vellip|Utilde|bumpeq|cupcap|dstrok|Dstrok|CupCap|cupcup|cupdot|eacute|Eacute|supdot|iquest|easter|ecaron|Ecaron|ecolon|isinsv|utilde|itilde|Itilde|curarr|succeq|Bumpeq|cacute|ulcrop|nparsl|Cacute|nprcue|egrave|Egrave|nrarrc|nrarrw|subsup|subsub|nrtrie|jsercy|nsccue|Jsercy|kappav|kcedil|Kcedil|subsim|ulcorn|nsimeq|egsdot|veebar|kgreen|capand|elsdot|Subset|subset|curren|aacute|lacute|Lacute|emptyv|ntilde|Ntilde|lagran|lambda|Lambda|capcap|Ugrave|langle|subdot|emsp13|numero|emsp14|nvdash|nvDash|nVdash|nVDash|ugrave|ufisht|nvHarr|larrfs|nvlArr|larrhk|larrlp|larrpl|nvrArr|Udblac|nwarhk|larrtl|nwnear|oacute|Oacute|latail|lAtail|sstarf|lbrace|odblac|Odblac|lbrack|udblac|odsold|eparsl|lcaron|Lcaron|ograve|Ograve|lcedil|Lcedil|Aacute|ssmile|ssetmn|squarf|ldquor|capcup|ominus|cylcty|rharul|eqcirc|dagger|rfloor|rfisht|Dagger|daleth|equals|origof|capdot|equest|dcaron|Dcaron|rdquor|oslash|Oslash|otilde|Otilde|otimes|Otimes|urcrop|Ubreve|ubreve|Yacute|Uacute|uacute|Rcedil|rcedil|urcorn|parsim|Rcaron|Vdashl|rcaron|Tstrok|percnt|period|permil|Exists|yacute|rbrack|rbrace|phmmat|ccaron|Ccaron|planck|ccedil|plankv|tstrok|female|plusdo|plusdu|ffilig|plusmn|ffllig|Ccedil|rAtail|dfisht|bernou|ratail|Rarrtl|rarrtl|angsph|rarrpl|rarrlp|rarrhk|xwedge|xotime|forall|ForAll|Vvdash|vsupnE|preceq|bigcap|frac12|frac13|frac14|primes|rarrfs|prnsim|frac15|Square|frac16|square|lesdot|frac18|frac23|propto|prurel|rarrap|rangle|puncsp|frac25|Racute|qprime|racute|lesges|frac34|abreve|AElig|eqsim|utdot|setmn|urtri|Equal|Uring|seArr|uring|searr|dashv|Dashv|mumap|nabla|iogon|Iogon|sdote|sdotb|scsim|napid|napos|equiv|natur|Acirc|dblac|erarr|nbump|iprod|erDot|ucirc|awint|esdot|angrt|ncong|isinE|scnap|Scirc|scirc|ndash|isins|Ubrcy|nearr|neArr|isinv|nedot|ubrcy|acute|Ycirc|iukcy|Iukcy|xutri|nesim|caret|jcirc|Jcirc|caron|twixt|ddarr|sccue|exist|jmath|sbquo|ngeqq|angst|ccaps|lceil|ngsim|UpTee|delta|Delta|rtrif|nharr|nhArr|nhpar|rtrie|jukcy|Jukcy|kappa|rsquo|Kappa|nlarr|nlArr|TSHcy|rrarr|aogon|Aogon|fflig|xrarr|tshcy|ccirc|nleqq|filig|upsih|nless|dharl|nlsim|fjlig|ropar|nltri|dharr|robrk|roarr|fllig|fltns|roang|rnmid|subnE|subne|lAarr|trisb|Ccirc|acirc|ccups|blank|VDash|forkv|Vdash|langd|cedil|blk12|blk14|laquo|strns|diams|notin|vDash|larrb|blk34|block|disin|uplus|vdash|vBarv|aelig|starf|Wedge|check|xrArr|lates|lbarr|lBarr|notni|lbbrk|bcong|frasl|lbrke|frown|vrtri|vprop|vnsup|gamma|Gamma|wedge|xodot|bdquo|srarr|doteq|ldquo|boxdl|boxdL|gcirc|Gcirc|boxDl|boxDL|boxdr|boxdR|boxDr|TRADE|trade|rlhar|boxDR|vnsub|npart|vltri|rlarr|boxhd|boxhD|nprec|gescc|nrarr|nrArr|boxHd|boxHD|boxhu|boxhU|nrtri|boxHu|clubs|boxHU|times|colon|Colon|gimel|xlArr|Tilde|nsime|tilde|nsmid|nspar|THORN|thorn|xlarr|nsube|nsubE|thkap|xhArr|comma|nsucc|boxul|boxuL|nsupe|nsupE|gneqq|gnsim|boxUl|boxUL|grave|boxur|boxuR|boxUr|boxUR|lescc|angle|bepsi|boxvh|varpi|boxvH|numsp|Theta|gsime|gsiml|theta|boxVh|boxVH|boxvl|gtcir|gtdot|boxvL|boxVl|boxVL|crarr|cross|Cross|nvsim|boxvr|nwarr|nwArr|sqsup|dtdot|Uogon|lhard|lharu|dtrif|ocirc|Ocirc|lhblk|duarr|odash|sqsub|Hacek|sqcup|llarr|duhar|oelig|OElig|ofcir|boxvR|uogon|lltri|boxVr|csube|uuarr|ohbar|csupe|ctdot|olarr|olcir|harrw|oline|sqcap|omacr|Omacr|omega|Omega|boxVR|aleph|lneqq|lnsim|loang|loarr|rharu|lobrk|hcirc|operp|oplus|rhard|Hcirc|orarr|Union|order|ecirc|Ecirc|cuepr|szlig|cuesc|breve|reals|eDDot|Breve|hoarr|lopar|utrif|rdquo|Umacr|umacr|efDot|swArr|ultri|alpha|rceil|ovbar|swarr|Wcirc|wcirc|smtes|smile|bsemi|lrarr|aring|parsl|lrhar|bsime|uhblk|lrtri|cupor|Aring|uharr|uharl|slarr|rbrke|bsolb|lsime|rbbrk|RBarr|lsimg|phone|rBarr|rbarr|icirc|lsquo|Icirc|emacr|Emacr|ratio|simne|plusb|simlE|simgE|simeq|pluse|ltcir|ltdot|empty|xharr|xdtri|iexcl|Alpha|ltrie|rarrw|pound|ltrif|xcirc|bumpe|prcue|bumpE|asymp|amacr|cuvee|Sigma|sigma|iiint|udhar|iiota|ijlig|IJlig|supnE|imacr|Imacr|prime|Prime|image|prnap|eogon|Eogon|rarrc|mdash|mDDot|cuwed|imath|supne|imped|Amacr|udarr|prsim|micro|rarrb|cwint|raquo|infin|eplus|range|rangd|Ucirc|radic|minus|amalg|veeeq|rAarr|epsiv|ycirc|quest|sharp|quot|zwnj|Qscr|race|qscr|Qopf|qopf|qint|rang|Rang|Zscr|zscr|Zopf|zopf|rarr|rArr|Rarr|Pscr|pscr|prop|prod|prnE|prec|ZHcy|zhcy|prap|Zeta|zeta|Popf|popf|Zdot|plus|zdot|Yuml|yuml|phiv|YUcy|yucy|Yscr|yscr|perp|Yopf|yopf|part|para|YIcy|Ouml|rcub|yicy|YAcy|rdca|ouml|osol|Oscr|rdsh|yacy|real|oscr|xvee|andd|rect|andv|Xscr|oror|ordm|ordf|xscr|ange|aopf|Aopf|rHar|Xopf|opar|Oopf|xopf|xnis|rhov|oopf|omid|xmap|oint|apid|apos|ogon|ascr|Ascr|odot|odiv|xcup|xcap|ocir|oast|nvlt|nvle|nvgt|nvge|nvap|Wscr|wscr|auml|ntlg|ntgl|nsup|nsub|nsim|Nscr|nscr|nsce|Wopf|ring|npre|wopf|npar|Auml|Barv|bbrk|Nopf|nopf|nmid|nLtv|beta|ropf|Ropf|Beta|beth|nles|rpar|nleq|bnot|bNot|nldr|NJcy|rscr|Rscr|Vscr|vscr|rsqb|njcy|bopf|nisd|Bopf|rtri|Vopf|nGtv|ngtr|vopf|boxh|boxH|boxv|nges|ngeq|boxV|bscr|scap|Bscr|bsim|Vert|vert|bsol|bull|bump|caps|cdot|ncup|scnE|ncap|nbsp|napE|Cdot|cent|sdot|Vbar|nang|vBar|chcy|Mscr|mscr|sect|semi|CHcy|Mopf|mopf|sext|circ|cire|mldr|mlcp|cirE|comp|shcy|SHcy|vArr|varr|cong|copf|Copf|copy|COPY|malt|male|macr|lvnE|cscr|ltri|sime|ltcc|simg|Cscr|siml|csub|Uuml|lsqb|lsim|uuml|csup|Lscr|lscr|utri|smid|lpar|cups|smte|lozf|darr|Lopf|Uscr|solb|lopf|sopf|Sopf|lneq|uscr|spar|dArr|lnap|Darr|dash|Sqrt|LJcy|ljcy|lHar|dHar|Upsi|upsi|diam|lesg|djcy|DJcy|leqq|dopf|Dopf|dscr|Dscr|dscy|ldsh|ldca|squf|DScy|sscr|Sscr|dsol|lcub|late|star|Star|Uopf|Larr|lArr|larr|uopf|dtri|dzcy|sube|subE|Lang|lang|Kscr|kscr|Kopf|kopf|KJcy|kjcy|KHcy|khcy|DZcy|ecir|edot|eDot|Jscr|jscr|succ|Jopf|jopf|Edot|uHar|emsp|ensp|Iuml|iuml|eopf|isin|Iscr|iscr|Eopf|epar|sung|epsi|escr|sup1|sup2|sup3|Iota|iota|supe|supE|Iopf|iopf|IOcy|iocy|Escr|esim|Esim|imof|Uarr|QUOT|uArr|uarr|euml|IEcy|iecy|Idot|Euml|euro|excl|Hscr|hscr|Hopf|hopf|TScy|tscy|Tscr|hbar|tscr|flat|tbrk|fnof|hArr|harr|half|fopf|Fopf|tdot|gvnE|fork|trie|gtcc|fscr|Fscr|gdot|gsim|Gscr|gscr|Gopf|gopf|gneq|Gdot|tosa|gnap|Topf|topf|geqq|toea|GJcy|gjcy|tint|gesl|mid|Sfr|ggg|top|ges|gla|glE|glj|geq|gne|gEl|gel|gnE|Gcy|gcy|gap|Tfr|tfr|Tcy|tcy|Hat|Tau|Ffr|tau|Tab|hfr|Hfr|ffr|Fcy|fcy|icy|Icy|iff|ETH|eth|ifr|Ifr|Eta|eta|int|Int|Sup|sup|ucy|Ucy|Sum|sum|jcy|ENG|ufr|Ufr|eng|Jcy|jfr|els|ell|egs|Efr|efr|Jfr|uml|kcy|Kcy|Ecy|ecy|kfr|Kfr|lap|Sub|sub|lat|lcy|Lcy|leg|Dot|dot|lEg|leq|les|squ|div|die|lfr|Lfr|lgE|Dfr|dfr|Del|deg|Dcy|dcy|lne|lnE|sol|loz|smt|Cup|lrm|cup|lsh|Lsh|sim|shy|map|Map|mcy|Mcy|mfr|Mfr|mho|gfr|Gfr|sfr|cir|Chi|chi|nap|Cfr|vcy|Vcy|cfr|Scy|scy|ncy|Ncy|vee|Vee|Cap|cap|nfr|scE|sce|Nfr|nge|ngE|nGg|vfr|Vfr|ngt|bot|nGt|nis|niv|Rsh|rsh|nle|nlE|bne|Bfr|bfr|nLl|nlt|nLt|Bcy|bcy|not|Not|rlm|wfr|Wfr|npr|nsc|num|ocy|ast|Ocy|ofr|xfr|Xfr|Ofr|ogt|ohm|apE|olt|Rho|ape|rho|Rfr|rfr|ord|REG|ang|reg|orv|And|and|AMP|Rcy|amp|Afr|ycy|Ycy|yen|yfr|Yfr|rcy|par|pcy|Pcy|pfr|Pfr|phi|Phi|afr|Acy|acy|zcy|Zcy|piv|acE|acd|zfr|Zfr|pre|prE|psi|Psi|qfr|Qfr|zwj|Or|ge|Gg|gt|gg|el|oS|lt|Lt|LT|Re|lg|gl|eg|ne|Im|it|le|DD|wp|wr|nu|Nu|dd|lE|Sc|sc|pi|Pi|ee|af|ll|Ll|rx|gE|xi|pm|Xi|ic|pr|Pr|in|ni|mp|mu|ac|Mu|or|ap|Gt|GT|ii);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)(?!;)([=a-zA-Z0-9]?)|&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+)/g;
      var decodeMap = { "aacute": "", "Aacute": "", "abreve": "", "Abreve": "", "ac": "", "acd": "", "acE": "", "acirc": "", "Acirc": "", "acute": "", "acy": "", "Acy": "", "aelig": "", "AElig": "", "af": "", "afr": "", "Afr": "", "agrave": "", "Agrave": "", "alefsym": "", "aleph": "", "alpha": "", "Alpha": "", "amacr": "", "Amacr": "", "amalg": "", "amp": "&", "AMP": "&", "and": "", "And": "", "andand": "", "andd": "", "andslope": "", "andv": "", "ang": "", "ange": "", "angle": "", "angmsd": "", "angmsdaa": "", "angmsdab": "", "angmsdac": "", "angmsdad": "", "angmsdae": "", "angmsdaf": "", "angmsdag": "", "angmsdah": "", "angrt": "", "angrtvb": "", "angrtvbd": "", "angsph": "", "angst": "", "angzarr": "", "aogon": "", "Aogon": "", "aopf": "", "Aopf": "", "ap": "", "apacir": "", "ape": "", "apE": "", "apid": "", "apos": "'", "ApplyFunction": "", "approx": "", "approxeq": "", "aring": "", "Aring": "", "ascr": "", "Ascr": "", "Assign": "", "ast": "*", "asymp": "", "asympeq": "", "atilde": "", "Atilde": "", "auml": "", "Auml": "", "awconint": "", "awint": "", "backcong": "", "backepsilon": "", "backprime": "", "backsim": "", "backsimeq": "", "Backslash": "", "Barv": "", "barvee": "", "barwed": "", "Barwed": "", "barwedge": "", "bbrk": "", "bbrktbrk": "", "bcong": "", "bcy": "", "Bcy": "", "bdquo": "", "becaus": "", "because": "", "Because": "", "bemptyv": "", "bepsi": "", "bernou": "", "Bernoullis": "", "beta": "", "Beta": "", "beth": "", "between": "", "bfr": "", "Bfr": "", "bigcap": "", "bigcirc": "", "bigcup": "", "bigodot": "", "bigoplus": "", "bigotimes": "", "bigsqcup": "", "bigstar": "", "bigtriangledown": "", "bigtriangleup": "", "biguplus": "", "bigvee": "", "bigwedge": "", "bkarow": "", "blacklozenge": "", "blacksquare": "", "blacktriangle": "", "blacktriangledown": "", "blacktriangleleft": "", "blacktriangleright": "", "blank": "", "blk12": "", "blk14": "", "blk34": "", "block": "", "bne": "=", "bnequiv": "", "bnot": "", "bNot": "", "bopf": "", "Bopf": "", "bot": "", "bottom": "", "bowtie": "", "boxbox": "", "boxdl": "", "boxdL": "", "boxDl": "", "boxDL": "", "boxdr": "", "boxdR": "", "boxDr": "", "boxDR": "", "boxh": "", "boxH": "", "boxhd": "", "boxhD": "", "boxHd": "", "boxHD": "", "boxhu": "", "boxhU": "", "boxHu": "", "boxHU": "", "boxminus": "", "boxplus": "", "boxtimes": "", "boxul": "", "boxuL": "", "boxUl": "", "boxUL": "", "boxur": "", "boxuR": "", "boxUr": "", "boxUR": "", "boxv": "", "boxV": "", "boxvh": "", "boxvH": "", "boxVh": "", "boxVH": "", "boxvl": "", "boxvL": "", "boxVl": "", "boxVL": "", "boxvr": "", "boxvR": "", "boxVr": "", "boxVR": "", "bprime": "", "breve": "", "Breve": "", "brvbar": "", "bscr": "", "Bscr": "", "bsemi": "", "bsim": "", "bsime": "", "bsol": "\\", "bsolb": "", "bsolhsub": "", "bull": "", "bullet": "", "bump": "", "bumpe": "", "bumpE": "", "bumpeq": "", "Bumpeq": "", "cacute": "", "Cacute": "", "cap": "", "Cap": "", "capand": "", "capbrcup": "", "capcap": "", "capcup": "", "capdot": "", "CapitalDifferentialD": "", "caps": "", "caret": "", "caron": "", "Cayleys": "", "ccaps": "", "ccaron": "", "Ccaron": "", "ccedil": "", "Ccedil": "", "ccirc": "", "Ccirc": "", "Cconint": "", "ccups": "", "ccupssm": "", "cdot": "", "Cdot": "", "cedil": "", "Cedilla": "", "cemptyv": "", "cent": "", "centerdot": "", "CenterDot": "", "cfr": "", "Cfr": "", "chcy": "", "CHcy": "", "check": "", "checkmark": "", "chi": "", "Chi": "", "cir": "", "circ": "", "circeq": "", "circlearrowleft": "", "circlearrowright": "", "circledast": "", "circledcirc": "", "circleddash": "", "CircleDot": "", "circledR": "", "circledS": "", "CircleMinus": "", "CirclePlus": "", "CircleTimes": "", "cire": "", "cirE": "", "cirfnint": "", "cirmid": "", "cirscir": "", "ClockwiseContourIntegral": "", "CloseCurlyDoubleQuote": "", "CloseCurlyQuote": "", "clubs": "", "clubsuit": "", "colon": ":", "Colon": "", "colone": "", "Colone": "", "coloneq": "", "comma": ",", "commat": "@", "comp": "", "compfn": "", "complement": "", "complexes": "", "cong": "", "congdot": "", "Congruent": "", "conint": "", "Conint": "", "ContourIntegral": "", "copf": "", "Copf": "", "coprod": "", "Coproduct": "", "copy": "", "COPY": "", "copysr": "", "CounterClockwiseContourIntegral": "", "crarr": "", "cross": "", "Cross": "", "cscr": "", "Cscr": "", "csub": "", "csube": "", "csup": "", "csupe": "", "ctdot": "", "cudarrl": "", "cudarrr": "", "cuepr": "", "cuesc": "", "cularr": "", "cularrp": "", "cup": "", "Cup": "", "cupbrcap": "", "cupcap": "", "CupCap": "", "cupcup": "", "cupdot": "", "cupor": "", "cups": "", "curarr": "", "curarrm": "", "curlyeqprec": "", "curlyeqsucc": "", "curlyvee": "", "curlywedge": "", "curren": "", "curvearrowleft": "", "curvearrowright": "", "cuvee": "", "cuwed": "", "cwconint": "", "cwint": "", "cylcty": "", "dagger": "", "Dagger": "", "daleth": "", "darr": "", "dArr": "", "Darr": "", "dash": "", "dashv": "", "Dashv": "", "dbkarow": "", "dblac": "", "dcaron": "", "Dcaron": "", "dcy": "", "Dcy": "", "dd": "", "DD": "", "ddagger": "", "ddarr": "", "DDotrahd": "", "ddotseq": "", "deg": "", "Del": "", "delta": "", "Delta": "", "demptyv": "", "dfisht": "", "dfr": "", "Dfr": "", "dHar": "", "dharl": "", "dharr": "", "DiacriticalAcute": "", "DiacriticalDot": "", "DiacriticalDoubleAcute": "", "DiacriticalGrave": "`", "DiacriticalTilde": "", "diam": "", "diamond": "", "Diamond": "", "diamondsuit": "", "diams": "", "die": "", "DifferentialD": "", "digamma": "", "disin": "", "div": "", "divide": "", "divideontimes": "", "divonx": "", "djcy": "", "DJcy": "", "dlcorn": "", "dlcrop": "", "dollar": "$", "dopf": "", "Dopf": "", "dot": "", "Dot": "", "DotDot": "", "doteq": "", "doteqdot": "", "DotEqual": "", "dotminus": "", "dotplus": "", "dotsquare": "", "doublebarwedge": "", "DoubleContourIntegral": "", "DoubleDot": "", "DoubleDownArrow": "", "DoubleLeftArrow": "", "DoubleLeftRightArrow": "", "DoubleLeftTee": "", "DoubleLongLeftArrow": "", "DoubleLongLeftRightArrow": "", "DoubleLongRightArrow": "", "DoubleRightArrow": "", "DoubleRightTee": "", "DoubleUpArrow": "", "DoubleUpDownArrow": "", "DoubleVerticalBar": "", "downarrow": "", "Downarrow": "", "DownArrow": "", "DownArrowBar": "", "DownArrowUpArrow": "", "DownBreve": "", "downdownarrows": "", "downharpoonleft": "", "downharpoonright": "", "DownLeftRightVector": "", "DownLeftTeeVector": "", "DownLeftVector": "", "DownLeftVectorBar": "", "DownRightTeeVector": "", "DownRightVector": "", "DownRightVectorBar": "", "DownTee": "", "DownTeeArrow": "", "drbkarow": "", "drcorn": "", "drcrop": "", "dscr": "", "Dscr": "", "dscy": "", "DScy": "", "dsol": "", "dstrok": "", "Dstrok": "", "dtdot": "", "dtri": "", "dtrif": "", "duarr": "", "duhar": "", "dwangle": "", "dzcy": "", "DZcy": "", "dzigrarr": "", "eacute": "", "Eacute": "", "easter": "", "ecaron": "", "Ecaron": "", "ecir": "", "ecirc": "", "Ecirc": "", "ecolon": "", "ecy": "", "Ecy": "", "eDDot": "", "edot": "", "eDot": "", "Edot": "", "ee": "", "efDot": "", "efr": "", "Efr": "", "eg": "", "egrave": "", "Egrave": "", "egs": "", "egsdot": "", "el": "", "Element": "", "elinters": "", "ell": "", "els": "", "elsdot": "", "emacr": "", "Emacr": "", "empty": "", "emptyset": "", "EmptySmallSquare": "", "emptyv": "", "EmptyVerySmallSquare": "", "emsp": "", "emsp13": "", "emsp14": "", "eng": "", "ENG": "", "ensp": "", "eogon": "", "Eogon": "", "eopf": "", "Eopf": "", "epar": "", "eparsl": "", "eplus": "", "epsi": "", "epsilon": "", "Epsilon": "", "epsiv": "", "eqcirc": "", "eqcolon": "", "eqsim": "", "eqslantgtr": "", "eqslantless": "", "Equal": "", "equals": "=", "EqualTilde": "", "equest": "", "Equilibrium": "", "equiv": "", "equivDD": "", "eqvparsl": "", "erarr": "", "erDot": "", "escr": "", "Escr": "", "esdot": "", "esim": "", "Esim": "", "eta": "", "Eta": "", "eth": "", "ETH": "", "euml": "", "Euml": "", "euro": "", "excl": "!", "exist": "", "Exists": "", "expectation": "", "exponentiale": "", "ExponentialE": "", "fallingdotseq": "", "fcy": "", "Fcy": "", "female": "", "ffilig": "", "fflig": "", "ffllig": "", "ffr": "", "Ffr": "", "filig": "", "FilledSmallSquare": "", "FilledVerySmallSquare": "", "fjlig": "fj", "flat": "", "fllig": "", "fltns": "", "fnof": "", "fopf": "", "Fopf": "", "forall": "", "ForAll": "", "fork": "", "forkv": "", "Fouriertrf": "", "fpartint": "", "frac12": "", "frac13": "", "frac14": "", "frac15": "", "frac16": "", "frac18": "", "frac23": "", "frac25": "", "frac34": "", "frac35": "", "frac38": "", "frac45": "", "frac56": "", "frac58": "", "frac78": "", "frasl": "", "frown": "", "fscr": "", "Fscr": "", "gacute": "", "gamma": "", "Gamma": "", "gammad": "", "Gammad": "", "gap": "", "gbreve": "", "Gbreve": "", "Gcedil": "", "gcirc": "", "Gcirc": "", "gcy": "", "Gcy": "", "gdot": "", "Gdot": "", "ge": "", "gE": "", "gel": "", "gEl": "", "geq": "", "geqq": "", "geqslant": "", "ges": "", "gescc": "", "gesdot": "", "gesdoto": "", "gesdotol": "", "gesl": "", "gesles": "", "gfr": "", "Gfr": "", "gg": "", "Gg": "", "ggg": "", "gimel": "", "gjcy": "", "GJcy": "", "gl": "", "gla": "", "glE": "", "glj": "", "gnap": "", "gnapprox": "", "gne": "", "gnE": "", "gneq": "", "gneqq": "", "gnsim": "", "gopf": "", "Gopf": "", "grave": "`", "GreaterEqual": "", "GreaterEqualLess": "", "GreaterFullEqual": "", "GreaterGreater": "", "GreaterLess": "", "GreaterSlantEqual": "", "GreaterTilde": "", "gscr": "", "Gscr": "", "gsim": "", "gsime": "", "gsiml": "", "gt": ">", "Gt": "", "GT": ">", "gtcc": "", "gtcir": "", "gtdot": "", "gtlPar": "", "gtquest": "", "gtrapprox": "", "gtrarr": "", "gtrdot": "", "gtreqless": "", "gtreqqless": "", "gtrless": "", "gtrsim": "", "gvertneqq": "", "gvnE": "", "Hacek": "", "hairsp": "", "half": "", "hamilt": "", "hardcy": "", "HARDcy": "", "harr": "", "hArr": "", "harrcir": "", "harrw": "", "Hat": "^", "hbar": "", "hcirc": "", "Hcirc": "", "hearts": "", "heartsuit": "", "hellip": "", "hercon": "", "hfr": "", "Hfr": "", "HilbertSpace": "", "hksearow": "", "hkswarow": "", "hoarr": "", "homtht": "", "hookleftarrow": "", "hookrightarrow": "", "hopf": "", "Hopf": "", "horbar": "", "HorizontalLine": "", "hscr": "", "Hscr": "", "hslash": "", "hstrok": "", "Hstrok": "", "HumpDownHump": "", "HumpEqual": "", "hybull": "", "hyphen": "", "iacute": "", "Iacute": "", "ic": "", "icirc": "", "Icirc": "", "icy": "", "Icy": "", "Idot": "", "iecy": "", "IEcy": "", "iexcl": "", "iff": "", "ifr": "", "Ifr": "", "igrave": "", "Igrave": "", "ii": "", "iiiint": "", "iiint": "", "iinfin": "", "iiota": "", "ijlig": "", "IJlig": "", "Im": "", "imacr": "", "Imacr": "", "image": "", "ImaginaryI": "", "imagline": "", "imagpart": "", "imath": "", "imof": "", "imped": "", "Implies": "", "in": "", "incare": "", "infin": "", "infintie": "", "inodot": "", "int": "", "Int": "", "intcal": "", "integers": "", "Integral": "", "intercal": "", "Intersection": "", "intlarhk": "", "intprod": "", "InvisibleComma": "", "InvisibleTimes": "", "iocy": "", "IOcy": "", "iogon": "", "Iogon": "", "iopf": "", "Iopf": "", "iota": "", "Iota": "", "iprod": "", "iquest": "", "iscr": "", "Iscr": "", "isin": "", "isindot": "", "isinE": "", "isins": "", "isinsv": "", "isinv": "", "it": "", "itilde": "", "Itilde": "", "iukcy": "", "Iukcy": "", "iuml": "", "Iuml": "", "jcirc": "", "Jcirc": "", "jcy": "", "Jcy": "", "jfr": "", "Jfr": "", "jmath": "", "jopf": "", "Jopf": "", "jscr": "", "Jscr": "", "jsercy": "", "Jsercy": "", "jukcy": "", "Jukcy": "", "kappa": "", "Kappa": "", "kappav": "", "kcedil": "", "Kcedil": "", "kcy": "", "Kcy": "", "kfr": "", "Kfr": "", "kgreen": "", "khcy": "", "KHcy": "", "kjcy": "", "KJcy": "", "kopf": "", "Kopf": "", "kscr": "", "Kscr": "", "lAarr": "", "lacute": "", "Lacute": "", "laemptyv": "", "lagran": "", "lambda": "", "Lambda": "", "lang": "", "Lang": "", "langd": "", "langle": "", "lap": "", "Laplacetrf": "", "laquo": "", "larr": "", "lArr": "", "Larr": "", "larrb": "", "larrbfs": "", "larrfs": "", "larrhk": "", "larrlp": "", "larrpl": "", "larrsim": "", "larrtl": "", "lat": "", "latail": "", "lAtail": "", "late": "", "lates": "", "lbarr": "", "lBarr": "", "lbbrk": "", "lbrace": "{", "lbrack": "[", "lbrke": "", "lbrksld": "", "lbrkslu": "", "lcaron": "", "Lcaron": "", "lcedil": "", "Lcedil": "", "lceil": "", "lcub": "{", "lcy": "", "Lcy": "", "ldca": "", "ldquo": "", "ldquor": "", "ldrdhar": "", "ldrushar": "", "ldsh": "", "le": "", "lE": "", "LeftAngleBracket": "", "leftarrow": "", "Leftarrow": "", "LeftArrow": "", "LeftArrowBar": "", "LeftArrowRightArrow": "", "leftarrowtail": "", "LeftCeiling": "", "LeftDoubleBracket": "", "LeftDownTeeVector": "", "LeftDownVector": "", "LeftDownVectorBar": "", "LeftFloor": "", "leftharpoondown": "", "leftharpoonup": "", "leftleftarrows": "", "leftrightarrow": "", "Leftrightarrow": "", "LeftRightArrow": "", "leftrightarrows": "", "leftrightharpoons": "", "leftrightsquigarrow": "", "LeftRightVector": "", "LeftTee": "", "LeftTeeArrow": "", "LeftTeeVector": "", "leftthreetimes": "", "LeftTriangle": "", "LeftTriangleBar": "", "LeftTriangleEqual": "", "LeftUpDownVector": "", "LeftUpTeeVector": "", "LeftUpVector": "", "LeftUpVectorBar": "", "LeftVector": "", "LeftVectorBar": "", "leg": "", "lEg": "", "leq": "", "leqq": "", "leqslant": "", "les": "", "lescc": "", "lesdot": "", "lesdoto": "", "lesdotor": "", "lesg": "", "lesges": "", "lessapprox": "", "lessdot": "", "lesseqgtr": "", "lesseqqgtr": "", "LessEqualGreater": "", "LessFullEqual": "", "LessGreater": "", "lessgtr": "", "LessLess": "", "lesssim": "", "LessSlantEqual": "", "LessTilde": "", "lfisht": "", "lfloor": "", "lfr": "", "Lfr": "", "lg": "", "lgE": "", "lHar": "", "lhard": "", "lharu": "", "lharul": "", "lhblk": "", "ljcy": "", "LJcy": "", "ll": "", "Ll": "", "llarr": "", "llcorner": "", "Lleftarrow": "", "llhard": "", "lltri": "", "lmidot": "", "Lmidot": "", "lmoust": "", "lmoustache": "", "lnap": "", "lnapprox": "", "lne": "", "lnE": "", "lneq": "", "lneqq": "", "lnsim": "", "loang": "", "loarr": "", "lobrk": "", "longleftarrow": "", "Longleftarrow": "", "LongLeftArrow": "", "longleftrightarrow": "", "Longleftrightarrow": "", "LongLeftRightArrow": "", "longmapsto": "", "longrightarrow": "", "Longrightarrow": "", "LongRightArrow": "", "looparrowleft": "", "looparrowright": "", "lopar": "", "lopf": "", "Lopf": "", "loplus": "", "lotimes": "", "lowast": "", "lowbar": "_", "LowerLeftArrow": "", "LowerRightArrow": "", "loz": "", "lozenge": "", "lozf": "", "lpar": "(", "lparlt": "", "lrarr": "", "lrcorner": "", "lrhar": "", "lrhard": "", "lrm": "", "lrtri": "", "lsaquo": "", "lscr": "", "Lscr": "", "lsh": "", "Lsh": "", "lsim": "", "lsime": "", "lsimg": "", "lsqb": "[", "lsquo": "", "lsquor": "", "lstrok": "", "Lstrok": "", "lt": "<", "Lt": "", "LT": "<", "ltcc": "", "ltcir": "", "ltdot": "", "lthree": "", "ltimes": "", "ltlarr": "", "ltquest": "", "ltri": "", "ltrie": "", "ltrif": "", "ltrPar": "", "lurdshar": "", "luruhar": "", "lvertneqq": "", "lvnE": "", "macr": "", "male": "", "malt": "", "maltese": "", "map": "", "Map": "", "mapsto": "", "mapstodown": "", "mapstoleft": "", "mapstoup": "", "marker": "", "mcomma": "", "mcy": "", "Mcy": "", "mdash": "", "mDDot": "", "measuredangle": "", "MediumSpace": "", "Mellintrf": "", "mfr": "", "Mfr": "", "mho": "", "micro": "", "mid": "", "midast": "*", "midcir": "", "middot": "", "minus": "", "minusb": "", "minusd": "", "minusdu": "", "MinusPlus": "", "mlcp": "", "mldr": "", "mnplus": "", "models": "", "mopf": "", "Mopf": "", "mp": "", "mscr": "", "Mscr": "", "mstpos": "", "mu": "", "Mu": "", "multimap": "", "mumap": "", "nabla": "", "nacute": "", "Nacute": "", "nang": "", "nap": "", "napE": "", "napid": "", "napos": "", "napprox": "", "natur": "", "natural": "", "naturals": "", "nbsp": "", "nbump": "", "nbumpe": "", "ncap": "", "ncaron": "", "Ncaron": "", "ncedil": "", "Ncedil": "", "ncong": "", "ncongdot": "", "ncup": "", "ncy": "", "Ncy": "", "ndash": "", "ne": "", "nearhk": "", "nearr": "", "neArr": "", "nearrow": "", "nedot": "", "NegativeMediumSpace": "", "NegativeThickSpace": "", "NegativeThinSpace": "", "NegativeVeryThinSpace": "", "nequiv": "", "nesear": "", "nesim": "", "NestedGreaterGreater": "", "NestedLessLess": "", "NewLine": "\n", "nexist": "", "nexists": "", "nfr": "", "Nfr": "", "nge": "", "ngE": "", "ngeq": "", "ngeqq": "", "ngeqslant": "", "nges": "", "nGg": "", "ngsim": "", "ngt": "", "nGt": "", "ngtr": "", "nGtv": "", "nharr": "", "nhArr": "", "nhpar": "", "ni": "", "nis": "", "nisd": "", "niv": "", "njcy": "", "NJcy": "", "nlarr": "", "nlArr": "", "nldr": "", "nle": "", "nlE": "", "nleftarrow": "", "nLeftarrow": "", "nleftrightarrow": "", "nLeftrightarrow": "", "nleq": "", "nleqq": "", "nleqslant": "", "nles": "", "nless": "", "nLl": "", "nlsim": "", "nlt": "", "nLt": "", "nltri": "", "nltrie": "", "nLtv": "", "nmid": "", "NoBreak": "", "NonBreakingSpace": "", "nopf": "", "Nopf": "", "not": "", "Not": "", "NotCongruent": "", "NotCupCap": "", "NotDoubleVerticalBar": "", "NotElement": "", "NotEqual": "", "NotEqualTilde": "", "NotExists": "", "NotGreater": "", "NotGreaterEqual": "", "NotGreaterFullEqual": "", "NotGreaterGreater": "", "NotGreaterLess": "", "NotGreaterSlantEqual": "", "NotGreaterTilde": "", "NotHumpDownHump": "", "NotHumpEqual": "", "notin": "", "notindot": "", "notinE": "", "notinva": "", "notinvb": "", "notinvc": "", "NotLeftTriangle": "", "NotLeftTriangleBar": "", "NotLeftTriangleEqual": "", "NotLess": "", "NotLessEqual": "", "NotLessGreater": "", "NotLessLess": "", "NotLessSlantEqual": "", "NotLessTilde": "", "NotNestedGreaterGreater": "", "NotNestedLessLess": "", "notni": "", "notniva": "", "notnivb": "", "notnivc": "", "NotPrecedes": "", "NotPrecedesEqual": "", "NotPrecedesSlantEqual": "", "NotReverseElement": "", "NotRightTriangle": "", "NotRightTriangleBar": "", "NotRightTriangleEqual": "", "NotSquareSubset": "", "NotSquareSubsetEqual": "", "NotSquareSuperset": "", "NotSquareSupersetEqual": "", "NotSubset": "", "NotSubsetEqual": "", "NotSucceeds": "", "NotSucceedsEqual": "", "NotSucceedsSlantEqual": "", "NotSucceedsTilde": "", "NotSuperset": "", "NotSupersetEqual": "", "NotTilde": "", "NotTildeEqual": "", "NotTildeFullEqual": "", "NotTildeTilde": "", "NotVerticalBar": "", "npar": "", "nparallel": "", "nparsl": "", "npart": "", "npolint": "", "npr": "", "nprcue": "", "npre": "", "nprec": "", "npreceq": "", "nrarr": "", "nrArr": "", "nrarrc": "", "nrarrw": "", "nrightarrow": "", "nRightarrow": "", "nrtri": "", "nrtrie": "", "nsc": "", "nsccue": "", "nsce": "", "nscr": "", "Nscr": "", "nshortmid": "", "nshortparallel": "", "nsim": "", "nsime": "", "nsimeq": "", "nsmid": "", "nspar": "", "nsqsube": "", "nsqsupe": "", "nsub": "", "nsube": "", "nsubE": "", "nsubset": "", "nsubseteq": "", "nsubseteqq": "", "nsucc": "", "nsucceq": "", "nsup": "", "nsupe": "", "nsupE": "", "nsupset": "", "nsupseteq": "", "nsupseteqq": "", "ntgl": "", "ntilde": "", "Ntilde": "", "ntlg": "", "ntriangleleft": "", "ntrianglelefteq": "", "ntriangleright": "", "ntrianglerighteq": "", "nu": "", "Nu": "", "num": "#", "numero": "", "numsp": "", "nvap": "", "nvdash": "", "nvDash": "", "nVdash": "", "nVDash": "", "nvge": "", "nvgt": ">", "nvHarr": "", "nvinfin": "", "nvlArr": "", "nvle": "", "nvlt": "<", "nvltrie": "", "nvrArr": "", "nvrtrie": "", "nvsim": "", "nwarhk": "", "nwarr": "", "nwArr": "", "nwarrow": "", "nwnear": "", "oacute": "", "Oacute": "", "oast": "", "ocir": "", "ocirc": "", "Ocirc": "", "ocy": "", "Ocy": "", "odash": "", "odblac": "", "Odblac": "", "odiv": "", "odot": "", "odsold": "", "oelig": "", "OElig": "", "ofcir": "", "ofr": "", "Ofr": "", "ogon": "", "ograve": "", "Ograve": "", "ogt": "", "ohbar": "", "ohm": "", "oint": "", "olarr": "", "olcir": "", "olcross": "", "oline": "", "olt": "", "omacr": "", "Omacr": "", "omega": "", "Omega": "", "omicron": "", "Omicron": "", "omid": "", "ominus": "", "oopf": "", "Oopf": "", "opar": "", "OpenCurlyDoubleQuote": "", "OpenCurlyQuote": "", "operp": "", "oplus": "", "or": "", "Or": "", "orarr": "", "ord": "", "order": "", "orderof": "", "ordf": "", "ordm": "", "origof": "", "oror": "", "orslope": "", "orv": "", "oS": "", "oscr": "", "Oscr": "", "oslash": "", "Oslash": "", "osol": "", "otilde": "", "Otilde": "", "otimes": "", "Otimes": "", "otimesas": "", "ouml": "", "Ouml": "", "ovbar": "", "OverBar": "", "OverBrace": "", "OverBracket": "", "OverParenthesis": "", "par": "", "para": "", "parallel": "", "parsim": "", "parsl": "", "part": "", "PartialD": "", "pcy": "", "Pcy": "", "percnt": "%", "period": ".", "permil": "", "perp": "", "pertenk": "", "pfr": "", "Pfr": "", "phi": "", "Phi": "", "phiv": "", "phmmat": "", "phone": "", "pi": "", "Pi": "", "pitchfork": "", "piv": "", "planck": "", "planckh": "", "plankv": "", "plus": "+", "plusacir": "", "plusb": "", "pluscir": "", "plusdo": "", "plusdu": "", "pluse": "", "PlusMinus": "", "plusmn": "", "plussim": "", "plustwo": "", "pm": "", "Poincareplane": "", "pointint": "", "popf": "", "Popf": "", "pound": "", "pr": "", "Pr": "", "prap": "", "prcue": "", "pre": "", "prE": "", "prec": "", "precapprox": "", "preccurlyeq": "", "Precedes": "", "PrecedesEqual": "", "PrecedesSlantEqual": "", "PrecedesTilde": "", "preceq": "", "precnapprox": "", "precneqq": "", "precnsim": "", "precsim": "", "prime": "", "Prime": "", "primes": "", "prnap": "", "prnE": "", "prnsim": "", "prod": "", "Product": "", "profalar": "", "profline": "", "profsurf": "", "prop": "", "Proportion": "", "Proportional": "", "propto": "", "prsim": "", "prurel": "", "pscr": "", "Pscr": "", "psi": "", "Psi": "", "puncsp": "", "qfr": "", "Qfr": "", "qint": "", "qopf": "", "Qopf": "", "qprime": "", "qscr": "", "Qscr": "", "quaternions": "", "quatint": "", "quest": "?", "questeq": "", "quot": '"', "QUOT": '"', "rAarr": "", "race": "", "racute": "", "Racute": "", "radic": "", "raemptyv": "", "rang": "", "Rang": "", "rangd": "", "range": "", "rangle": "", "raquo": "", "rarr": "", "rArr": "", "Rarr": "", "rarrap": "", "rarrb": "", "rarrbfs": "", "rarrc": "", "rarrfs": "", "rarrhk": "", "rarrlp": "", "rarrpl": "", "rarrsim": "", "rarrtl": "", "Rarrtl": "", "rarrw": "", "ratail": "", "rAtail": "", "ratio": "", "rationals": "", "rbarr": "", "rBarr": "", "RBarr": "", "rbbrk": "", "rbrace": "}", "rbrack": "]", "rbrke": "", "rbrksld": "", "rbrkslu": "", "rcaron": "", "Rcaron": "", "rcedil": "", "Rcedil": "", "rceil": "", "rcub": "}", "rcy": "", "Rcy": "", "rdca": "", "rdldhar": "", "rdquo": "", "rdquor": "", "rdsh": "", "Re": "", "real": "", "realine": "", "realpart": "", "reals": "", "rect": "", "reg": "", "REG": "", "ReverseElement": "", "ReverseEquilibrium": "", "ReverseUpEquilibrium": "", "rfisht": "", "rfloor": "", "rfr": "", "Rfr": "", "rHar": "", "rhard": "", "rharu": "", "rharul": "", "rho": "", "Rho": "", "rhov": "", "RightAngleBracket": "", "rightarrow": "", "Rightarrow": "", "RightArrow": "", "RightArrowBar": "", "RightArrowLeftArrow": "", "rightarrowtail": "", "RightCeiling": "", "RightDoubleBracket": "", "RightDownTeeVector": "", "RightDownVector": "", "RightDownVectorBar": "", "RightFloor": "", "rightharpoondown": "", "rightharpoonup": "", "rightleftarrows": "", "rightleftharpoons": "", "rightrightarrows": "", "rightsquigarrow": "", "RightTee": "", "RightTeeArrow": "", "RightTeeVector": "", "rightthreetimes": "", "RightTriangle": "", "RightTriangleBar": "", "RightTriangleEqual": "", "RightUpDownVector": "", "RightUpTeeVector": "", "RightUpVector": "", "RightUpVectorBar": "", "RightVector": "", "RightVectorBar": "", "ring": "", "risingdotseq": "", "rlarr": "", "rlhar": "", "rlm": "", "rmoust": "", "rmoustache": "", "rnmid": "", "roang": "", "roarr": "", "robrk": "", "ropar": "", "ropf": "", "Ropf": "", "roplus": "", "rotimes": "", "RoundImplies": "", "rpar": ")", "rpargt": "", "rppolint": "", "rrarr": "", "Rrightarrow": "", "rsaquo": "", "rscr": "", "Rscr": "", "rsh": "", "Rsh": "", "rsqb": "]", "rsquo": "", "rsquor": "", "rthree": "", "rtimes": "", "rtri": "", "rtrie": "", "rtrif": "", "rtriltri": "", "RuleDelayed": "", "ruluhar": "", "rx": "", "sacute": "", "Sacute": "", "sbquo": "", "sc": "", "Sc": "", "scap": "", "scaron": "", "Scaron": "", "sccue": "", "sce": "", "scE": "", "scedil": "", "Scedil": "", "scirc": "", "Scirc": "", "scnap": "", "scnE": "", "scnsim": "", "scpolint": "", "scsim": "", "scy": "", "Scy": "", "sdot": "", "sdotb": "", "sdote": "", "searhk": "", "searr": "", "seArr": "", "searrow": "", "sect": "", "semi": ";", "seswar": "", "setminus": "", "setmn": "", "sext": "", "sfr": "", "Sfr": "", "sfrown": "", "sharp": "", "shchcy": "", "SHCHcy": "", "shcy": "", "SHcy": "", "ShortDownArrow": "", "ShortLeftArrow": "", "shortmid": "", "shortparallel": "", "ShortRightArrow": "", "ShortUpArrow": "", "shy": "", "sigma": "", "Sigma": "", "sigmaf": "", "sigmav": "", "sim": "", "simdot": "", "sime": "", "simeq": "", "simg": "", "simgE": "", "siml": "", "simlE": "", "simne": "", "simplus": "", "simrarr": "", "slarr": "", "SmallCircle": "", "smallsetminus": "", "smashp": "", "smeparsl": "", "smid": "", "smile": "", "smt": "", "smte": "", "smtes": "", "softcy": "", "SOFTcy": "", "sol": "/", "solb": "", "solbar": "", "sopf": "", "Sopf": "", "spades": "", "spadesuit": "", "spar": "", "sqcap": "", "sqcaps": "", "sqcup": "", "sqcups": "", "Sqrt": "", "sqsub": "", "sqsube": "", "sqsubset": "", "sqsubseteq": "", "sqsup": "", "sqsupe": "", "sqsupset": "", "sqsupseteq": "", "squ": "", "square": "", "Square": "", "SquareIntersection": "", "SquareSubset": "", "SquareSubsetEqual": "", "SquareSuperset": "", "SquareSupersetEqual": "", "SquareUnion": "", "squarf": "", "squf": "", "srarr": "", "sscr": "", "Sscr": "", "ssetmn": "", "ssmile": "", "sstarf": "", "star": "", "Star": "", "starf": "", "straightepsilon": "", "straightphi": "", "strns": "", "sub": "", "Sub": "", "subdot": "", "sube": "", "subE": "", "subedot": "", "submult": "", "subne": "", "subnE": "", "subplus": "", "subrarr": "", "subset": "", "Subset": "", "subseteq": "", "subseteqq": "", "SubsetEqual": "", "subsetneq": "", "subsetneqq": "", "subsim": "", "subsub": "", "subsup": "", "succ": "", "succapprox": "", "succcurlyeq": "", "Succeeds": "", "SucceedsEqual": "", "SucceedsSlantEqual": "", "SucceedsTilde": "", "succeq": "", "succnapprox": "", "succneqq": "", "succnsim": "", "succsim": "", "SuchThat": "", "sum": "", "Sum": "", "sung": "", "sup": "", "Sup": "", "sup1": "", "sup2": "", "sup3": "", "supdot": "", "supdsub": "", "supe": "", "supE": "", "supedot": "", "Superset": "", "SupersetEqual": "", "suphsol": "", "suphsub": "", "suplarr": "", "supmult": "", "supne": "", "supnE": "", "supplus": "", "supset": "", "Supset": "", "supseteq": "", "supseteqq": "", "supsetneq": "", "supsetneqq": "", "supsim": "", "supsub": "", "supsup": "", "swarhk": "", "swarr": "", "swArr": "", "swarrow": "", "swnwar": "", "szlig": "", "Tab": "	", "target": "", "tau": "", "Tau": "", "tbrk": "", "tcaron": "", "Tcaron": "", "tcedil": "", "Tcedil": "", "tcy": "", "Tcy": "", "tdot": "", "telrec": "", "tfr": "", "Tfr": "", "there4": "", "therefore": "", "Therefore": "", "theta": "", "Theta": "", "thetasym": "", "thetav": "", "thickapprox": "", "thicksim": "", "ThickSpace": "", "thinsp": "", "ThinSpace": "", "thkap": "", "thksim": "", "thorn": "", "THORN": "", "tilde": "", "Tilde": "", "TildeEqual": "", "TildeFullEqual": "", "TildeTilde": "", "times": "", "timesb": "", "timesbar": "", "timesd": "", "tint": "", "toea": "", "top": "", "topbot": "", "topcir": "", "topf": "", "Topf": "", "topfork": "", "tosa": "", "tprime": "", "trade": "", "TRADE": "", "triangle": "", "triangledown": "", "triangleleft": "", "trianglelefteq": "", "triangleq": "", "triangleright": "", "trianglerighteq": "", "tridot": "", "trie": "", "triminus": "", "TripleDot": "", "triplus": "", "trisb": "", "tritime": "", "trpezium": "", "tscr": "", "Tscr": "", "tscy": "", "TScy": "", "tshcy": "", "TSHcy": "", "tstrok": "", "Tstrok": "", "twixt": "", "twoheadleftarrow": "", "twoheadrightarrow": "", "uacute": "", "Uacute": "", "uarr": "", "uArr": "", "Uarr": "", "Uarrocir": "", "ubrcy": "", "Ubrcy": "", "ubreve": "", "Ubreve": "", "ucirc": "", "Ucirc": "", "ucy": "", "Ucy": "", "udarr": "", "udblac": "", "Udblac": "", "udhar": "", "ufisht": "", "ufr": "", "Ufr": "", "ugrave": "", "Ugrave": "", "uHar": "", "uharl": "", "uharr": "", "uhblk": "", "ulcorn": "", "ulcorner": "", "ulcrop": "", "ultri": "", "umacr": "", "Umacr": "", "uml": "", "UnderBar": "_", "UnderBrace": "", "UnderBracket": "", "UnderParenthesis": "", "Union": "", "UnionPlus": "", "uogon": "", "Uogon": "", "uopf": "", "Uopf": "", "uparrow": "", "Uparrow": "", "UpArrow": "", "UpArrowBar": "", "UpArrowDownArrow": "", "updownarrow": "", "Updownarrow": "", "UpDownArrow": "", "UpEquilibrium": "", "upharpoonleft": "", "upharpoonright": "", "uplus": "", "UpperLeftArrow": "", "UpperRightArrow": "", "upsi": "", "Upsi": "", "upsih": "", "upsilon": "", "Upsilon": "", "UpTee": "", "UpTeeArrow": "", "upuparrows": "", "urcorn": "", "urcorner": "", "urcrop": "", "uring": "", "Uring": "", "urtri": "", "uscr": "", "Uscr": "", "utdot": "", "utilde": "", "Utilde": "", "utri": "", "utrif": "", "uuarr": "", "uuml": "", "Uuml": "", "uwangle": "", "vangrt": "", "varepsilon": "", "varkappa": "", "varnothing": "", "varphi": "", "varpi": "", "varpropto": "", "varr": "", "vArr": "", "varrho": "", "varsigma": "", "varsubsetneq": "", "varsubsetneqq": "", "varsupsetneq": "", "varsupsetneqq": "", "vartheta": "", "vartriangleleft": "", "vartriangleright": "", "vBar": "", "Vbar": "", "vBarv": "", "vcy": "", "Vcy": "", "vdash": "", "vDash": "", "Vdash": "", "VDash": "", "Vdashl": "", "vee": "", "Vee": "", "veebar": "", "veeeq": "", "vellip": "", "verbar": "|", "Verbar": "", "vert": "|", "Vert": "", "VerticalBar": "", "VerticalLine": "|", "VerticalSeparator": "", "VerticalTilde": "", "VeryThinSpace": "", "vfr": "", "Vfr": "", "vltri": "", "vnsub": "", "vnsup": "", "vopf": "", "Vopf": "", "vprop": "", "vrtri": "", "vscr": "", "Vscr": "", "vsubne": "", "vsubnE": "", "vsupne": "", "vsupnE": "", "Vvdash": "", "vzigzag": "", "wcirc": "", "Wcirc": "", "wedbar": "", "wedge": "", "Wedge": "", "wedgeq": "", "weierp": "", "wfr": "", "Wfr": "", "wopf": "", "Wopf": "", "wp": "", "wr": "", "wreath": "", "wscr": "", "Wscr": "", "xcap": "", "xcirc": "", "xcup": "", "xdtri": "", "xfr": "", "Xfr": "", "xharr": "", "xhArr": "", "xi": "", "Xi": "", "xlarr": "", "xlArr": "", "xmap": "", "xnis": "", "xodot": "", "xopf": "", "Xopf": "", "xoplus": "", "xotime": "", "xrarr": "", "xrArr": "", "xscr": "", "Xscr": "", "xsqcup": "", "xuplus": "", "xutri": "", "xvee": "", "xwedge": "", "yacute": "", "Yacute": "", "yacy": "", "YAcy": "", "ycirc": "", "Ycirc": "", "ycy": "", "Ycy": "", "yen": "", "yfr": "", "Yfr": "", "yicy": "", "YIcy": "", "yopf": "", "Yopf": "", "yscr": "", "Yscr": "", "yucy": "", "YUcy": "", "yuml": "", "Yuml": "", "zacute": "", "Zacute": "", "zcaron": "", "Zcaron": "", "zcy": "", "Zcy": "", "zdot": "", "Zdot": "", "zeetrf": "", "ZeroWidthSpace": "", "zeta": "", "Zeta": "", "zfr": "", "Zfr": "", "zhcy": "", "ZHcy": "", "zigrarr": "", "zopf": "", "Zopf": "", "zscr": "", "Zscr": "", "zwj": "", "zwnj": "" };
      var decodeMapLegacy = { "aacute": "", "Aacute": "", "acirc": "", "Acirc": "", "acute": "", "aelig": "", "AElig": "", "agrave": "", "Agrave": "", "amp": "&", "AMP": "&", "aring": "", "Aring": "", "atilde": "", "Atilde": "", "auml": "", "Auml": "", "brvbar": "", "ccedil": "", "Ccedil": "", "cedil": "", "cent": "", "copy": "", "COPY": "", "curren": "", "deg": "", "divide": "", "eacute": "", "Eacute": "", "ecirc": "", "Ecirc": "", "egrave": "", "Egrave": "", "eth": "", "ETH": "", "euml": "", "Euml": "", "frac12": "", "frac14": "", "frac34": "", "gt": ">", "GT": ">", "iacute": "", "Iacute": "", "icirc": "", "Icirc": "", "iexcl": "", "igrave": "", "Igrave": "", "iquest": "", "iuml": "", "Iuml": "", "laquo": "", "lt": "<", "LT": "<", "macr": "", "micro": "", "middot": "", "nbsp": "", "not": "", "ntilde": "", "Ntilde": "", "oacute": "", "Oacute": "", "ocirc": "", "Ocirc": "", "ograve": "", "Ograve": "", "ordf": "", "ordm": "", "oslash": "", "Oslash": "", "otilde": "", "Otilde": "", "ouml": "", "Ouml": "", "para": "", "plusmn": "", "pound": "", "quot": '"', "QUOT": '"', "raquo": "", "reg": "", "REG": "", "sect": "", "shy": "", "sup1": "", "sup2": "", "sup3": "", "szlig": "", "thorn": "", "THORN": "", "times": "", "uacute": "", "Uacute": "", "ucirc": "", "Ucirc": "", "ugrave": "", "Ugrave": "", "uml": "", "uuml": "", "Uuml": "", "yacute": "", "Yacute": "", "yen": "", "yuml": "" };
      var decodeMapNumeric = { "0": "", "128": "", "130": "", "131": "", "132": "", "133": "", "134": "", "135": "", "136": "", "137": "", "138": "", "139": "", "140": "", "142": "", "145": "", "146": "", "147": "", "148": "", "149": "", "150": "", "151": "", "152": "", "153": "", "154": "", "155": "", "156": "", "158": "", "159": "" };
      var invalidReferenceCodePoints = [1, 2, 3, 4, 5, 6, 7, 8, 11, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 64976, 64977, 64978, 64979, 64980, 64981, 64982, 64983, 64984, 64985, 64986, 64987, 64988, 64989, 64990, 64991, 64992, 64993, 64994, 64995, 64996, 64997, 64998, 64999, 65e3, 65001, 65002, 65003, 65004, 65005, 65006, 65007, 65534, 65535, 131070, 131071, 196606, 196607, 262142, 262143, 327678, 327679, 393214, 393215, 458750, 458751, 524286, 524287, 589822, 589823, 655358, 655359, 720894, 720895, 786430, 786431, 851966, 851967, 917502, 917503, 983038, 983039, 1048574, 1048575, 1114110, 1114111];
      var stringFromCharCode = String.fromCharCode;
      var object = {};
      var hasOwnProperty = object.hasOwnProperty;
      var has = function(object2, propertyName) {
        return hasOwnProperty.call(object2, propertyName);
      };
      var contains = function(array, value) {
        var index = -1;
        var length = array.length;
        while (++index < length) {
          if (array[index] == value) {
            return true;
          }
        }
        return false;
      };
      var merge = function(options, defaults) {
        if (!options) {
          return defaults;
        }
        var result = {};
        var key2;
        for (key2 in defaults) {
          result[key2] = has(options, key2) ? options[key2] : defaults[key2];
        }
        return result;
      };
      var codePointToSymbol = function(codePoint, strict) {
        var output = "";
        if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
          if (strict) {
            parseError("character reference outside the permissible Unicode range");
          }
          return "";
        }
        if (has(decodeMapNumeric, codePoint)) {
          if (strict) {
            parseError("disallowed character reference");
          }
          return decodeMapNumeric[codePoint];
        }
        if (strict && contains(invalidReferenceCodePoints, codePoint)) {
          parseError("disallowed character reference");
        }
        if (codePoint > 65535) {
          codePoint -= 65536;
          output += stringFromCharCode(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        output += stringFromCharCode(codePoint);
        return output;
      };
      var hexEscape = function(codePoint) {
        return "&#x" + codePoint.toString(16).toUpperCase() + ";";
      };
      var decEscape = function(codePoint) {
        return "&#" + codePoint + ";";
      };
      var parseError = function(message) {
        throw Error("Parse error: " + message);
      };
      var encode = function(string, options) {
        options = merge(options, encode.options);
        var strict = options.strict;
        if (strict && regexInvalidRawCodePoint.test(string)) {
          parseError("forbidden code point");
        }
        var encodeEverything = options.encodeEverything;
        var useNamedReferences = options.useNamedReferences;
        var allowUnsafeSymbols = options.allowUnsafeSymbols;
        var escapeCodePoint = options.decimal ? decEscape : hexEscape;
        var escapeBmpSymbol = function(symbol) {
          return escapeCodePoint(symbol.charCodeAt(0));
        };
        if (encodeEverything) {
          string = string.replace(regexAsciiWhitelist, function(symbol) {
            if (useNamedReferences && has(encodeMap, symbol)) {
              return "&" + encodeMap[symbol] + ";";
            }
            return escapeBmpSymbol(symbol);
          });
          if (useNamedReferences) {
            string = string.replace(/&gt;\u20D2/g, "&nvgt;").replace(/&lt;\u20D2/g, "&nvlt;").replace(/&#x66;&#x6A;/g, "&fjlig;");
          }
          if (useNamedReferences) {
            string = string.replace(regexEncodeNonAscii, function(string2) {
              return "&" + encodeMap[string2] + ";";
            });
          }
        } else if (useNamedReferences) {
          if (!allowUnsafeSymbols) {
            string = string.replace(regexEscape, function(string2) {
              return "&" + encodeMap[string2] + ";";
            });
          }
          string = string.replace(/&gt;\u20D2/g, "&nvgt;").replace(/&lt;\u20D2/g, "&nvlt;");
          string = string.replace(regexEncodeNonAscii, function(string2) {
            return "&" + encodeMap[string2] + ";";
          });
        } else if (!allowUnsafeSymbols) {
          string = string.replace(regexEscape, escapeBmpSymbol);
        }
        return string.replace(regexAstralSymbols, function($0) {
          var high = $0.charCodeAt(0);
          var low = $0.charCodeAt(1);
          var codePoint = (high - 55296) * 1024 + low - 56320 + 65536;
          return escapeCodePoint(codePoint);
        }).replace(regexBmpWhitelist, escapeBmpSymbol);
      };
      encode.options = {
        "allowUnsafeSymbols": false,
        "encodeEverything": false,
        "strict": false,
        "useNamedReferences": false,
        "decimal": false
      };
      var decode = function(html, options) {
        options = merge(options, decode.options);
        var strict = options.strict;
        if (strict && regexInvalidEntity.test(html)) {
          parseError("malformed character reference");
        }
        return html.replace(regexDecode, function($0, $1, $2, $3, $4, $5, $6, $7, $8) {
          var codePoint;
          var semicolon;
          var decDigits;
          var hexDigits;
          var reference;
          var next;
          if ($1) {
            reference = $1;
            return decodeMap[reference];
          }
          if ($2) {
            reference = $2;
            next = $3;
            if (next && options.isAttributeValue) {
              if (strict && next == "=") {
                parseError("`&` did not start a character reference");
              }
              return $0;
            } else {
              if (strict) {
                parseError(
                  "named character reference was not terminated by a semicolon"
                );
              }
              return decodeMapLegacy[reference] + (next || "");
            }
          }
          if ($4) {
            decDigits = $4;
            semicolon = $5;
            if (strict && !semicolon) {
              parseError("character reference was not terminated by a semicolon");
            }
            codePoint = parseInt(decDigits, 10);
            return codePointToSymbol(codePoint, strict);
          }
          if ($6) {
            hexDigits = $6;
            semicolon = $7;
            if (strict && !semicolon) {
              parseError("character reference was not terminated by a semicolon");
            }
            codePoint = parseInt(hexDigits, 16);
            return codePointToSymbol(codePoint, strict);
          }
          if (strict) {
            parseError(
              "named character reference was not terminated by a semicolon"
            );
          }
          return $0;
        });
      };
      decode.options = {
        "isAttributeValue": false,
        "strict": false
      };
      var escape = function(string) {
        return string.replace(regexEscape, function($0) {
          return escapeMap[$0];
        });
      };
      var he = {
        "version": "1.2.0",
        "encode": encode,
        "decode": decode,
        "escape": escape,
        "unescape": decode
      };
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        define(function() {
          return he;
        });
      } else if (freeExports && !freeExports.nodeType) {
        if (freeModule) {
          freeModule.exports = he;
        } else {
          for (var key in he) {
            has(he, key) && (freeExports[key] = he[key]);
          }
        }
      } else {
        root.he = he;
      }
    })(exports);
  }
});

// node_modules/mocha/lib/utils.js
var require_utils = __commonJS({
  "node_modules/mocha/lib/utils.js"(exports) {
    "use strict";
    init_shim();
    var { nanoid } = require_non_secure();
    var path = require_path_browserify();
    var util = require_util();
    var he = require_he();
    var MOCHA_ID_PROP_NAME = "__mocha_id__";
    exports.inherits = util.inherits;
    exports.escape = function(html) {
      return he.encode(String(html), { useNamedReferences: false });
    };
    exports.isString = function(obj) {
      return typeof obj === "string";
    };
    exports.slug = function(str) {
      return str.toLowerCase().replace(/\s+/g, "-").replace(/[^-\w]/g, "").replace(/-{2,}/g, "-");
    };
    exports.clean = function(str) {
      str = str.replace(/\r\n?|[\n\u2028\u2029]/g, "\n").replace(/^\uFEFF/, "").replace(
        /^function(?:\s*|\s[^(]*)\([^)]*\)\s*\{((?:.|\n)*?)\}$|^\([^)]*\)\s*=>\s*(?:\{((?:.|\n)*?)\}|((?:.|\n)*))$/,
        "$1$2$3"
      );
      var spaces = str.match(/^\n?( *)/)[1].length;
      var tabs = str.match(/^\n?(\t*)/)[1].length;
      var re = new RegExp(
        "^\n?" + (tabs ? "	" : " ") + "{" + (tabs || spaces) + "}",
        "gm"
      );
      str = str.replace(re, "");
      return str.trim();
    };
    function emptyRepresentation(value, typeHint) {
      switch (typeHint) {
        case "function":
          return "[Function]";
        case "object":
          return "{}";
        case "array":
          return "[]";
        default:
          return value.toString();
      }
    }
    var canonicalType = exports.canonicalType = function canonicalType2(value) {
      if (value === void 0) {
        return "undefined";
      } else if (value === null) {
        return "null";
      } else if (import_buffer.Buffer.isBuffer(value)) {
        return "buffer";
      }
      return Object.prototype.toString.call(value).replace(/^\[.+\s(.+?)]$/, "$1").toLowerCase();
    };
    exports.type = function type(value) {
      if (value === null)
        return "null";
      const primitives = /* @__PURE__ */ new Set([
        "undefined",
        "boolean",
        "number",
        "string",
        "bigint",
        "symbol"
      ]);
      const _type = typeof value;
      if (_type === "function")
        return _type;
      if (primitives.has(_type))
        return _type;
      if (value instanceof String)
        return "string";
      if (value instanceof Error)
        return "error";
      if (Array.isArray(value))
        return "array";
      return _type;
    };
    exports.stringify = function(value) {
      var typeHint = canonicalType(value);
      if (!~["object", "array", "function"].indexOf(typeHint)) {
        if (typeHint === "buffer") {
          var json = import_buffer.Buffer.prototype.toJSON.call(value);
          return jsonStringify(
            json.data && json.type ? json.data : json,
            2
          ).replace(/,(\n|$)/g, "$1");
        }
        if (typeHint === "string" && typeof value === "object") {
          value = value.split("").reduce(function(acc, char, idx) {
            acc[idx] = char;
            return acc;
          }, {});
          typeHint = "object";
        } else {
          return jsonStringify(value);
        }
      }
      for (var prop in value) {
        if (Object.prototype.hasOwnProperty.call(value, prop)) {
          return jsonStringify(
            exports.canonicalize(value, null, typeHint),
            2
          ).replace(/,(\n|$)/g, "$1");
        }
      }
      return emptyRepresentation(value, typeHint);
    };
    function jsonStringify(object, spaces, depth) {
      if (typeof spaces === "undefined") {
        return _stringify(object);
      }
      depth = depth || 1;
      var space = spaces * depth;
      var str = Array.isArray(object) ? "[" : "{";
      var end = Array.isArray(object) ? "]" : "}";
      var length = typeof object.length === "number" ? object.length : Object.keys(object).length;
      function repeat(s, n) {
        return new Array(n).join(s);
      }
      function _stringify(val) {
        switch (canonicalType(val)) {
          case "null":
          case "undefined":
            val = "[" + val + "]";
            break;
          case "array":
          case "object":
            val = jsonStringify(val, spaces, depth + 1);
            break;
          case "boolean":
          case "regexp":
          case "symbol":
          case "number":
            val = val === 0 && 1 / val === -Infinity ? "-0" : val.toString();
            break;
          case "bigint":
            val = val.toString() + "n";
            break;
          case "date":
            var sDate = isNaN(val.getTime()) ? val.toString() : val.toISOString();
            val = "[Date: " + sDate + "]";
            break;
          case "buffer":
            var json = val.toJSON();
            json = json.data && json.type ? json.data : json;
            val = "[Buffer: " + jsonStringify(json, 2, depth + 1) + "]";
            break;
          default:
            val = val === "[Function]" || val === "[Circular]" ? val : JSON.stringify(val);
        }
        return val;
      }
      for (var i in object) {
        if (!Object.prototype.hasOwnProperty.call(object, i)) {
          continue;
        }
        --length;
        str += "\n " + repeat(" ", space) + (Array.isArray(object) ? "" : '"' + i + '": ') + // key
        _stringify(object[i]) + // value
        (length ? "," : "");
      }
      return str + // [], {}
      (str.length !== 1 ? "\n" + repeat(" ", --space) + end : end);
    }
    exports.canonicalize = function canonicalize(value, stack, typeHint) {
      var canonicalizedObj;
      var prop;
      typeHint = typeHint || canonicalType(value);
      function withStack(value2, fn) {
        stack.push(value2);
        fn();
        stack.pop();
      }
      stack = stack || [];
      if (stack.indexOf(value) !== -1) {
        return "[Circular]";
      }
      switch (typeHint) {
        case "undefined":
        case "buffer":
        case "null":
          canonicalizedObj = value;
          break;
        case "array":
          withStack(value, function() {
            canonicalizedObj = value.map(function(item) {
              return exports.canonicalize(item, stack);
            });
          });
          break;
        case "function":
          for (prop in value) {
            canonicalizedObj = {};
            break;
          }
          if (!canonicalizedObj) {
            canonicalizedObj = emptyRepresentation(value, typeHint);
            break;
          }
        case "object":
          canonicalizedObj = canonicalizedObj || {};
          withStack(value, function() {
            Object.keys(value).sort().forEach(function(key) {
              canonicalizedObj[key] = exports.canonicalize(value[key], stack);
            });
          });
          break;
        case "date":
        case "number":
        case "regexp":
        case "boolean":
        case "symbol":
          canonicalizedObj = value;
          break;
        default:
          canonicalizedObj = value + "";
      }
      return canonicalizedObj;
    };
    exports.stackTraceFilter = function() {
      var is = typeof document === "undefined" ? { node: true } : { browser: true };
      var slash = path.sep;
      var cwd;
      if (is.node) {
        cwd = exports.cwd() + slash;
      } else {
        cwd = (typeof location === "undefined" ? window.location : location).href.replace(/\/[^/]*$/, "/");
        slash = "/";
      }
      function isMochaInternal(line) {
        return ~line.indexOf("node_modules" + slash + "mocha" + slash) || ~line.indexOf(slash + "mocha.js") || ~line.indexOf(slash + "mocha.min.js");
      }
      function isNodeInternal(line) {
        return ~line.indexOf("(timers.js:") || ~line.indexOf("(events.js:") || ~line.indexOf("(node.js:") || ~line.indexOf("(module.js:") || ~line.indexOf("GeneratorFunctionPrototype.next (native)") || false;
      }
      return function(stack) {
        stack = stack.split("\n");
        stack = stack.reduce(function(list, line) {
          if (isMochaInternal(line)) {
            return list;
          }
          if (is.node && isNodeInternal(line)) {
            return list;
          }
          if (/:\d+:\d+\)?$/.test(line)) {
            line = line.replace("(" + cwd, "(");
          }
          list.push(line);
          return list;
        }, []);
        return stack.join("\n");
      };
    };
    exports.isPromise = function isPromise(value) {
      return typeof value === "object" && value !== null && typeof value.then === "function";
    };
    exports.clamp = function clamp(value, range) {
      return Math.min(Math.max(value, range[0]), range[1]);
    };
    exports.noop = function() {
    };
    exports.createMap = function(obj) {
      return Object.assign.apply(
        null,
        [/* @__PURE__ */ Object.create(null)].concat(Array.prototype.slice.call(arguments))
      );
    };
    exports.defineConstants = function(obj) {
      if (canonicalType(obj) !== "object" || !Object.keys(obj).length) {
        throw new TypeError("Invalid argument; expected a non-empty object");
      }
      return Object.freeze(exports.createMap(obj));
    };
    exports.cwd = function cwd() {
      return import_process.default.cwd();
    };
    exports.isBrowser = function isBrowser() {
      return Boolean(import_process.default.browser);
    };
    exports.castArray = function castArray(value) {
      if (value === void 0) {
        return [];
      }
      if (value === null) {
        return [null];
      }
      if (typeof value === "object" && (typeof value[Symbol.iterator] === "function" || value.length !== void 0)) {
        return Array.from(value);
      }
      return [value];
    };
    exports.constants = exports.defineConstants({
      MOCHA_ID_PROP_NAME
    });
    exports.uniqueID = () => nanoid();
    exports.assignNewMochaID = (obj) => {
      const id = exports.uniqueID();
      Object.defineProperty(obj, MOCHA_ID_PROP_NAME, {
        get() {
          return id;
        }
      });
      return obj;
    };
    exports.getMochaID = (obj) => obj && typeof obj === "object" ? obj[MOCHA_ID_PROP_NAME] : void 0;
  }
});

// browser-external:supports-color
var require_supports_color = __commonJS({
  "browser-external:supports-color"(exports, module) {
    init_shim();
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "supports-color" has been externalized for browser compatibility. Cannot access "supports-color.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/log-symbols/browser.js
var require_browser2 = __commonJS({
  "node_modules/log-symbols/browser.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = {
      info: "",
      success: "",
      warning: "",
      error: ""
    };
  }
});

// node_modules/mocha/lib/pending.js
var require_pending = __commonJS({
  "node_modules/mocha/lib/pending.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = Pending;
    function Pending(message) {
      this.message = message;
    }
  }
});

// node_modules/ms/index.js
var require_ms2 = __commonJS({
  "node_modules/ms/index.js"(exports, module) {
    init_shim();
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module) {
    init_shim();
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms2();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser3 = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module) {
    init_shim();
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof import_process.default !== "undefined" && "env" in import_process.default) {
        r = import_process.default.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/mocha/lib/errors.js
var require_errors = __commonJS({
  "node_modules/mocha/lib/errors.js"(exports, module) {
    "use strict";
    init_shim();
    var { format } = require_util();
    var emitWarning = (msg, type) => {
      if (import_process.default.emitWarning) {
        import_process.default.emitWarning(msg, type);
      } else {
        import_process.default.nextTick(function() {
          console.warn(type + ": " + msg);
        });
      }
    };
    var deprecate = (msg) => {
      msg = String(msg);
      if (msg && !deprecate.cache[msg]) {
        deprecate.cache[msg] = true;
        emitWarning(msg, "DeprecationWarning");
      }
    };
    deprecate.cache = {};
    var warn = (msg) => {
      if (msg) {
        emitWarning(msg);
      }
    };
    var constants = {
      /**
       * An unrecoverable error.
       * @constant
       * @default
       */
      FATAL: "ERR_MOCHA_FATAL",
      /**
       * The type of an argument to a function call is invalid
       * @constant
       * @default
       */
      INVALID_ARG_TYPE: "ERR_MOCHA_INVALID_ARG_TYPE",
      /**
       * The value of an argument to a function call is invalid
       * @constant
       * @default
       */
      INVALID_ARG_VALUE: "ERR_MOCHA_INVALID_ARG_VALUE",
      /**
       * Something was thrown, but it wasn't an `Error`
       * @constant
       * @default
       */
      INVALID_EXCEPTION: "ERR_MOCHA_INVALID_EXCEPTION",
      /**
       * An interface (e.g., `Mocha.interfaces`) is unknown or invalid
       * @constant
       * @default
       */
      INVALID_INTERFACE: "ERR_MOCHA_INVALID_INTERFACE",
      /**
       * A reporter (.e.g, `Mocha.reporters`) is unknown or invalid
       * @constant
       * @default
       */
      INVALID_REPORTER: "ERR_MOCHA_INVALID_REPORTER",
      /**
       * `done()` was called twice in a `Test` or `Hook` callback
       * @constant
       * @default
       */
      MULTIPLE_DONE: "ERR_MOCHA_MULTIPLE_DONE",
      /**
       * No files matched the pattern provided by the user
       * @constant
       * @default
       */
      NO_FILES_MATCH_PATTERN: "ERR_MOCHA_NO_FILES_MATCH_PATTERN",
      /**
       * Known, but unsupported behavior of some kind
       * @constant
       * @default
       */
      UNSUPPORTED: "ERR_MOCHA_UNSUPPORTED",
      /**
       * Invalid state transition occurring in `Mocha` instance
       * @constant
       * @default
       */
      INSTANCE_ALREADY_RUNNING: "ERR_MOCHA_INSTANCE_ALREADY_RUNNING",
      /**
       * Invalid state transition occurring in `Mocha` instance
       * @constant
       * @default
       */
      INSTANCE_ALREADY_DISPOSED: "ERR_MOCHA_INSTANCE_ALREADY_DISPOSED",
      /**
       * Use of `only()` w/ `--forbid-only` results in this error.
       * @constant
       * @default
       */
      FORBIDDEN_EXCLUSIVITY: "ERR_MOCHA_FORBIDDEN_EXCLUSIVITY",
      /**
       * To be thrown when a user-defined plugin implementation (e.g., `mochaHooks`) is invalid
       * @constant
       * @default
       */
      INVALID_PLUGIN_IMPLEMENTATION: "ERR_MOCHA_INVALID_PLUGIN_IMPLEMENTATION",
      /**
       * To be thrown when a builtin or third-party plugin definition (the _definition_ of `mochaHooks`) is invalid
       * @constant
       * @default
       */
      INVALID_PLUGIN_DEFINITION: "ERR_MOCHA_INVALID_PLUGIN_DEFINITION",
      /**
       * When a runnable exceeds its allowed run time.
       * @constant
       * @default
       */
      TIMEOUT: "ERR_MOCHA_TIMEOUT",
      /**
       * Input file is not able to be parsed
       * @constant
       * @default
       */
      UNPARSABLE_FILE: "ERR_MOCHA_UNPARSABLE_FILE"
    };
    var MOCHA_ERRORS = new Set(Object.values(constants));
    function createNoFilesMatchPatternError(message, pattern) {
      var err = new Error(message);
      err.code = constants.NO_FILES_MATCH_PATTERN;
      err.pattern = pattern;
      return err;
    }
    function createInvalidReporterError(message, reporter) {
      var err = new TypeError(message);
      err.code = constants.INVALID_REPORTER;
      err.reporter = reporter;
      return err;
    }
    function createInvalidInterfaceError(message, ui) {
      var err = new Error(message);
      err.code = constants.INVALID_INTERFACE;
      err.interface = ui;
      return err;
    }
    function createUnsupportedError(message) {
      var err = new Error(message);
      err.code = constants.UNSUPPORTED;
      return err;
    }
    function createMissingArgumentError(message, argument, expected) {
      return createInvalidArgumentTypeError(message, argument, expected);
    }
    function createInvalidArgumentTypeError(message, argument, expected) {
      var err = new TypeError(message);
      err.code = constants.INVALID_ARG_TYPE;
      err.argument = argument;
      err.expected = expected;
      err.actual = typeof argument;
      return err;
    }
    function createInvalidArgumentValueError(message, argument, value, reason) {
      var err = new TypeError(message);
      err.code = constants.INVALID_ARG_VALUE;
      err.argument = argument;
      err.value = value;
      err.reason = typeof reason !== "undefined" ? reason : "is invalid";
      return err;
    }
    function createInvalidExceptionError(message, value) {
      var err = new Error(message);
      err.code = constants.INVALID_EXCEPTION;
      err.valueType = typeof value;
      err.value = value;
      return err;
    }
    function createFatalError(message, value) {
      var err = new Error(message);
      err.code = constants.FATAL;
      err.valueType = typeof value;
      err.value = value;
      return err;
    }
    function createInvalidLegacyPluginError(message, pluginType, pluginId) {
      switch (pluginType) {
        case "reporter":
          return createInvalidReporterError(message, pluginId);
        case "ui":
          return createInvalidInterfaceError(message, pluginId);
        default:
          throw new Error('unknown pluginType "' + pluginType + '"');
      }
    }
    function createInvalidPluginError(...args) {
      deprecate("Use createInvalidLegacyPluginError() instead");
      return createInvalidLegacyPluginError(...args);
    }
    function createMochaInstanceAlreadyDisposedError(message, cleanReferencesAfterRun, instance) {
      var err = new Error(message);
      err.code = constants.INSTANCE_ALREADY_DISPOSED;
      err.cleanReferencesAfterRun = cleanReferencesAfterRun;
      err.instance = instance;
      return err;
    }
    function createMochaInstanceAlreadyRunningError(message, instance) {
      var err = new Error(message);
      err.code = constants.INSTANCE_ALREADY_RUNNING;
      err.instance = instance;
      return err;
    }
    function createMultipleDoneError(runnable, originalErr) {
      var title;
      try {
        title = format("<%s>", runnable.fullTitle());
        if (runnable.parent.root) {
          title += " (of root suite)";
        }
      } catch (ignored) {
        title = format("<%s> (of unknown suite)", runnable.title);
      }
      var message = format(
        "done() called multiple times in %s %s",
        runnable.type ? runnable.type : "unknown runnable",
        title
      );
      if (runnable.file) {
        message += format(" of file %s", runnable.file);
      }
      if (originalErr) {
        message += format("; in addition, done() received error: %s", originalErr);
      }
      var err = new Error(message);
      err.code = constants.MULTIPLE_DONE;
      err.valueType = typeof originalErr;
      err.value = originalErr;
      return err;
    }
    function createForbiddenExclusivityError(mocha) {
      var err = new Error(
        mocha.isWorker ? "`.only` is not supported in parallel mode" : "`.only` forbidden by --forbid-only"
      );
      err.code = constants.FORBIDDEN_EXCLUSIVITY;
      return err;
    }
    function createInvalidPluginDefinitionError(msg, pluginDef) {
      const err = new Error(msg);
      err.code = constants.INVALID_PLUGIN_DEFINITION;
      err.pluginDef = pluginDef;
      return err;
    }
    function createInvalidPluginImplementationError(msg, { pluginDef, pluginImpl } = {}) {
      const err = new Error(msg);
      err.code = constants.INVALID_PLUGIN_IMPLEMENTATION;
      err.pluginDef = pluginDef;
      err.pluginImpl = pluginImpl;
      return err;
    }
    function createTimeoutError(msg, timeout, file) {
      const err = new Error(msg);
      err.code = constants.TIMEOUT;
      err.timeout = timeout;
      err.file = file;
      return err;
    }
    function createUnparsableFileError(message, filename) {
      var err = new Error(message);
      err.code = constants.UNPARSABLE_FILE;
      return err;
    }
    var isMochaError = (err) => Boolean(err && typeof err === "object" && MOCHA_ERRORS.has(err.code));
    module.exports = {
      constants,
      createFatalError,
      createForbiddenExclusivityError,
      createInvalidArgumentTypeError,
      createInvalidArgumentValueError,
      createInvalidExceptionError,
      createInvalidInterfaceError,
      createInvalidLegacyPluginError,
      createInvalidPluginDefinitionError,
      createInvalidPluginError,
      createInvalidPluginImplementationError,
      createInvalidReporterError,
      createMissingArgumentError,
      createMochaInstanceAlreadyDisposedError,
      createMochaInstanceAlreadyRunningError,
      createMultipleDoneError,
      createNoFilesMatchPatternError,
      createTimeoutError,
      createUnparsableFileError,
      createUnsupportedError,
      deprecate,
      isMochaError,
      warn
    };
  }
});

// node_modules/mocha/lib/runnable.js
var require_runnable = __commonJS({
  "node_modules/mocha/lib/runnable.js"(exports, module) {
    "use strict";
    init_shim();
    var EventEmitter = require_events().EventEmitter;
    var Pending = require_pending();
    var debug = require_browser3()("mocha:runnable");
    var milliseconds = require_ms();
    var utils = require_utils();
    var {
      createInvalidExceptionError,
      createMultipleDoneError,
      createTimeoutError
    } = require_errors();
    var Date2 = _global.Date;
    var setTimeout2 = _global.setTimeout;
    var clearTimeout = _global.clearTimeout;
    var toString = Object.prototype.toString;
    module.exports = Runnable;
    function Runnable(title, fn) {
      this.title = title;
      this.fn = fn;
      this.body = (fn || "").toString();
      this.async = fn && fn.length;
      this.sync = !this.async;
      this._timeout = 2e3;
      this._slow = 75;
      this._retries = -1;
      utils.assignNewMochaID(this);
      Object.defineProperty(this, "id", {
        get() {
          return utils.getMochaID(this);
        }
      });
      this.reset();
    }
    utils.inherits(Runnable, EventEmitter);
    Runnable.prototype.reset = function() {
      this.timedOut = false;
      this._currentRetry = 0;
      this.pending = false;
      delete this.state;
      delete this.err;
    };
    Runnable.prototype.timeout = function(ms) {
      if (!arguments.length) {
        return this._timeout;
      }
      if (typeof ms === "string") {
        ms = milliseconds(ms);
      }
      var INT_MAX = Math.pow(2, 31) - 1;
      var range = [0, INT_MAX];
      ms = utils.clamp(ms, range);
      if (ms === range[0] || ms === range[1]) {
        this._timeout = 0;
      } else {
        this._timeout = ms;
      }
      debug("timeout %d", this._timeout);
      if (this.timer) {
        this.resetTimeout();
      }
      return this;
    };
    Runnable.prototype.slow = function(ms) {
      if (!arguments.length || typeof ms === "undefined") {
        return this._slow;
      }
      if (typeof ms === "string") {
        ms = milliseconds(ms);
      }
      debug("slow %d", ms);
      this._slow = ms;
      return this;
    };
    Runnable.prototype.skip = function() {
      this.pending = true;
      throw new Pending("sync skip; aborting execution");
    };
    Runnable.prototype.isPending = function() {
      return this.pending || this.parent && this.parent.isPending();
    };
    Runnable.prototype.isFailed = function() {
      return !this.isPending() && this.state === constants.STATE_FAILED;
    };
    Runnable.prototype.isPassed = function() {
      return !this.isPending() && this.state === constants.STATE_PASSED;
    };
    Runnable.prototype.retries = function(n) {
      if (!arguments.length) {
        return this._retries;
      }
      this._retries = n;
    };
    Runnable.prototype.currentRetry = function(n) {
      if (!arguments.length) {
        return this._currentRetry;
      }
      this._currentRetry = n;
    };
    Runnable.prototype.fullTitle = function() {
      return this.titlePath().join(" ");
    };
    Runnable.prototype.titlePath = function() {
      return this.parent.titlePath().concat([this.title]);
    };
    Runnable.prototype.clearTimeout = function() {
      clearTimeout(this.timer);
    };
    Runnable.prototype.resetTimeout = function() {
      var self2 = this;
      var ms = this.timeout();
      if (ms === 0) {
        return;
      }
      this.clearTimeout();
      this.timer = setTimeout2(function() {
        if (self2.timeout() === 0) {
          return;
        }
        self2.callback(self2._timeoutError(ms));
        self2.timedOut = true;
      }, ms);
    };
    Runnable.prototype.globals = function(globals) {
      if (!arguments.length) {
        return this._allowedGlobals;
      }
      this._allowedGlobals = globals;
    };
    Runnable.prototype.run = function(fn) {
      var self2 = this;
      var start = new Date2();
      var ctx = this.ctx;
      var finished;
      var errorWasHandled = false;
      if (this.isPending())
        return fn();
      if (ctx && ctx.runnable) {
        ctx.runnable(this);
      }
      function multiple(err) {
        if (errorWasHandled) {
          return;
        }
        errorWasHandled = true;
        self2.emit("error", createMultipleDoneError(self2, err));
      }
      function done(err) {
        var ms = self2.timeout();
        if (self2.timedOut) {
          return;
        }
        if (finished) {
          return multiple(err);
        }
        self2.clearTimeout();
        self2.duration = new Date2() - start;
        finished = true;
        if (!err && self2.duration > ms && ms > 0) {
          err = self2._timeoutError(ms);
        }
        fn(err);
      }
      this.callback = done;
      if (this.fn && typeof this.fn.call !== "function") {
        done(
          new TypeError(
            "A runnable must be passed a function as its second argument."
          )
        );
        return;
      }
      if (this.async) {
        this.resetTimeout();
        this.skip = function asyncSkip() {
          this.pending = true;
          done();
          throw new Pending("async skip; aborting execution");
        };
        try {
          callFnAsync(this.fn);
        } catch (err) {
          errorWasHandled = true;
          if (err instanceof Pending) {
            return;
          } else if (this.allowUncaught) {
            throw err;
          }
          done(Runnable.toValueOrError(err));
        }
        return;
      }
      try {
        callFn(this.fn);
      } catch (err) {
        errorWasHandled = true;
        if (err instanceof Pending) {
          return done();
        } else if (this.allowUncaught) {
          throw err;
        }
        done(Runnable.toValueOrError(err));
      }
      function callFn(fn2) {
        var result = fn2.call(ctx);
        if (result && typeof result.then === "function") {
          self2.resetTimeout();
          result.then(
            function() {
              done();
              return null;
            },
            function(reason) {
              done(reason || new Error("Promise rejected with no or falsy reason"));
            }
          );
        } else {
          if (self2.asyncOnly) {
            return done(
              new Error(
                "--async-only option in use without declaring `done()` or returning a promise"
              )
            );
          }
          done();
        }
      }
      function callFnAsync(fn2) {
        var result = fn2.call(ctx, function(err) {
          if (err instanceof Error || toString.call(err) === "[object Error]") {
            return done(err);
          }
          if (err) {
            if (Object.prototype.toString.call(err) === "[object Object]") {
              return done(
                new Error("done() invoked with non-Error: " + JSON.stringify(err))
              );
            }
            return done(new Error("done() invoked with non-Error: " + err));
          }
          if (result && utils.isPromise(result)) {
            return done(
              new Error(
                "Resolution method is overspecified. Specify a callback *or* return a Promise; not both."
              )
            );
          }
          done();
        });
      }
    };
    Runnable.prototype._timeoutError = function(ms) {
      let msg = `Timeout of ${ms}ms exceeded. For async tests and hooks, ensure "done()" is called; if returning a Promise, ensure it resolves.`;
      if (this.file) {
        msg += " (" + this.file + ")";
      }
      return createTimeoutError(msg, ms, this.file);
    };
    var constants = utils.defineConstants(
      /**
       * {@link Runnable}-related constants.
       * @public
       * @memberof Runnable
       * @readonly
       * @static
       * @alias constants
       * @enum {string}
       */
      {
        /**
         * Value of `state` prop when a `Runnable` has failed
         */
        STATE_FAILED: "failed",
        /**
         * Value of `state` prop when a `Runnable` has passed
         */
        STATE_PASSED: "passed",
        /**
         * Value of `state` prop when a `Runnable` has been skipped by user
         */
        STATE_PENDING: "pending"
      }
    );
    Runnable.toValueOrError = function(value) {
      return value || createInvalidExceptionError(
        "Runnable failed with falsy or undefined exception. Please throw an Error instead.",
        value
      );
    };
    Runnable.constants = constants;
  }
});

// node_modules/mocha/lib/hook.js
var require_hook = __commonJS({
  "node_modules/mocha/lib/hook.js"(exports, module) {
    "use strict";
    init_shim();
    var Runnable = require_runnable();
    var { inherits, constants } = require_utils();
    var { MOCHA_ID_PROP_NAME } = constants;
    module.exports = Hook;
    function Hook(title, fn) {
      Runnable.call(this, title, fn);
      this.type = "hook";
    }
    inherits(Hook, Runnable);
    Hook.prototype.reset = function() {
      Runnable.prototype.reset.call(this);
      delete this._error;
    };
    Hook.prototype.error = function(err) {
      if (!arguments.length) {
        err = this._error;
        this._error = null;
        return err;
      }
      this._error = err;
    };
    Hook.prototype.serialize = function serialize() {
      return {
        $$currentRetry: this.currentRetry(),
        $$fullTitle: this.fullTitle(),
        $$isPending: Boolean(this.isPending()),
        $$titlePath: this.titlePath(),
        ctx: this.ctx && this.ctx.currentTest ? {
          currentTest: {
            title: this.ctx.currentTest.title,
            [MOCHA_ID_PROP_NAME]: this.ctx.currentTest.id
          }
        } : {},
        duration: this.duration,
        file: this.file,
        parent: {
          $$fullTitle: this.parent.fullTitle(),
          [MOCHA_ID_PROP_NAME]: this.parent.id
        },
        state: this.state,
        title: this.title,
        type: this.type,
        [MOCHA_ID_PROP_NAME]: this.id
      };
    };
  }
});

// node_modules/mocha/lib/suite.js
var require_suite = __commonJS({
  "node_modules/mocha/lib/suite.js"(exports, module) {
    "use strict";
    init_shim();
    var { EventEmitter } = require_events();
    var Hook = require_hook();
    var {
      assignNewMochaID,
      clamp,
      constants: utilsConstants,
      defineConstants,
      getMochaID,
      inherits,
      isString
    } = require_utils();
    var debug = require_browser3()("mocha:suite");
    var milliseconds = require_ms();
    var errors = require_errors();
    var { MOCHA_ID_PROP_NAME } = utilsConstants;
    exports = module.exports = Suite;
    Suite.create = function(parent, title) {
      var suite = new Suite(title, parent.ctx);
      suite.parent = parent;
      title = suite.fullTitle();
      parent.addSuite(suite);
      return suite;
    };
    function Suite(title, parentContext, isRoot) {
      if (!isString(title)) {
        throw errors.createInvalidArgumentTypeError(
          'Suite argument "title" must be a string. Received type "' + typeof title + '"',
          "title",
          "string"
        );
      }
      this.title = title;
      function Context() {
      }
      Context.prototype = parentContext;
      this.ctx = new Context();
      this.suites = [];
      this.tests = [];
      this.root = isRoot === true;
      this.pending = false;
      this._retries = -1;
      this._beforeEach = [];
      this._beforeAll = [];
      this._afterEach = [];
      this._afterAll = [];
      this._timeout = 2e3;
      this._slow = 75;
      this._bail = false;
      this._onlyTests = [];
      this._onlySuites = [];
      assignNewMochaID(this);
      Object.defineProperty(this, "id", {
        get() {
          return getMochaID(this);
        }
      });
      this.reset();
    }
    inherits(Suite, EventEmitter);
    Suite.prototype.reset = function() {
      this.delayed = false;
      function doReset(thingToReset) {
        thingToReset.reset();
      }
      this.suites.forEach(doReset);
      this.tests.forEach(doReset);
      this._beforeEach.forEach(doReset);
      this._afterEach.forEach(doReset);
      this._beforeAll.forEach(doReset);
      this._afterAll.forEach(doReset);
    };
    Suite.prototype.clone = function() {
      var suite = new Suite(this.title);
      debug("clone");
      suite.ctx = this.ctx;
      suite.root = this.root;
      suite.timeout(this.timeout());
      suite.retries(this.retries());
      suite.slow(this.slow());
      suite.bail(this.bail());
      return suite;
    };
    Suite.prototype.timeout = function(ms) {
      if (!arguments.length) {
        return this._timeout;
      }
      if (typeof ms === "string") {
        ms = milliseconds(ms);
      }
      var INT_MAX = Math.pow(2, 31) - 1;
      var range = [0, INT_MAX];
      ms = clamp(ms, range);
      debug("timeout %d", ms);
      this._timeout = parseInt(ms, 10);
      return this;
    };
    Suite.prototype.retries = function(n) {
      if (!arguments.length) {
        return this._retries;
      }
      debug("retries %d", n);
      this._retries = parseInt(n, 10) || 0;
      return this;
    };
    Suite.prototype.slow = function(ms) {
      if (!arguments.length) {
        return this._slow;
      }
      if (typeof ms === "string") {
        ms = milliseconds(ms);
      }
      debug("slow %d", ms);
      this._slow = ms;
      return this;
    };
    Suite.prototype.bail = function(bail) {
      if (!arguments.length) {
        return this._bail;
      }
      debug("bail %s", bail);
      this._bail = bail;
      return this;
    };
    Suite.prototype.isPending = function() {
      return this.pending || this.parent && this.parent.isPending();
    };
    Suite.prototype._createHook = function(title, fn) {
      var hook = new Hook(title, fn);
      hook.parent = this;
      hook.timeout(this.timeout());
      hook.retries(this.retries());
      hook.slow(this.slow());
      hook.ctx = this.ctx;
      hook.file = this.file;
      return hook;
    };
    Suite.prototype.beforeAll = function(title, fn) {
      if (this.isPending()) {
        return this;
      }
      if (typeof title === "function") {
        fn = title;
        title = fn.name;
      }
      title = '"before all" hook' + (title ? ": " + title : "");
      var hook = this._createHook(title, fn);
      this._beforeAll.push(hook);
      this.emit(constants.EVENT_SUITE_ADD_HOOK_BEFORE_ALL, hook);
      return this;
    };
    Suite.prototype.afterAll = function(title, fn) {
      if (this.isPending()) {
        return this;
      }
      if (typeof title === "function") {
        fn = title;
        title = fn.name;
      }
      title = '"after all" hook' + (title ? ": " + title : "");
      var hook = this._createHook(title, fn);
      this._afterAll.push(hook);
      this.emit(constants.EVENT_SUITE_ADD_HOOK_AFTER_ALL, hook);
      return this;
    };
    Suite.prototype.beforeEach = function(title, fn) {
      if (this.isPending()) {
        return this;
      }
      if (typeof title === "function") {
        fn = title;
        title = fn.name;
      }
      title = '"before each" hook' + (title ? ": " + title : "");
      var hook = this._createHook(title, fn);
      this._beforeEach.push(hook);
      this.emit(constants.EVENT_SUITE_ADD_HOOK_BEFORE_EACH, hook);
      return this;
    };
    Suite.prototype.afterEach = function(title, fn) {
      if (this.isPending()) {
        return this;
      }
      if (typeof title === "function") {
        fn = title;
        title = fn.name;
      }
      title = '"after each" hook' + (title ? ": " + title : "");
      var hook = this._createHook(title, fn);
      this._afterEach.push(hook);
      this.emit(constants.EVENT_SUITE_ADD_HOOK_AFTER_EACH, hook);
      return this;
    };
    Suite.prototype.addSuite = function(suite) {
      suite.parent = this;
      suite.root = false;
      suite.timeout(this.timeout());
      suite.retries(this.retries());
      suite.slow(this.slow());
      suite.bail(this.bail());
      this.suites.push(suite);
      this.emit(constants.EVENT_SUITE_ADD_SUITE, suite);
      return this;
    };
    Suite.prototype.addTest = function(test) {
      test.parent = this;
      test.timeout(this.timeout());
      test.retries(this.retries());
      test.slow(this.slow());
      test.ctx = this.ctx;
      this.tests.push(test);
      this.emit(constants.EVENT_SUITE_ADD_TEST, test);
      return this;
    };
    Suite.prototype.fullTitle = function() {
      return this.titlePath().join(" ");
    };
    Suite.prototype.titlePath = function() {
      var result = [];
      if (this.parent) {
        result = result.concat(this.parent.titlePath());
      }
      if (!this.root) {
        result.push(this.title);
      }
      return result;
    };
    Suite.prototype.total = function() {
      return this.suites.reduce(function(sum, suite) {
        return sum + suite.total();
      }, 0) + this.tests.length;
    };
    Suite.prototype.eachTest = function(fn) {
      this.tests.forEach(fn);
      this.suites.forEach(function(suite) {
        suite.eachTest(fn);
      });
      return this;
    };
    Suite.prototype.run = function run() {
      if (this.root) {
        this.emit(constants.EVENT_ROOT_SUITE_RUN);
      }
    };
    Suite.prototype.hasOnly = function hasOnly() {
      return this._onlyTests.length > 0 || this._onlySuites.length > 0 || this.suites.some(function(suite) {
        return suite.hasOnly();
      });
    };
    Suite.prototype.filterOnly = function filterOnly() {
      if (this._onlyTests.length) {
        this.tests = this._onlyTests;
        this.suites = [];
      } else {
        this.tests = [];
        this._onlySuites.forEach(function(onlySuite) {
          if (onlySuite.hasOnly()) {
            onlySuite.filterOnly();
          }
        });
        var onlySuites = this._onlySuites;
        this.suites = this.suites.filter(function(childSuite) {
          return onlySuites.indexOf(childSuite) !== -1 || childSuite.filterOnly();
        });
      }
      return this.tests.length > 0 || this.suites.length > 0;
    };
    Suite.prototype.appendOnlySuite = function(suite) {
      this._onlySuites.push(suite);
    };
    Suite.prototype.markOnly = function() {
      this.parent && this.parent.appendOnlySuite(this);
    };
    Suite.prototype.appendOnlyTest = function(test) {
      this._onlyTests.push(test);
    };
    Suite.prototype.getHooks = function getHooks(name) {
      return this["_" + name];
    };
    Suite.prototype.dispose = function() {
      this.suites.forEach(function(suite) {
        suite.dispose();
      });
      this.cleanReferences();
    };
    Suite.prototype.cleanReferences = function cleanReferences() {
      function cleanArrReferences(arr) {
        for (var i2 = 0; i2 < arr.length; i2++) {
          delete arr[i2].fn;
        }
      }
      if (Array.isArray(this._beforeAll)) {
        cleanArrReferences(this._beforeAll);
      }
      if (Array.isArray(this._beforeEach)) {
        cleanArrReferences(this._beforeEach);
      }
      if (Array.isArray(this._afterAll)) {
        cleanArrReferences(this._afterAll);
      }
      if (Array.isArray(this._afterEach)) {
        cleanArrReferences(this._afterEach);
      }
      for (var i = 0; i < this.tests.length; i++) {
        delete this.tests[i].fn;
      }
    };
    Suite.prototype.serialize = function serialize() {
      return {
        _bail: this._bail,
        $$fullTitle: this.fullTitle(),
        $$isPending: Boolean(this.isPending()),
        root: this.root,
        title: this.title,
        [MOCHA_ID_PROP_NAME]: this.id,
        parent: this.parent ? { [MOCHA_ID_PROP_NAME]: this.parent.id } : null
      };
    };
    var constants = defineConstants(
      /**
       * {@link Suite}-related constants.
       * @public
       * @memberof Suite
       * @alias constants
       * @readonly
       * @static
       * @enum {string}
       */
      {
        /**
         * Event emitted after a test file has been loaded. Not emitted in browser.
         */
        EVENT_FILE_POST_REQUIRE: "post-require",
        /**
         * Event emitted before a test file has been loaded. In browser, this is emitted once an interface has been selected.
         */
        EVENT_FILE_PRE_REQUIRE: "pre-require",
        /**
         * Event emitted immediately after a test file has been loaded. Not emitted in browser.
         */
        EVENT_FILE_REQUIRE: "require",
        /**
         * Event emitted when `global.run()` is called (use with `delay` option).
         */
        EVENT_ROOT_SUITE_RUN: "run",
        /**
         * Namespace for collection of a `Suite`'s "after all" hooks.
         */
        HOOK_TYPE_AFTER_ALL: "afterAll",
        /**
         * Namespace for collection of a `Suite`'s "after each" hooks.
         */
        HOOK_TYPE_AFTER_EACH: "afterEach",
        /**
         * Namespace for collection of a `Suite`'s "before all" hooks.
         */
        HOOK_TYPE_BEFORE_ALL: "beforeAll",
        /**
         * Namespace for collection of a `Suite`'s "before each" hooks.
         */
        HOOK_TYPE_BEFORE_EACH: "beforeEach",
        /**
         * Emitted after a child `Suite` has been added to a `Suite`.
         */
        EVENT_SUITE_ADD_SUITE: "suite",
        /**
         * Emitted after an "after all" `Hook` has been added to a `Suite`.
         */
        EVENT_SUITE_ADD_HOOK_AFTER_ALL: "afterAll",
        /**
         * Emitted after an "after each" `Hook` has been added to a `Suite`.
         */
        EVENT_SUITE_ADD_HOOK_AFTER_EACH: "afterEach",
        /**
         * Emitted after an "before all" `Hook` has been added to a `Suite`.
         */
        EVENT_SUITE_ADD_HOOK_BEFORE_ALL: "beforeAll",
        /**
         * Emitted after an "before each" `Hook` has been added to a `Suite`.
         */
        EVENT_SUITE_ADD_HOOK_BEFORE_EACH: "beforeEach",
        /**
         * Emitted after a `Test` has been added to a `Suite`.
         */
        EVENT_SUITE_ADD_TEST: "test"
      }
    );
    Suite.constants = constants;
  }
});

// node_modules/mocha/lib/runner.js
var require_runner = __commonJS({
  "node_modules/mocha/lib/runner.js"(exports, module) {
    "use strict";
    init_shim();
    var EventEmitter = require_events().EventEmitter;
    var Pending = require_pending();
    var utils = require_utils();
    var debug = require_browser3()("mocha:runner");
    var Runnable = require_runnable();
    var Suite = require_suite();
    var HOOK_TYPE_BEFORE_EACH = Suite.constants.HOOK_TYPE_BEFORE_EACH;
    var HOOK_TYPE_AFTER_EACH = Suite.constants.HOOK_TYPE_AFTER_EACH;
    var HOOK_TYPE_AFTER_ALL = Suite.constants.HOOK_TYPE_AFTER_ALL;
    var HOOK_TYPE_BEFORE_ALL = Suite.constants.HOOK_TYPE_BEFORE_ALL;
    var EVENT_ROOT_SUITE_RUN = Suite.constants.EVENT_ROOT_SUITE_RUN;
    var STATE_FAILED = Runnable.constants.STATE_FAILED;
    var STATE_PASSED = Runnable.constants.STATE_PASSED;
    var STATE_PENDING = Runnable.constants.STATE_PENDING;
    var stackFilter = utils.stackTraceFilter();
    var stringify = utils.stringify;
    var {
      createInvalidExceptionError,
      createUnsupportedError,
      createFatalError,
      isMochaError,
      constants: errorConstants
    } = require_errors();
    var globals = [
      "setTimeout",
      "clearTimeout",
      "setInterval",
      "clearInterval",
      "XMLHttpRequest",
      "Date",
      "setImmediate",
      "clearImmediate"
    ];
    var constants = utils.defineConstants(
      /**
       * {@link Runner}-related constants.
       * @public
       * @memberof Runner
       * @readonly
       * @alias constants
       * @static
       * @enum {string}
       */
      {
        /**
         * Emitted when {@link Hook} execution begins
         */
        EVENT_HOOK_BEGIN: "hook",
        /**
         * Emitted when {@link Hook} execution ends
         */
        EVENT_HOOK_END: "hook end",
        /**
         * Emitted when Root {@link Suite} execution begins (all files have been parsed and hooks/tests are ready for execution)
         */
        EVENT_RUN_BEGIN: "start",
        /**
         * Emitted when Root {@link Suite} execution has been delayed via `delay` option
         */
        EVENT_DELAY_BEGIN: "waiting",
        /**
         * Emitted when delayed Root {@link Suite} execution is triggered by user via `global.run()`
         */
        EVENT_DELAY_END: "ready",
        /**
         * Emitted when Root {@link Suite} execution ends
         */
        EVENT_RUN_END: "end",
        /**
         * Emitted when {@link Suite} execution begins
         */
        EVENT_SUITE_BEGIN: "suite",
        /**
         * Emitted when {@link Suite} execution ends
         */
        EVENT_SUITE_END: "suite end",
        /**
         * Emitted when {@link Test} execution begins
         */
        EVENT_TEST_BEGIN: "test",
        /**
         * Emitted when {@link Test} execution ends
         */
        EVENT_TEST_END: "test end",
        /**
         * Emitted when {@link Test} execution fails
         */
        EVENT_TEST_FAIL: "fail",
        /**
         * Emitted when {@link Test} execution succeeds
         */
        EVENT_TEST_PASS: "pass",
        /**
         * Emitted when {@link Test} becomes pending
         */
        EVENT_TEST_PENDING: "pending",
        /**
         * Emitted when {@link Test} execution has failed, but will retry
         */
        EVENT_TEST_RETRY: "retry",
        /**
         * Initial state of Runner
         */
        STATE_IDLE: "idle",
        /**
         * State set to this value when the Runner has started running
         */
        STATE_RUNNING: "running",
        /**
         * State set to this value when the Runner has stopped
         */
        STATE_STOPPED: "stopped"
      }
    );
    var Runner = class extends EventEmitter {
      /**
       * Initialize a `Runner` at the Root {@link Suite}, which represents a hierarchy of {@link Suite|Suites} and {@link Test|Tests}.
       *
       * @extends external:EventEmitter
       * @public
       * @class
       * @param {Suite} suite - Root suite
       * @param {Object} [opts] - Settings object
       * @param {boolean} [opts.cleanReferencesAfterRun] - Whether to clean references to test fns and hooks when a suite is done.
       * @param {boolean} [opts.delay] - Whether to delay execution of root suite until ready.
       * @param {boolean} [opts.dryRun] - Whether to report tests without running them.
       * @param {boolean} [opts.failZero] - Whether to fail test run if zero tests encountered.
       */
      constructor(suite, opts = {}) {
        super();
        var self2 = this;
        this._globals = [];
        this._abort = false;
        this.suite = suite;
        this._opts = opts;
        this.state = constants.STATE_IDLE;
        this.total = suite.total();
        this.failures = 0;
        this._eventListeners = /* @__PURE__ */ new Map();
        this.on(constants.EVENT_TEST_END, function(test) {
          if (test.type === "test" && test.retriedTest() && test.parent) {
            var idx = test.parent.tests && test.parent.tests.indexOf(test.retriedTest());
            if (idx > -1)
              test.parent.tests[idx] = test;
          }
          self2.checkGlobals(test);
        });
        this.on(constants.EVENT_HOOK_END, function(hook) {
          self2.checkGlobals(hook);
        });
        this._defaultGrep = /.*/;
        this.grep(this._defaultGrep);
        this.globals(this.globalProps());
        this.uncaught = this._uncaught.bind(this);
        this.unhandled = (reason, promise) => {
          if (isMochaError(reason)) {
            debug(
              "trapped unhandled rejection coming out of Mocha; forwarding to uncaught handler:",
              reason
            );
            this.uncaught(reason);
          } else {
            debug(
              "trapped unhandled rejection from (probably) user code; re-emitting on process"
            );
            this._removeEventListener(
              import_process.default,
              "unhandledRejection",
              this.unhandled
            );
            try {
              import_process.default.emit("unhandledRejection", reason, promise);
            } finally {
              this._addEventListener(import_process.default, "unhandledRejection", this.unhandled);
            }
          }
        };
      }
    };
    Runner.immediately = _global.setImmediate || import_process.default.nextTick;
    Runner.prototype._addEventListener = function(target, eventName, listener) {
      debug(
        "_addEventListener(): adding for event %s; %d current listeners",
        eventName,
        target.listenerCount(eventName)
      );
      if (this._eventListeners.has(target) && this._eventListeners.get(target).has(eventName) && this._eventListeners.get(target).get(eventName).has(listener)) {
        debug(
          "warning: tried to attach duplicate event listener for %s",
          eventName
        );
        return;
      }
      target.on(eventName, listener);
      const targetListeners = this._eventListeners.has(target) ? this._eventListeners.get(target) : /* @__PURE__ */ new Map();
      const targetEventListeners = targetListeners.has(eventName) ? targetListeners.get(eventName) : /* @__PURE__ */ new Set();
      targetEventListeners.add(listener);
      targetListeners.set(eventName, targetEventListeners);
      this._eventListeners.set(target, targetListeners);
    };
    Runner.prototype._removeEventListener = function(target, eventName, listener) {
      target.removeListener(eventName, listener);
      if (this._eventListeners.has(target)) {
        const targetListeners = this._eventListeners.get(target);
        if (targetListeners.has(eventName)) {
          const targetEventListeners = targetListeners.get(eventName);
          targetEventListeners.delete(listener);
          if (!targetEventListeners.size) {
            targetListeners.delete(eventName);
          }
        }
        if (!targetListeners.size) {
          this._eventListeners.delete(target);
        }
      } else {
        debug("trying to remove listener for untracked object %s", target);
      }
    };
    Runner.prototype.dispose = function() {
      this.removeAllListeners();
      this._eventListeners.forEach((targetListeners, target) => {
        targetListeners.forEach((targetEventListeners, eventName) => {
          targetEventListeners.forEach((listener) => {
            target.removeListener(eventName, listener);
          });
        });
      });
      this._eventListeners.clear();
    };
    Runner.prototype.grep = function(re, invert) {
      debug("grep(): setting to %s", re);
      this._grep = re;
      this._invert = invert;
      this.total = this.grepTotal(this.suite);
      return this;
    };
    Runner.prototype.grepTotal = function(suite) {
      var self2 = this;
      var total = 0;
      suite.eachTest(function(test) {
        var match = self2._grep.test(test.fullTitle());
        if (self2._invert) {
          match = !match;
        }
        if (match) {
          total++;
        }
      });
      return total;
    };
    Runner.prototype.globalProps = function() {
      var props = Object.keys(_global);
      for (var i = 0; i < globals.length; ++i) {
        if (~props.indexOf(globals[i])) {
          continue;
        }
        props.push(globals[i]);
      }
      return props;
    };
    Runner.prototype.globals = function(arr) {
      if (!arguments.length) {
        return this._globals;
      }
      debug("globals(): setting to %O", arr);
      this._globals = this._globals.concat(arr);
      return this;
    };
    Runner.prototype.checkGlobals = function(test) {
      if (!this.checkLeaks) {
        return;
      }
      var ok = this._globals;
      var globals2 = this.globalProps();
      var leaks;
      if (test) {
        ok = ok.concat(test._allowedGlobals || []);
      }
      if (this.prevGlobalsLength === globals2.length) {
        return;
      }
      this.prevGlobalsLength = globals2.length;
      leaks = filterLeaks(ok, globals2);
      this._globals = this._globals.concat(leaks);
      if (leaks.length) {
        var msg = `global leak(s) detected: ${leaks.map((e) => `'${e}'`).join(", ")}`;
        this.fail(test, new Error(msg));
      }
    };
    Runner.prototype.fail = function(test, err, force) {
      force = force === true;
      if (test.isPending() && !force) {
        return;
      }
      if (this.state === constants.STATE_STOPPED) {
        if (err.code === errorConstants.MULTIPLE_DONE) {
          throw err;
        }
        throw createFatalError(
          "Test failed after root suite execution completed!",
          err
        );
      }
      ++this.failures;
      debug("total number of failures: %d", this.failures);
      test.state = STATE_FAILED;
      if (!isError(err)) {
        err = thrown2Error(err);
      }
      try {
        err.stack = this.fullStackTrace || !err.stack ? err.stack : stackFilter(err.stack);
      } catch (ignore) {
      }
      this.emit(constants.EVENT_TEST_FAIL, test, err);
    };
    Runner.prototype.hook = function(name, fn) {
      if (this._opts.dryRun)
        return fn();
      var suite = this.suite;
      var hooks = suite.getHooks(name);
      var self2 = this;
      function next(i) {
        var hook = hooks[i];
        if (!hook) {
          return fn();
        }
        self2.currentRunnable = hook;
        if (name === HOOK_TYPE_BEFORE_ALL) {
          hook.ctx.currentTest = hook.parent.tests[0];
        } else if (name === HOOK_TYPE_AFTER_ALL) {
          hook.ctx.currentTest = hook.parent.tests[hook.parent.tests.length - 1];
        } else {
          hook.ctx.currentTest = self2.test;
        }
        setHookTitle(hook);
        hook.allowUncaught = self2.allowUncaught;
        self2.emit(constants.EVENT_HOOK_BEGIN, hook);
        if (!hook.listeners("error").length) {
          self2._addEventListener(hook, "error", function(err) {
            self2.fail(hook, err);
          });
        }
        hook.run(function cbHookRun(err) {
          var testError = hook.error();
          if (testError) {
            self2.fail(self2.test, testError);
          }
          if (hook.pending) {
            if (name === HOOK_TYPE_AFTER_EACH) {
              if (self2.test) {
                self2.test.pending = true;
              }
            } else if (name === HOOK_TYPE_BEFORE_EACH) {
              if (self2.test) {
                self2.test.pending = true;
              }
              self2.emit(constants.EVENT_HOOK_END, hook);
              hook.pending = false;
              return fn(new Error("abort hookDown"));
            } else if (name === HOOK_TYPE_BEFORE_ALL) {
              suite.tests.forEach(function(test) {
                test.pending = true;
              });
              suite.suites.forEach(function(suite2) {
                suite2.pending = true;
              });
              hooks = [];
            } else {
              hook.pending = false;
              var errForbid = createUnsupportedError("`this.skip` forbidden");
              self2.fail(hook, errForbid);
              return fn(errForbid);
            }
          } else if (err) {
            self2.fail(hook, err);
            return fn(err);
          }
          self2.emit(constants.EVENT_HOOK_END, hook);
          delete hook.ctx.currentTest;
          setHookTitle(hook);
          next(++i);
        });
        function setHookTitle(hook2) {
          hook2.originalTitle = hook2.originalTitle || hook2.title;
          if (hook2.ctx && hook2.ctx.currentTest) {
            hook2.title = `${hook2.originalTitle} for "${hook2.ctx.currentTest.title}"`;
          } else {
            var parentTitle;
            if (hook2.parent.title) {
              parentTitle = hook2.parent.title;
            } else {
              parentTitle = hook2.parent.root ? "{root}" : "";
            }
            hook2.title = `${hook2.originalTitle} in "${parentTitle}"`;
          }
        }
      }
      Runner.immediately(function() {
        next(0);
      });
    };
    Runner.prototype.hooks = function(name, suites, fn) {
      var self2 = this;
      var orig = this.suite;
      function next(suite) {
        self2.suite = suite;
        if (!suite) {
          self2.suite = orig;
          return fn();
        }
        self2.hook(name, function(err) {
          if (err) {
            var errSuite = self2.suite;
            self2.suite = orig;
            return fn(err, errSuite);
          }
          next(suites.pop());
        });
      }
      next(suites.pop());
    };
    Runner.prototype.hookUp = function(name, fn) {
      var suites = [this.suite].concat(this.parents()).reverse();
      this.hooks(name, suites, fn);
    };
    Runner.prototype.hookDown = function(name, fn) {
      var suites = [this.suite].concat(this.parents());
      this.hooks(name, suites, fn);
    };
    Runner.prototype.parents = function() {
      var suite = this.suite;
      var suites = [];
      while (suite.parent) {
        suite = suite.parent;
        suites.push(suite);
      }
      return suites;
    };
    Runner.prototype.runTest = function(fn) {
      if (this._opts.dryRun)
        return Runner.immediately(fn);
      var self2 = this;
      var test = this.test;
      if (!test) {
        return;
      }
      if (this.asyncOnly) {
        test.asyncOnly = true;
      }
      this._addEventListener(test, "error", function(err) {
        self2.fail(test, err);
      });
      if (this.allowUncaught) {
        test.allowUncaught = true;
        return test.run(fn);
      }
      try {
        test.run(fn);
      } catch (err) {
        fn(err);
      }
    };
    Runner.prototype.runTests = function(suite, fn) {
      var self2 = this;
      var tests = suite.tests.slice();
      var test;
      function hookErr(_, errSuite, after) {
        var orig = self2.suite;
        self2.suite = after ? errSuite.parent : errSuite;
        if (self2.suite) {
          self2.hookUp(HOOK_TYPE_AFTER_EACH, function(err2, errSuite2) {
            self2.suite = orig;
            if (err2) {
              return hookErr(err2, errSuite2, true);
            }
            fn(errSuite);
          });
        } else {
          self2.suite = orig;
          fn(errSuite);
        }
      }
      function next(err, errSuite) {
        if (self2.failures && suite._bail) {
          tests = [];
        }
        if (self2._abort) {
          return fn();
        }
        if (err) {
          return hookErr(err, errSuite, true);
        }
        test = tests.shift();
        if (!test) {
          return fn();
        }
        var match = self2._grep.test(test.fullTitle());
        if (self2._invert) {
          match = !match;
        }
        if (!match) {
          if (self2._grep !== self2._defaultGrep) {
            Runner.immediately(next);
          } else {
            next();
          }
          return;
        }
        if (test.isPending()) {
          if (self2.forbidPending) {
            self2.fail(test, new Error("Pending test forbidden"), true);
          } else {
            test.state = STATE_PENDING;
            self2.emit(constants.EVENT_TEST_PENDING, test);
          }
          self2.emit(constants.EVENT_TEST_END, test);
          return next();
        }
        self2.emit(constants.EVENT_TEST_BEGIN, self2.test = test);
        self2.hookDown(HOOK_TYPE_BEFORE_EACH, function(err2, errSuite2) {
          if (test.isPending()) {
            if (self2.forbidPending) {
              self2.fail(test, new Error("Pending test forbidden"), true);
            } else {
              test.state = STATE_PENDING;
              self2.emit(constants.EVENT_TEST_PENDING, test);
            }
            self2.emit(constants.EVENT_TEST_END, test);
            var origSuite = self2.suite;
            self2.suite = errSuite2 || self2.suite;
            return self2.hookUp(HOOK_TYPE_AFTER_EACH, function(e, eSuite) {
              self2.suite = origSuite;
              next(e, eSuite);
            });
          }
          if (err2) {
            return hookErr(err2, errSuite2, false);
          }
          self2.currentRunnable = self2.test;
          self2.runTest(function(err3) {
            test = self2.test;
            if (test.pending) {
              if (self2.forbidPending) {
                self2.fail(test, new Error("Pending test forbidden"), true);
              } else {
                test.state = STATE_PENDING;
                self2.emit(constants.EVENT_TEST_PENDING, test);
              }
              self2.emit(constants.EVENT_TEST_END, test);
              return self2.hookUp(HOOK_TYPE_AFTER_EACH, next);
            } else if (err3) {
              var retry = test.currentRetry();
              if (retry < test.retries()) {
                var clonedTest = test.clone();
                clonedTest.currentRetry(retry + 1);
                tests.unshift(clonedTest);
                self2.emit(constants.EVENT_TEST_RETRY, test, err3);
                return self2.hookUp(HOOK_TYPE_AFTER_EACH, next);
              } else {
                self2.fail(test, err3);
              }
              self2.emit(constants.EVENT_TEST_END, test);
              return self2.hookUp(HOOK_TYPE_AFTER_EACH, next);
            }
            test.state = STATE_PASSED;
            self2.emit(constants.EVENT_TEST_PASS, test);
            self2.emit(constants.EVENT_TEST_END, test);
            self2.hookUp(HOOK_TYPE_AFTER_EACH, next);
          });
        });
      }
      this.next = next;
      this.hookErr = hookErr;
      next();
    };
    Runner.prototype.runSuite = function(suite, fn) {
      var i = 0;
      var self2 = this;
      var total = this.grepTotal(suite);
      debug("runSuite(): running %s", suite.fullTitle());
      if (!total || self2.failures && suite._bail) {
        debug("runSuite(): bailing");
        return fn();
      }
      this.emit(constants.EVENT_SUITE_BEGIN, this.suite = suite);
      function next(errSuite) {
        if (errSuite) {
          if (errSuite === suite) {
            return done();
          }
          return done(errSuite);
        }
        if (self2._abort) {
          return done();
        }
        var curr = suite.suites[i++];
        if (!curr) {
          return done();
        }
        if (self2._grep !== self2._defaultGrep) {
          Runner.immediately(function() {
            self2.runSuite(curr, next);
          });
        } else {
          self2.runSuite(curr, next);
        }
      }
      function done(errSuite) {
        self2.suite = suite;
        self2.nextSuite = next;
        delete self2.test;
        self2.hook(HOOK_TYPE_AFTER_ALL, function() {
          self2.emit(constants.EVENT_SUITE_END, suite);
          fn(errSuite);
        });
      }
      this.nextSuite = next;
      this.hook(HOOK_TYPE_BEFORE_ALL, function(err) {
        if (err) {
          return done();
        }
        self2.runTests(suite, next);
      });
    };
    Runner.prototype._uncaught = function(err) {
      if (!(this instanceof Runner)) {
        throw createFatalError(
          "Runner#uncaught() called with invalid context",
          this
        );
      }
      if (err instanceof Pending) {
        debug("uncaught(): caught a Pending");
        return;
      }
      if (this.allowUncaught && !utils.isBrowser()) {
        debug("uncaught(): bubbling exception due to --allow-uncaught");
        throw err;
      }
      if (this.state === constants.STATE_STOPPED) {
        debug("uncaught(): throwing after run has completed!");
        throw err;
      }
      if (err) {
        debug("uncaught(): got truthy exception %O", err);
      } else {
        debug("uncaught(): undefined/falsy exception");
        err = createInvalidExceptionError(
          "Caught falsy/undefined exception which would otherwise be uncaught. No stack trace found; try a debugger",
          err
        );
      }
      if (!isError(err)) {
        err = thrown2Error(err);
        debug('uncaught(): converted "error" %o to Error', err);
      }
      err.uncaught = true;
      var runnable = this.currentRunnable;
      if (!runnable) {
        runnable = new Runnable("Uncaught error outside test suite");
        debug("uncaught(): no current Runnable; created a phony one");
        runnable.parent = this.suite;
        if (this.state === constants.STATE_RUNNING) {
          debug("uncaught(): failing gracefully");
          this.fail(runnable, err);
        } else {
          debug("uncaught(): test run has not yet started; unrecoverable");
          this.emit(constants.EVENT_RUN_BEGIN);
          this.fail(runnable, err);
          this.emit(constants.EVENT_RUN_END);
        }
        return;
      }
      runnable.clearTimeout();
      if (runnable.isFailed()) {
        debug("uncaught(): Runnable has already failed");
        return;
      } else if (runnable.isPending()) {
        debug("uncaught(): pending Runnable wound up failing!");
        this.fail(runnable, err, true);
        return;
      }
      if (runnable.isPassed()) {
        debug("uncaught(): Runnable has already passed; bailing gracefully");
        this.fail(runnable, err);
        this.abort();
      } else {
        debug("uncaught(): forcing Runnable to complete with Error");
        return runnable.callback(err);
      }
    };
    Runner.prototype.run = function(fn, opts = {}) {
      var rootSuite = this.suite;
      var options = opts.options || {};
      debug("run(): got options: %O", options);
      fn = fn || function() {
      };
      const end = () => {
        if (!this.total && this._opts.failZero)
          this.failures = 1;
        debug("run(): root suite completed; emitting %s", constants.EVENT_RUN_END);
        this.emit(constants.EVENT_RUN_END);
      };
      const begin = () => {
        debug("run(): emitting %s", constants.EVENT_RUN_BEGIN);
        this.emit(constants.EVENT_RUN_BEGIN);
        debug("run(): emitted %s", constants.EVENT_RUN_BEGIN);
        this.runSuite(rootSuite, end);
      };
      const prepare = () => {
        debug("run(): starting");
        if (rootSuite.hasOnly()) {
          rootSuite.filterOnly();
          debug("run(): filtered exclusive Runnables");
        }
        this.state = constants.STATE_RUNNING;
        if (this._opts.delay) {
          this.emit(constants.EVENT_DELAY_END);
          debug('run(): "delay" ended');
        }
        return begin();
      };
      if (this._opts.cleanReferencesAfterRun) {
        this.on(constants.EVENT_SUITE_END, (suite) => {
          suite.cleanReferences();
        });
      }
      this.on(constants.EVENT_RUN_END, function() {
        this.state = constants.STATE_STOPPED;
        debug("run(): emitted %s", constants.EVENT_RUN_END);
        fn(this.failures);
      });
      this._removeEventListener(import_process.default, "uncaughtException", this.uncaught);
      this._removeEventListener(import_process.default, "unhandledRejection", this.unhandled);
      this._addEventListener(import_process.default, "uncaughtException", this.uncaught);
      this._addEventListener(import_process.default, "unhandledRejection", this.unhandled);
      if (this._opts.delay) {
        this.emit(constants.EVENT_DELAY_BEGIN, rootSuite);
        rootSuite.once(EVENT_ROOT_SUITE_RUN, prepare);
        debug("run(): waiting for green light due to --delay");
      } else {
        Runner.immediately(prepare);
      }
      return this;
    };
    Runner.prototype.linkPartialObjects = function(value) {
      return this;
    };
    Runner.prototype.runAsync = async function runAsync(opts = {}) {
      return new Promise((resolve) => {
        this.run(resolve, opts);
      });
    };
    Runner.prototype.abort = function() {
      debug("abort(): aborting");
      this._abort = true;
      return this;
    };
    Runner.prototype.isParallelMode = function isParallelMode() {
      return false;
    };
    Runner.prototype.workerReporter = function() {
      throw createUnsupportedError("workerReporter() not supported in serial mode");
    };
    function filterLeaks(ok, globals2) {
      return globals2.filter(function(key) {
        if (/^\d+/.test(key)) {
          return false;
        }
        if (_global.navigator && /^getInterface/.test(key)) {
          return false;
        }
        if (_global.navigator && /^\d+/.test(key)) {
          return false;
        }
        if (/^mocha-/.test(key)) {
          return false;
        }
        var matched = ok.filter(function(ok2) {
          if (~ok2.indexOf("*")) {
            return key.indexOf(ok2.split("*")[0]) === 0;
          }
          return key === ok2;
        });
        return !matched.length && (!_global.navigator || key !== "onerror");
      });
    }
    function isError(err) {
      return err instanceof Error || err && typeof err.message === "string";
    }
    function thrown2Error(err) {
      return new Error(
        `the ${utils.canonicalType(err)} ${stringify(
          err
        )} was thrown, throw an Error :)`
      );
    }
    Runner.constants = constants;
    module.exports = Runner;
  }
});

// node_modules/mocha/lib/reporters/base.js
var require_base2 = __commonJS({
  "node_modules/mocha/lib/reporters/base.js"(exports, module) {
    "use strict";
    init_shim();
    var diff = require_lib();
    var milliseconds = require_ms();
    var utils = require_utils();
    var supportsColor = require_supports_color();
    var symbols = require_browser2();
    var constants = require_runner().constants;
    var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
    var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;
    var isBrowser = utils.isBrowser();
    function getBrowserWindowSize() {
      if ("innerHeight" in _global) {
        return [_global.innerHeight, _global.innerWidth];
      }
      return [640, 480];
    }
    exports = module.exports = Base;
    var isatty = isBrowser || import_process.default.stdout.isTTY && import_process.default.stderr.isTTY;
    var consoleLog = console.log;
    exports.useColors = !isBrowser && (supportsColor.stdout || import_process.default.env.MOCHA_COLORS !== void 0);
    exports.inlineDiffs = false;
    exports.maxDiffSize = 8192;
    exports.colors = {
      pass: 90,
      fail: 31,
      "bright pass": 92,
      "bright fail": 91,
      "bright yellow": 93,
      pending: 36,
      suite: 0,
      "error title": 0,
      "error message": 31,
      "error stack": 90,
      checkmark: 32,
      fast: 90,
      medium: 33,
      slow: 31,
      green: 32,
      light: 90,
      "diff gutter": 90,
      "diff added": 32,
      "diff removed": 31,
      "diff added inline": "30;42",
      "diff removed inline": "30;41"
    };
    exports.symbols = {
      ok: symbols.success,
      err: symbols.error,
      dot: ".",
      comma: ",",
      bang: "!"
    };
    var color = exports.color = function(type, str) {
      if (!exports.useColors) {
        return String(str);
      }
      return "\x1B[" + exports.colors[type] + "m" + str + "\x1B[0m";
    };
    exports.window = {
      width: 75
    };
    if (isatty) {
      if (isBrowser) {
        exports.window.width = getBrowserWindowSize()[1];
      } else {
        exports.window.width = import_process.default.stdout.getWindowSize(1)[0];
      }
    }
    exports.cursor = {
      hide: function() {
        isatty && import_process.default.stdout.write("\x1B[?25l");
      },
      show: function() {
        isatty && import_process.default.stdout.write("\x1B[?25h");
      },
      deleteLine: function() {
        isatty && import_process.default.stdout.write("\x1B[2K");
      },
      beginningOfLine: function() {
        isatty && import_process.default.stdout.write("\x1B[0G");
      },
      CR: function() {
        if (isatty) {
          exports.cursor.deleteLine();
          exports.cursor.beginningOfLine();
        } else {
          import_process.default.stdout.write("\r");
        }
      }
    };
    var showDiff = exports.showDiff = function(err) {
      return err && err.showDiff !== false && sameType(err.actual, err.expected) && err.expected !== void 0;
    };
    function stringifyDiffObjs(err) {
      if (!utils.isString(err.actual) || !utils.isString(err.expected)) {
        err.actual = utils.stringify(err.actual);
        err.expected = utils.stringify(err.expected);
      }
    }
    var generateDiff = exports.generateDiff = function(actual, expected) {
      try {
        var maxLen = exports.maxDiffSize;
        var skipped = 0;
        if (maxLen > 0) {
          skipped = Math.max(actual.length - maxLen, expected.length - maxLen);
          actual = actual.slice(0, maxLen);
          expected = expected.slice(0, maxLen);
        }
        let result = exports.inlineDiffs ? inlineDiff(actual, expected) : unifiedDiff(actual, expected);
        if (skipped > 0) {
          result = `${result}
      [mocha] output truncated to ${maxLen} characters, see "maxDiffSize" reporter-option
`;
        }
        return result;
      } catch (err) {
        var msg = "\n      " + color("diff added", "+ expected") + " " + color("diff removed", "- actual:  failed to generate Mocha diff") + "\n";
        return msg;
      }
    };
    exports.list = function(failures) {
      var multipleErr, multipleTest;
      Base.consoleLog();
      failures.forEach(function(test, i) {
        var fmt = color("error title", "  %s) %s:\n") + color("error message", "     %s") + color("error stack", "\n%s\n");
        var msg;
        var err;
        if (test.err && test.err.multiple) {
          if (multipleTest !== test) {
            multipleTest = test;
            multipleErr = [test.err].concat(test.err.multiple);
          }
          err = multipleErr.shift();
        } else {
          err = test.err;
        }
        var message;
        if (typeof err.inspect === "function") {
          message = err.inspect() + "";
        } else if (err.message && typeof err.message.toString === "function") {
          message = err.message + "";
        } else {
          message = "";
        }
        var stack = err.stack || message;
        var index = message ? stack.indexOf(message) : -1;
        if (index === -1) {
          msg = message;
        } else {
          index += message.length;
          msg = stack.slice(0, index);
          stack = stack.slice(index + 1);
        }
        if (err.uncaught) {
          msg = "Uncaught " + msg;
        }
        if (!exports.hideDiff && showDiff(err)) {
          stringifyDiffObjs(err);
          fmt = color("error title", "  %s) %s:\n%s") + color("error stack", "\n%s\n");
          var match = message.match(/^([^:]+): expected/);
          msg = "\n      " + color("error message", match ? match[1] : msg);
          msg += generateDiff(err.actual, err.expected);
        }
        stack = stack.replace(/^/gm, "  ");
        var testTitle = "";
        test.titlePath().forEach(function(str, index2) {
          if (index2 !== 0) {
            testTitle += "\n     ";
          }
          for (var i2 = 0; i2 < index2; i2++) {
            testTitle += "  ";
          }
          testTitle += str;
        });
        Base.consoleLog(fmt, i + 1, testTitle, msg, stack);
      });
    };
    function Base(runner, options) {
      var failures = this.failures = [];
      if (!runner) {
        throw new TypeError("Missing runner argument");
      }
      this.options = options || {};
      this.runner = runner;
      this.stats = runner.stats;
      var maxDiffSizeOpt = this.options.reporterOption && this.options.reporterOption.maxDiffSize;
      if (maxDiffSizeOpt !== void 0 && !isNaN(Number(maxDiffSizeOpt))) {
        exports.maxDiffSize = Number(maxDiffSizeOpt);
      }
      runner.on(EVENT_TEST_PASS, function(test) {
        if (test.duration > test.slow()) {
          test.speed = "slow";
        } else if (test.duration > test.slow() / 2) {
          test.speed = "medium";
        } else {
          test.speed = "fast";
        }
      });
      runner.on(EVENT_TEST_FAIL, function(test, err) {
        if (showDiff(err)) {
          stringifyDiffObjs(err);
        }
        if (test.err && err instanceof Error) {
          test.err.multiple = (test.err.multiple || []).concat(err);
        } else {
          test.err = err;
        }
        failures.push(test);
      });
    }
    Base.prototype.epilogue = function() {
      var stats = this.stats;
      var fmt;
      Base.consoleLog();
      fmt = color("bright pass", " ") + color("green", " %d passing") + color("light", " (%s)");
      Base.consoleLog(fmt, stats.passes || 0, milliseconds(stats.duration));
      if (stats.pending) {
        fmt = color("pending", " ") + color("pending", " %d pending");
        Base.consoleLog(fmt, stats.pending);
      }
      if (stats.failures) {
        fmt = color("fail", "  %d failing");
        Base.consoleLog(fmt, stats.failures);
        Base.list(this.failures);
        Base.consoleLog();
      }
      Base.consoleLog();
    };
    function pad(str, len) {
      str = String(str);
      return Array(len - str.length + 1).join(" ") + str;
    }
    function inlineDiff(actual, expected) {
      var msg = errorDiff(actual, expected);
      var lines = msg.split("\n");
      if (lines.length > 4) {
        var width = String(lines.length).length;
        msg = lines.map(function(str, i) {
          return pad(++i, width) + " | " + str;
        }).join("\n");
      }
      msg = "\n" + color("diff removed inline", "actual") + " " + color("diff added inline", "expected") + "\n\n" + msg + "\n";
      msg = msg.replace(/^/gm, "      ");
      return msg;
    }
    function unifiedDiff(actual, expected) {
      var indent = "      ";
      function cleanUp(line) {
        if (line[0] === "+") {
          return indent + colorLines("diff added", line);
        }
        if (line[0] === "-") {
          return indent + colorLines("diff removed", line);
        }
        if (line.match(/@@/)) {
          return "--";
        }
        if (line.match(/\\ No newline/)) {
          return null;
        }
        return indent + line;
      }
      function notBlank(line) {
        return typeof line !== "undefined" && line !== null;
      }
      var msg = diff.createPatch("string", actual, expected);
      var lines = msg.split("\n").splice(5);
      return "\n      " + colorLines("diff added", "+ expected") + " " + colorLines("diff removed", "- actual") + "\n\n" + lines.map(cleanUp).filter(notBlank).join("\n");
    }
    function errorDiff(actual, expected) {
      return diff.diffWordsWithSpace(actual, expected).map(function(str) {
        if (str.added) {
          return colorLines("diff added inline", str.value);
        }
        if (str.removed) {
          return colorLines("diff removed inline", str.value);
        }
        return str.value;
      }).join("");
    }
    function colorLines(name, str) {
      return str.split("\n").map(function(str2) {
        return color(name, str2);
      }).join("\n");
    }
    var objToString = Object.prototype.toString;
    function sameType(a, b) {
      return objToString.call(a) === objToString.call(b);
    }
    Base.consoleLog = consoleLog;
    Base.abstract = true;
  }
});

// node_modules/mocha/lib/reporters/dot.js
var require_dot = __commonJS({
  "node_modules/mocha/lib/reporters/dot.js"(exports, module) {
    "use strict";
    init_shim();
    var Base = require_base2();
    var inherits = require_utils().inherits;
    var constants = require_runner().constants;
    var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
    var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;
    var EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;
    var EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;
    var EVENT_RUN_END = constants.EVENT_RUN_END;
    exports = module.exports = Dot;
    function Dot(runner, options) {
      Base.call(this, runner, options);
      var self2 = this;
      var width = Base.window.width * 0.75 | 0;
      var n = -1;
      runner.on(EVENT_RUN_BEGIN, function() {
        import_process.default.stdout.write("\n");
      });
      runner.on(EVENT_TEST_PENDING, function() {
        if (++n % width === 0) {
          import_process.default.stdout.write("\n  ");
        }
        import_process.default.stdout.write(Base.color("pending", Base.symbols.comma));
      });
      runner.on(EVENT_TEST_PASS, function(test) {
        if (++n % width === 0) {
          import_process.default.stdout.write("\n  ");
        }
        if (test.speed === "slow") {
          import_process.default.stdout.write(Base.color("bright yellow", Base.symbols.dot));
        } else {
          import_process.default.stdout.write(Base.color(test.speed, Base.symbols.dot));
        }
      });
      runner.on(EVENT_TEST_FAIL, function() {
        if (++n % width === 0) {
          import_process.default.stdout.write("\n  ");
        }
        import_process.default.stdout.write(Base.color("fail", Base.symbols.bang));
      });
      runner.once(EVENT_RUN_END, function() {
        import_process.default.stdout.write("\n");
        self2.epilogue();
      });
    }
    inherits(Dot, Base);
    Dot.description = "dot matrix representation";
  }
});

// node_modules/mocha/lib/reporters/doc.js
var require_doc = __commonJS({
  "node_modules/mocha/lib/reporters/doc.js"(exports, module) {
    "use strict";
    init_shim();
    var Base = require_base2();
    var utils = require_utils();
    var constants = require_runner().constants;
    var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
    var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;
    var EVENT_SUITE_BEGIN = constants.EVENT_SUITE_BEGIN;
    var EVENT_SUITE_END = constants.EVENT_SUITE_END;
    exports = module.exports = Doc;
    function Doc(runner, options) {
      Base.call(this, runner, options);
      var indents = 2;
      function indent() {
        return Array(indents).join("  ");
      }
      runner.on(EVENT_SUITE_BEGIN, function(suite) {
        if (suite.root) {
          return;
        }
        ++indents;
        Base.consoleLog('%s<section class="suite">', indent());
        ++indents;
        Base.consoleLog("%s<h1>%s</h1>", indent(), utils.escape(suite.title));
        Base.consoleLog("%s<dl>", indent());
      });
      runner.on(EVENT_SUITE_END, function(suite) {
        if (suite.root) {
          return;
        }
        Base.consoleLog("%s</dl>", indent());
        --indents;
        Base.consoleLog("%s</section>", indent());
        --indents;
      });
      runner.on(EVENT_TEST_PASS, function(test) {
        Base.consoleLog("%s  <dt>%s</dt>", indent(), utils.escape(test.title));
        Base.consoleLog("%s  <dt>%s</dt>", indent(), utils.escape(test.file));
        var code = utils.escape(utils.clean(test.body));
        Base.consoleLog("%s  <dd><pre><code>%s</code></pre></dd>", indent(), code);
      });
      runner.on(EVENT_TEST_FAIL, function(test, err) {
        Base.consoleLog(
          '%s  <dt class="error">%s</dt>',
          indent(),
          utils.escape(test.title)
        );
        Base.consoleLog(
          '%s  <dt class="error">%s</dt>',
          indent(),
          utils.escape(test.file)
        );
        var code = utils.escape(utils.clean(test.body));
        Base.consoleLog(
          '%s  <dd class="error"><pre><code>%s</code></pre></dd>',
          indent(),
          code
        );
        Base.consoleLog(
          '%s  <dd class="error">%s</dd>',
          indent(),
          utils.escape(err)
        );
      });
    }
    Doc.description = "HTML documentation";
  }
});

// node_modules/mocha/lib/reporters/tap.js
var require_tap = __commonJS({
  "node_modules/mocha/lib/reporters/tap.js"(exports, module) {
    "use strict";
    init_shim();
    var util = require_util();
    var Base = require_base2();
    var constants = require_runner().constants;
    var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
    var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;
    var EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;
    var EVENT_RUN_END = constants.EVENT_RUN_END;
    var EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;
    var EVENT_TEST_END = constants.EVENT_TEST_END;
    var inherits = require_utils().inherits;
    var sprintf = util.format;
    exports = module.exports = TAP;
    function TAP(runner, options) {
      Base.call(this, runner, options);
      var self2 = this;
      var n = 1;
      var tapVersion = "12";
      if (options && options.reporterOptions) {
        if (options.reporterOptions.tapVersion) {
          tapVersion = options.reporterOptions.tapVersion.toString();
        }
      }
      this._producer = createProducer(tapVersion);
      runner.once(EVENT_RUN_BEGIN, function() {
        self2._producer.writeVersion();
      });
      runner.on(EVENT_TEST_END, function() {
        ++n;
      });
      runner.on(EVENT_TEST_PENDING, function(test) {
        self2._producer.writePending(n, test);
      });
      runner.on(EVENT_TEST_PASS, function(test) {
        self2._producer.writePass(n, test);
      });
      runner.on(EVENT_TEST_FAIL, function(test, err) {
        self2._producer.writeFail(n, test, err);
      });
      runner.once(EVENT_RUN_END, function() {
        self2._producer.writeEpilogue(runner.stats);
      });
    }
    inherits(TAP, Base);
    function title(test) {
      return test.fullTitle().replace(/#/g, "");
    }
    function println(format, varArgs) {
      var vargs = Array.from(arguments);
      vargs[0] += "\n";
      import_process.default.stdout.write(sprintf.apply(null, vargs));
    }
    function createProducer(tapVersion) {
      var producers = {
        12: new TAP12Producer(),
        13: new TAP13Producer()
      };
      var producer = producers[tapVersion];
      if (!producer) {
        throw new Error(
          "invalid or unsupported TAP version: " + JSON.stringify(tapVersion)
        );
      }
      return producer;
    }
    function TAPProducer() {
    }
    TAPProducer.prototype.writeVersion = function() {
    };
    TAPProducer.prototype.writePlan = function(ntests) {
      println("%d..%d", 1, ntests);
    };
    TAPProducer.prototype.writePass = function(n, test) {
      println("ok %d %s", n, title(test));
    };
    TAPProducer.prototype.writePending = function(n, test) {
      println("ok %d %s # SKIP -", n, title(test));
    };
    TAPProducer.prototype.writeFail = function(n, test, err) {
      println("not ok %d %s", n, title(test));
    };
    TAPProducer.prototype.writeEpilogue = function(stats) {
      println("# tests " + (stats.passes + stats.failures));
      println("# pass " + stats.passes);
      println("# fail " + stats.failures);
      this.writePlan(stats.passes + stats.failures + stats.pending);
    };
    function TAP12Producer() {
      this.writeFail = function(n, test, err) {
        TAPProducer.prototype.writeFail.call(this, n, test, err);
        if (err.message) {
          println(err.message.replace(/^/gm, "  "));
        }
        if (err.stack) {
          println(err.stack.replace(/^/gm, "  "));
        }
      };
    }
    inherits(TAP12Producer, TAPProducer);
    function TAP13Producer() {
      this.writeVersion = function() {
        println("TAP version 13");
      };
      this.writeFail = function(n, test, err) {
        TAPProducer.prototype.writeFail.call(this, n, test, err);
        var emitYamlBlock = err.message != null || err.stack != null;
        if (emitYamlBlock) {
          println(indent(1) + "---");
          if (err.message) {
            println(indent(2) + "message: |-");
            println(err.message.replace(/^/gm, indent(3)));
          }
          if (err.stack) {
            println(indent(2) + "stack: |-");
            println(err.stack.replace(/^/gm, indent(3)));
          }
          println(indent(1) + "...");
        }
      };
      function indent(level) {
        return Array(level + 1).join("  ");
      }
    }
    inherits(TAP13Producer, TAPProducer);
    TAP.description = "TAP-compatible output";
  }
});

// node_modules/node-stdlib-browser/esm/mock/empty.js
var empty_exports = {};
__export(empty_exports, {
  default: () => empty
});
var empty;
var init_empty = __esm({
  "node_modules/node-stdlib-browser/esm/mock/empty.js"() {
    init_shim();
    empty = null;
  }
});

// node_modules/mocha/lib/reporters/json.js
var require_json2 = __commonJS({
  "node_modules/mocha/lib/reporters/json.js"(exports, module) {
    "use strict";
    init_shim();
    var Base = require_base2();
    var fs = (init_empty(), __toCommonJS(empty_exports));
    var path = require_path_browserify();
    var createUnsupportedError = require_errors().createUnsupportedError;
    var utils = require_utils();
    var constants = require_runner().constants;
    var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
    var EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;
    var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;
    var EVENT_TEST_END = constants.EVENT_TEST_END;
    var EVENT_RUN_END = constants.EVENT_RUN_END;
    exports = module.exports = JSONReporter;
    function JSONReporter(runner, options = {}) {
      Base.call(this, runner, options);
      var self2 = this;
      var tests = [];
      var pending = [];
      var failures = [];
      var passes = [];
      var output;
      if (options.reporterOption && options.reporterOption.output) {
        if (utils.isBrowser()) {
          throw createUnsupportedError("file output not supported in browser");
        }
        output = options.reporterOption.output;
      }
      runner.on(EVENT_TEST_END, function(test) {
        tests.push(test);
      });
      runner.on(EVENT_TEST_PASS, function(test) {
        passes.push(test);
      });
      runner.on(EVENT_TEST_FAIL, function(test) {
        failures.push(test);
      });
      runner.on(EVENT_TEST_PENDING, function(test) {
        pending.push(test);
      });
      runner.once(EVENT_RUN_END, function() {
        var obj = {
          stats: self2.stats,
          tests: tests.map(clean),
          pending: pending.map(clean),
          failures: failures.map(clean),
          passes: passes.map(clean)
        };
        runner.testResults = obj;
        var json = JSON.stringify(obj, null, 2);
        if (output) {
          try {
            fs.mkdirSync(path.dirname(output), { recursive: true });
            fs.writeFileSync(output, json);
          } catch (err) {
            console.error(
              `${Base.symbols.err} [mocha] writing output to "${output}" failed: ${err.message}
`
            );
            import_process.default.stdout.write(json);
          }
        } else {
          import_process.default.stdout.write(json);
        }
      });
    }
    function clean(test) {
      var err = test.err || {};
      if (err instanceof Error) {
        err = errorJSON(err);
      }
      return {
        title: test.title,
        fullTitle: test.fullTitle(),
        file: test.file,
        duration: test.duration,
        currentRetry: test.currentRetry(),
        speed: test.speed,
        err: cleanCycles(err)
      };
    }
    function cleanCycles(obj) {
      var cache = [];
      return JSON.parse(
        JSON.stringify(obj, function(key, value) {
          if (typeof value === "object" && value !== null) {
            if (cache.indexOf(value) !== -1) {
              return "" + value;
            }
            cache.push(value);
          }
          return value;
        })
      );
    }
    function errorJSON(err) {
      var res = {};
      Object.getOwnPropertyNames(err).forEach(function(key) {
        res[key] = err[key];
      }, err);
      return res;
    }
    JSONReporter.description = "single JSON object";
  }
});

// node_modules/mocha/lib/browser/progress.js
var require_progress = __commonJS({
  "node_modules/mocha/lib/browser/progress.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = Progress;
    function Progress() {
      this.percent = 0;
      this.size(0);
      this.fontSize(11);
      this.font("helvetica, arial, sans-serif");
    }
    Progress.prototype.size = function(size) {
      this._size = size;
      return this;
    };
    Progress.prototype.text = function(text) {
      this._text = text;
      return this;
    };
    Progress.prototype.fontSize = function(size) {
      this._fontSize = size;
      return this;
    };
    Progress.prototype.font = function(family) {
      this._font = family;
      return this;
    };
    Progress.prototype.update = function(n) {
      this.percent = n;
      return this;
    };
    Progress.prototype.draw = function(ctx) {
      try {
        var darkMatcher = window.matchMedia("(prefers-color-scheme: dark)");
        var isDarkMode = !!darkMatcher.matches;
        var lightColors = {
          outerCircle: "#9f9f9f",
          innerCircle: "#eee",
          text: "#000"
        };
        var darkColors = {
          outerCircle: "#888",
          innerCircle: "#444",
          text: "#fff"
        };
        var colors = isDarkMode ? darkColors : lightColors;
        var percent = Math.min(this.percent, 100);
        var size = this._size;
        var half = size / 2;
        var x = half;
        var y = half;
        var rad = half - 1;
        var fontSize = this._fontSize;
        ctx.font = fontSize + "px " + this._font;
        var angle = Math.PI * 2 * (percent / 100);
        ctx.clearRect(0, 0, size, size);
        ctx.strokeStyle = colors.outerCircle;
        ctx.beginPath();
        ctx.arc(x, y, rad, 0, angle, false);
        ctx.stroke();
        ctx.strokeStyle = colors.innerCircle;
        ctx.beginPath();
        ctx.arc(x, y, rad - 1, 0, angle, true);
        ctx.stroke();
        var text = this._text || (percent | 0) + "%";
        var w = ctx.measureText(text).width;
        ctx.fillStyle = colors.text;
        ctx.fillText(text, x - w / 2 + 1, y + fontSize / 2 - 1);
      } catch (ignore) {
      }
      return this;
    };
  }
});

// node_modules/mocha/lib/reporters/html.js
var require_html = __commonJS({
  "node_modules/mocha/lib/reporters/html.js"(exports, module) {
    "use strict";
    init_shim();
    var Base = require_base2();
    var utils = require_utils();
    var Progress = require_progress();
    var escapeRe = require_escape_string_regexp();
    var constants = require_runner().constants;
    var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
    var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;
    var EVENT_SUITE_BEGIN = constants.EVENT_SUITE_BEGIN;
    var EVENT_SUITE_END = constants.EVENT_SUITE_END;
    var EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;
    var escape = utils.escape;
    var Date2 = _global.Date;
    exports = module.exports = HTML;
    var statsTemplate = '<ul id="mocha-stats"><li class="progress"><canvas width="40" height="40"></canvas></li><li class="passes"><a href="javascript:void(0);">passes:</a> <em>0</em></li><li class="failures"><a href="javascript:void(0);">failures:</a> <em>0</em></li><li class="duration">duration: <em>0</em>s</li></ul>';
    var playIcon = "&#x2023;";
    function HTML(runner, options) {
      Base.call(this, runner, options);
      var self2 = this;
      var stats = this.stats;
      var stat = fragment(statsTemplate);
      var items = stat.getElementsByTagName("li");
      var passes = items[1].getElementsByTagName("em")[0];
      var passesLink = items[1].getElementsByTagName("a")[0];
      var failures = items[2].getElementsByTagName("em")[0];
      var failuresLink = items[2].getElementsByTagName("a")[0];
      var duration = items[3].getElementsByTagName("em")[0];
      var canvas = stat.getElementsByTagName("canvas")[0];
      var report = fragment('<ul id="mocha-report"></ul>');
      var stack = [report];
      var progress;
      var ctx;
      var root = document.getElementById("mocha");
      if (canvas.getContext) {
        var ratio = window.devicePixelRatio || 1;
        canvas.style.width = canvas.width;
        canvas.style.height = canvas.height;
        canvas.width *= ratio;
        canvas.height *= ratio;
        ctx = canvas.getContext("2d");
        ctx.scale(ratio, ratio);
        progress = new Progress();
      }
      if (!root) {
        return error("#mocha div missing, add it to your document");
      }
      on(passesLink, "click", function(evt) {
        evt.preventDefault();
        unhide();
        var name = /pass/.test(report.className) ? "" : " pass";
        report.className = report.className.replace(/fail|pass/g, "") + name;
        if (report.className.trim()) {
          hideSuitesWithout("test pass");
        }
      });
      on(failuresLink, "click", function(evt) {
        evt.preventDefault();
        unhide();
        var name = /fail/.test(report.className) ? "" : " fail";
        report.className = report.className.replace(/fail|pass/g, "") + name;
        if (report.className.trim()) {
          hideSuitesWithout("test fail");
        }
      });
      root.appendChild(stat);
      root.appendChild(report);
      if (progress) {
        progress.size(40);
      }
      runner.on(EVENT_SUITE_BEGIN, function(suite) {
        if (suite.root) {
          return;
        }
        var url = self2.suiteURL(suite);
        var el = fragment(
          '<li class="suite"><h1><a href="%s">%s</a></h1></li>',
          url,
          escape(suite.title)
        );
        stack[0].appendChild(el);
        stack.unshift(document.createElement("ul"));
        el.appendChild(stack[0]);
      });
      runner.on(EVENT_SUITE_END, function(suite) {
        if (suite.root) {
          updateStats();
          return;
        }
        stack.shift();
      });
      runner.on(EVENT_TEST_PASS, function(test) {
        var url = self2.testURL(test);
        var markup = '<li class="test pass %e"><h2>%e<span class="duration">%ems</span> <a href="%s" class="replay">' + playIcon + "</a></h2></li>";
        var el = fragment(markup, test.speed, test.title, test.duration, url);
        self2.addCodeToggle(el, test.body);
        appendToStack(el);
        updateStats();
      });
      runner.on(EVENT_TEST_FAIL, function(test) {
        var el = fragment(
          '<li class="test fail"><h2>%e <a href="%e" class="replay">' + playIcon + "</a></h2></li>",
          test.title,
          self2.testURL(test)
        );
        var stackString;
        var message = test.err.toString();
        if (message === "[object Error]") {
          message = test.err.message;
        }
        if (test.err.stack) {
          var indexOfMessage = test.err.stack.indexOf(test.err.message);
          if (indexOfMessage === -1) {
            stackString = test.err.stack;
          } else {
            stackString = test.err.stack.slice(
              test.err.message.length + indexOfMessage
            );
          }
        } else if (test.err.sourceURL && test.err.line !== void 0) {
          stackString = "\n(" + test.err.sourceURL + ":" + test.err.line + ")";
        }
        stackString = stackString || "";
        if (test.err.htmlMessage && stackString) {
          el.appendChild(
            fragment(
              '<div class="html-error">%s\n<pre class="error">%e</pre></div>',
              test.err.htmlMessage,
              stackString
            )
          );
        } else if (test.err.htmlMessage) {
          el.appendChild(
            fragment('<div class="html-error">%s</div>', test.err.htmlMessage)
          );
        } else {
          el.appendChild(
            fragment('<pre class="error">%e%e</pre>', message, stackString)
          );
        }
        self2.addCodeToggle(el, test.body);
        appendToStack(el);
        updateStats();
      });
      runner.on(EVENT_TEST_PENDING, function(test) {
        var el = fragment(
          '<li class="test pass pending"><h2>%e</h2></li>',
          test.title
        );
        appendToStack(el);
        updateStats();
      });
      function appendToStack(el) {
        if (stack[0]) {
          stack[0].appendChild(el);
        }
      }
      function updateStats() {
        var percent = stats.tests / runner.total * 100 | 0;
        if (progress) {
          progress.update(percent).draw(ctx);
        }
        var ms = new Date2() - stats.start;
        text(passes, stats.passes);
        text(failures, stats.failures);
        text(duration, (ms / 1e3).toFixed(2));
      }
    }
    function makeUrl(s) {
      var search = window.location.search;
      if (search) {
        search = search.replace(/[?&]grep=[^&\s]*/g, "").replace(/^&/, "?");
      }
      return window.location.pathname + (search ? search + "&" : "?") + "grep=" + encodeURIComponent(escapeRe(s));
    }
    HTML.prototype.suiteURL = function(suite) {
      return makeUrl(suite.fullTitle());
    };
    HTML.prototype.testURL = function(test) {
      return makeUrl(test.fullTitle());
    };
    HTML.prototype.addCodeToggle = function(el, contents) {
      var h2 = el.getElementsByTagName("h2")[0];
      on(h2, "click", function() {
        pre.style.display = pre.style.display === "none" ? "block" : "none";
      });
      var pre = fragment("<pre><code>%e</code></pre>", utils.clean(contents));
      el.appendChild(pre);
      pre.style.display = "none";
    };
    function error(msg) {
      document.body.appendChild(fragment('<div id="mocha-error">%s</div>', msg));
    }
    function fragment(html) {
      var args = arguments;
      var div = document.createElement("div");
      var i = 1;
      div.innerHTML = html.replace(/%([se])/g, function(_, type) {
        switch (type) {
          case "s":
            return String(args[i++]);
          case "e":
            return escape(args[i++]);
        }
      });
      return div.firstChild;
    }
    function hideSuitesWithout(classname) {
      var suites = document.getElementsByClassName("suite");
      for (var i = 0; i < suites.length; i++) {
        var els = suites[i].getElementsByClassName(classname);
        if (!els.length) {
          suites[i].className += " hidden";
        }
      }
    }
    function unhide() {
      var els = document.getElementsByClassName("suite hidden");
      while (els.length > 0) {
        els[0].className = els[0].className.replace("suite hidden", "suite");
      }
    }
    function text(el, contents) {
      if (el.textContent) {
        el.textContent = contents;
      } else {
        el.innerText = contents;
      }
    }
    function on(el, event, fn) {
      if (el.addEventListener) {
        el.addEventListener(event, fn, false);
      } else {
        el.attachEvent("on" + event, fn);
      }
    }
    HTML.browserOnly = true;
  }
});

// node_modules/mocha/lib/reporters/list.js
var require_list = __commonJS({
  "node_modules/mocha/lib/reporters/list.js"(exports, module) {
    "use strict";
    init_shim();
    var Base = require_base2();
    var inherits = require_utils().inherits;
    var constants = require_runner().constants;
    var EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;
    var EVENT_RUN_END = constants.EVENT_RUN_END;
    var EVENT_TEST_BEGIN = constants.EVENT_TEST_BEGIN;
    var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;
    var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
    var EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;
    var color = Base.color;
    var cursor = Base.cursor;
    exports = module.exports = List;
    function List(runner, options) {
      Base.call(this, runner, options);
      var self2 = this;
      var n = 0;
      runner.on(EVENT_RUN_BEGIN, function() {
        Base.consoleLog();
      });
      runner.on(EVENT_TEST_BEGIN, function(test) {
        import_process.default.stdout.write(color("pass", "    " + test.fullTitle() + ": "));
      });
      runner.on(EVENT_TEST_PENDING, function(test) {
        var fmt = color("checkmark", "  -") + color("pending", " %s");
        Base.consoleLog(fmt, test.fullTitle());
      });
      runner.on(EVENT_TEST_PASS, function(test) {
        var fmt = color("checkmark", "  " + Base.symbols.ok) + color("pass", " %s: ") + color(test.speed, "%dms");
        cursor.CR();
        Base.consoleLog(fmt, test.fullTitle(), test.duration);
      });
      runner.on(EVENT_TEST_FAIL, function(test) {
        cursor.CR();
        Base.consoleLog(color("fail", "  %d) %s"), ++n, test.fullTitle());
      });
      runner.once(EVENT_RUN_END, self2.epilogue.bind(self2));
    }
    inherits(List, Base);
    List.description = 'like "spec" reporter but flat';
  }
});

// node_modules/mocha/lib/reporters/min.js
var require_min = __commonJS({
  "node_modules/mocha/lib/reporters/min.js"(exports, module) {
    "use strict";
    init_shim();
    var Base = require_base2();
    var inherits = require_utils().inherits;
    var constants = require_runner().constants;
    var EVENT_RUN_END = constants.EVENT_RUN_END;
    var EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;
    exports = module.exports = Min;
    function Min(runner, options) {
      Base.call(this, runner, options);
      runner.on(EVENT_RUN_BEGIN, function() {
        import_process.default.stdout.write("\x1B[2J");
        import_process.default.stdout.write("\x1B[1;3H");
      });
      runner.once(EVENT_RUN_END, this.epilogue.bind(this));
    }
    inherits(Min, Base);
    Min.description = "essentially just a summary";
  }
});

// node_modules/mocha/lib/reporters/spec.js
var require_spec = __commonJS({
  "node_modules/mocha/lib/reporters/spec.js"(exports, module) {
    "use strict";
    init_shim();
    var Base = require_base2();
    var constants = require_runner().constants;
    var EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;
    var EVENT_RUN_END = constants.EVENT_RUN_END;
    var EVENT_SUITE_BEGIN = constants.EVENT_SUITE_BEGIN;
    var EVENT_SUITE_END = constants.EVENT_SUITE_END;
    var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;
    var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
    var EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;
    var inherits = require_utils().inherits;
    var color = Base.color;
    exports = module.exports = Spec;
    function Spec(runner, options) {
      Base.call(this, runner, options);
      var self2 = this;
      var indents = 0;
      var n = 0;
      function indent() {
        return Array(indents).join("  ");
      }
      runner.on(EVENT_RUN_BEGIN, function() {
        Base.consoleLog();
      });
      runner.on(EVENT_SUITE_BEGIN, function(suite) {
        ++indents;
        Base.consoleLog(color("suite", "%s%s"), indent(), suite.title);
      });
      runner.on(EVENT_SUITE_END, function() {
        --indents;
        if (indents === 1) {
          Base.consoleLog();
        }
      });
      runner.on(EVENT_TEST_PENDING, function(test) {
        var fmt = indent() + color("pending", "  - %s");
        Base.consoleLog(fmt, test.title);
      });
      runner.on(EVENT_TEST_PASS, function(test) {
        var fmt;
        if (test.speed === "fast") {
          fmt = indent() + color("checkmark", "  " + Base.symbols.ok) + color("pass", " %s");
          Base.consoleLog(fmt, test.title);
        } else {
          fmt = indent() + color("checkmark", "  " + Base.symbols.ok) + color("pass", " %s") + color(test.speed, " (%dms)");
          Base.consoleLog(fmt, test.title, test.duration);
        }
      });
      runner.on(EVENT_TEST_FAIL, function(test) {
        Base.consoleLog(indent() + color("fail", "  %d) %s"), ++n, test.title);
      });
      runner.once(EVENT_RUN_END, self2.epilogue.bind(self2));
    }
    inherits(Spec, Base);
    Spec.description = "hierarchical & verbose [default]";
  }
});

// node_modules/mocha/lib/reporters/nyan.js
var require_nyan = __commonJS({
  "node_modules/mocha/lib/reporters/nyan.js"(exports, module) {
    "use strict";
    init_shim();
    var Base = require_base2();
    var constants = require_runner().constants;
    var inherits = require_utils().inherits;
    var EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;
    var EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;
    var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
    var EVENT_RUN_END = constants.EVENT_RUN_END;
    var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;
    exports = module.exports = NyanCat;
    function NyanCat(runner, options) {
      Base.call(this, runner, options);
      var self2 = this;
      var width = Base.window.width * 0.75 | 0;
      var nyanCatWidth = this.nyanCatWidth = 11;
      this.colorIndex = 0;
      this.numberOfLines = 4;
      this.rainbowColors = self2.generateColors();
      this.scoreboardWidth = 5;
      this.tick = 0;
      this.trajectories = [[], [], [], []];
      this.trajectoryWidthMax = width - nyanCatWidth;
      runner.on(EVENT_RUN_BEGIN, function() {
        Base.cursor.hide();
        self2.draw();
      });
      runner.on(EVENT_TEST_PENDING, function() {
        self2.draw();
      });
      runner.on(EVENT_TEST_PASS, function() {
        self2.draw();
      });
      runner.on(EVENT_TEST_FAIL, function() {
        self2.draw();
      });
      runner.once(EVENT_RUN_END, function() {
        Base.cursor.show();
        for (var i = 0; i < self2.numberOfLines; i++) {
          write("\n");
        }
        self2.epilogue();
      });
    }
    inherits(NyanCat, Base);
    NyanCat.prototype.draw = function() {
      this.appendRainbow();
      this.drawScoreboard();
      this.drawRainbow();
      this.drawNyanCat();
      this.tick = !this.tick;
    };
    NyanCat.prototype.drawScoreboard = function() {
      var stats = this.stats;
      function draw(type, n) {
        write(" ");
        write(Base.color(type, n));
        write("\n");
      }
      draw("green", stats.passes);
      draw("fail", stats.failures);
      draw("pending", stats.pending);
      write("\n");
      this.cursorUp(this.numberOfLines);
    };
    NyanCat.prototype.appendRainbow = function() {
      var segment = this.tick ? "_" : "-";
      var rainbowified = this.rainbowify(segment);
      for (var index = 0; index < this.numberOfLines; index++) {
        var trajectory = this.trajectories[index];
        if (trajectory.length >= this.trajectoryWidthMax) {
          trajectory.shift();
        }
        trajectory.push(rainbowified);
      }
    };
    NyanCat.prototype.drawRainbow = function() {
      var self2 = this;
      this.trajectories.forEach(function(line) {
        write("\x1B[" + self2.scoreboardWidth + "C");
        write(line.join(""));
        write("\n");
      });
      this.cursorUp(this.numberOfLines);
    };
    NyanCat.prototype.drawNyanCat = function() {
      var self2 = this;
      var startWidth = this.scoreboardWidth + this.trajectories[0].length;
      var dist = "\x1B[" + startWidth + "C";
      var padding = "";
      write(dist);
      write("_,------,");
      write("\n");
      write(dist);
      padding = self2.tick ? "  " : "   ";
      write("_|" + padding + "/\\_/\\ ");
      write("\n");
      write(dist);
      padding = self2.tick ? "_" : "__";
      var tail = self2.tick ? "~" : "^";
      write(tail + "|" + padding + this.face() + " ");
      write("\n");
      write(dist);
      padding = self2.tick ? " " : "  ";
      write(padding + '""  "" ');
      write("\n");
      this.cursorUp(this.numberOfLines);
    };
    NyanCat.prototype.face = function() {
      var stats = this.stats;
      if (stats.failures) {
        return "( x .x)";
      } else if (stats.pending) {
        return "( o .o)";
      } else if (stats.passes) {
        return "( ^ .^)";
      }
      return "( - .-)";
    };
    NyanCat.prototype.cursorUp = function(n) {
      write("\x1B[" + n + "A");
    };
    NyanCat.prototype.cursorDown = function(n) {
      write("\x1B[" + n + "B");
    };
    NyanCat.prototype.generateColors = function() {
      var colors = [];
      for (var i = 0; i < 6 * 7; i++) {
        var pi3 = Math.floor(Math.PI / 3);
        var n = i * (1 / 6);
        var r = Math.floor(3 * Math.sin(n) + 3);
        var g = Math.floor(3 * Math.sin(n + 2 * pi3) + 3);
        var b = Math.floor(3 * Math.sin(n + 4 * pi3) + 3);
        colors.push(36 * r + 6 * g + b + 16);
      }
      return colors;
    };
    NyanCat.prototype.rainbowify = function(str) {
      if (!Base.useColors) {
        return str;
      }
      var color = this.rainbowColors[this.colorIndex % this.rainbowColors.length];
      this.colorIndex += 1;
      return "\x1B[38;5;" + color + "m" + str + "\x1B[0m";
    };
    function write(string) {
      import_process.default.stdout.write(string);
    }
    NyanCat.description = '"nyan cat"';
  }
});

// node_modules/mocha/lib/reporters/xunit.js
var require_xunit = __commonJS({
  "node_modules/mocha/lib/reporters/xunit.js"(exports, module) {
    "use strict";
    init_shim();
    var Base = require_base2();
    var utils = require_utils();
    var fs = (init_empty(), __toCommonJS(empty_exports));
    var path = require_path_browserify();
    var errors = require_errors();
    var createUnsupportedError = errors.createUnsupportedError;
    var constants = require_runner().constants;
    var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
    var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;
    var EVENT_RUN_END = constants.EVENT_RUN_END;
    var EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;
    var STATE_FAILED = require_runnable().constants.STATE_FAILED;
    var inherits = utils.inherits;
    var escape = utils.escape;
    var Date2 = _global.Date;
    exports = module.exports = XUnit;
    function XUnit(runner, options) {
      Base.call(this, runner, options);
      var stats = this.stats;
      var tests = [];
      var self2 = this;
      var suiteName;
      var DEFAULT_SUITE_NAME = "Mocha Tests";
      if (options && options.reporterOptions) {
        if (options.reporterOptions.output) {
          if (!fs.createWriteStream) {
            throw createUnsupportedError("file output not supported in browser");
          }
          fs.mkdirSync(path.dirname(options.reporterOptions.output), {
            recursive: true
          });
          self2.fileStream = fs.createWriteStream(options.reporterOptions.output);
        }
        suiteName = options.reporterOptions.suiteName;
      }
      suiteName = suiteName || DEFAULT_SUITE_NAME;
      runner.on(EVENT_TEST_PENDING, function(test) {
        tests.push(test);
      });
      runner.on(EVENT_TEST_PASS, function(test) {
        tests.push(test);
      });
      runner.on(EVENT_TEST_FAIL, function(test) {
        tests.push(test);
      });
      runner.once(EVENT_RUN_END, function() {
        self2.write(
          tag(
            "testsuite",
            {
              name: suiteName,
              tests: stats.tests,
              failures: 0,
              errors: stats.failures,
              skipped: stats.tests - stats.failures - stats.passes,
              timestamp: new Date2().toUTCString(),
              time: stats.duration / 1e3 || 0
            },
            false
          )
        );
        tests.forEach(function(t) {
          self2.test(t);
        });
        self2.write("</testsuite>");
      });
    }
    inherits(XUnit, Base);
    XUnit.prototype.done = function(failures, fn) {
      if (this.fileStream) {
        this.fileStream.end(function() {
          fn(failures);
        });
      } else {
        fn(failures);
      }
    };
    XUnit.prototype.write = function(line) {
      if (this.fileStream) {
        this.fileStream.write(line + "\n");
      } else if (typeof import_process.default === "object" && import_process.default.stdout) {
        import_process.default.stdout.write(line + "\n");
      } else {
        Base.consoleLog(line);
      }
    };
    XUnit.prototype.test = function(test) {
      Base.useColors = false;
      var attrs = {
        classname: test.parent.fullTitle(),
        name: test.title,
        time: test.duration / 1e3 || 0
      };
      if (test.state === STATE_FAILED) {
        var err = test.err;
        var diff = !Base.hideDiff && Base.showDiff(err) ? "\n" + Base.generateDiff(err.actual, err.expected) : "";
        this.write(
          tag(
            "testcase",
            attrs,
            false,
            tag(
              "failure",
              {},
              false,
              escape(err.message) + escape(diff) + "\n" + escape(err.stack)
            )
          )
        );
      } else if (test.isPending()) {
        this.write(tag("testcase", attrs, false, tag("skipped", {}, true)));
      } else {
        this.write(tag("testcase", attrs, true));
      }
    };
    function tag(name, attrs, close, content) {
      var end = close ? "/>" : ">";
      var pairs = [];
      var tag2;
      for (var key in attrs) {
        if (Object.prototype.hasOwnProperty.call(attrs, key)) {
          pairs.push(key + '="' + escape(attrs[key]) + '"');
        }
      }
      tag2 = "<" + name + (pairs.length ? " " + pairs.join(" ") : "") + end;
      if (content) {
        tag2 += content + "</" + name + end;
      }
      return tag2;
    }
    XUnit.description = "XUnit-compatible XML output";
  }
});

// node_modules/mocha/lib/reporters/markdown.js
var require_markdown = __commonJS({
  "node_modules/mocha/lib/reporters/markdown.js"(exports, module) {
    "use strict";
    init_shim();
    var Base = require_base2();
    var utils = require_utils();
    var constants = require_runner().constants;
    var EVENT_RUN_END = constants.EVENT_RUN_END;
    var EVENT_SUITE_BEGIN = constants.EVENT_SUITE_BEGIN;
    var EVENT_SUITE_END = constants.EVENT_SUITE_END;
    var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
    var SUITE_PREFIX = "$";
    exports = module.exports = Markdown;
    function Markdown(runner, options) {
      Base.call(this, runner, options);
      var level = 0;
      var buf = "";
      function title(str) {
        return Array(level).join("#") + " " + str;
      }
      function mapTOC(suite, obj) {
        var ret = obj;
        var key = SUITE_PREFIX + suite.title;
        obj = obj[key] = obj[key] || { suite };
        suite.suites.forEach(function(suite2) {
          mapTOC(suite2, obj);
        });
        return ret;
      }
      function stringifyTOC(obj, level2) {
        ++level2;
        var buf2 = "";
        var link;
        for (var key in obj) {
          if (key === "suite") {
            continue;
          }
          if (key !== SUITE_PREFIX) {
            link = " - [" + key.substring(1) + "]";
            link += "(#" + utils.slug(obj[key].suite.fullTitle()) + ")\n";
            buf2 += Array(level2).join("  ") + link;
          }
          buf2 += stringifyTOC(obj[key], level2);
        }
        return buf2;
      }
      function generateTOC(suite) {
        var obj = mapTOC(suite, {});
        return stringifyTOC(obj, 0);
      }
      generateTOC(runner.suite);
      runner.on(EVENT_SUITE_BEGIN, function(suite) {
        ++level;
        var slug = utils.slug(suite.fullTitle());
        buf += '<a name="' + slug + '"></a>\n';
        buf += title(suite.title) + "\n";
      });
      runner.on(EVENT_SUITE_END, function() {
        --level;
      });
      runner.on(EVENT_TEST_PASS, function(test) {
        var code = utils.clean(test.body);
        buf += test.title + ".\n";
        buf += "\n```js\n";
        buf += code + "\n";
        buf += "```\n\n";
      });
      runner.once(EVENT_RUN_END, function() {
        import_process.default.stdout.write("# TOC\n");
        import_process.default.stdout.write(generateTOC(runner.suite));
        import_process.default.stdout.write(buf);
      });
    }
    Markdown.description = "GitHub Flavored Markdown";
  }
});

// node_modules/mocha/lib/reporters/progress.js
var require_progress2 = __commonJS({
  "node_modules/mocha/lib/reporters/progress.js"(exports, module) {
    "use strict";
    init_shim();
    var Base = require_base2();
    var constants = require_runner().constants;
    var EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;
    var EVENT_TEST_END = constants.EVENT_TEST_END;
    var EVENT_RUN_END = constants.EVENT_RUN_END;
    var inherits = require_utils().inherits;
    var color = Base.color;
    var cursor = Base.cursor;
    exports = module.exports = Progress;
    Base.colors.progress = 90;
    function Progress(runner, options) {
      Base.call(this, runner, options);
      var self2 = this;
      var width = Base.window.width * 0.5 | 0;
      var total = runner.total;
      var complete = 0;
      var lastN = -1;
      options = options || {};
      var reporterOptions = options.reporterOptions || {};
      options.open = reporterOptions.open || "[";
      options.complete = reporterOptions.complete || "";
      options.incomplete = reporterOptions.incomplete || Base.symbols.dot;
      options.close = reporterOptions.close || "]";
      options.verbose = reporterOptions.verbose || false;
      runner.on(EVENT_RUN_BEGIN, function() {
        import_process.default.stdout.write("\n");
        cursor.hide();
      });
      runner.on(EVENT_TEST_END, function() {
        complete++;
        var percent = complete / total;
        var n = width * percent | 0;
        var i = width - n;
        if (n === lastN && !options.verbose) {
          return;
        }
        lastN = n;
        cursor.CR();
        import_process.default.stdout.write("\x1B[J");
        import_process.default.stdout.write(color("progress", "  " + options.open));
        import_process.default.stdout.write(Array(n).join(options.complete));
        import_process.default.stdout.write(Array(i).join(options.incomplete));
        import_process.default.stdout.write(color("progress", options.close));
        if (options.verbose) {
          import_process.default.stdout.write(color("progress", " " + complete + " of " + total));
        }
      });
      runner.once(EVENT_RUN_END, function() {
        cursor.show();
        import_process.default.stdout.write("\n");
        self2.epilogue();
      });
    }
    inherits(Progress, Base);
    Progress.description = "a progress bar";
  }
});

// node_modules/mocha/lib/reporters/landing.js
var require_landing = __commonJS({
  "node_modules/mocha/lib/reporters/landing.js"(exports, module) {
    "use strict";
    init_shim();
    var Base = require_base2();
    var inherits = require_utils().inherits;
    var constants = require_runner().constants;
    var EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;
    var EVENT_RUN_END = constants.EVENT_RUN_END;
    var EVENT_TEST_END = constants.EVENT_TEST_END;
    var STATE_FAILED = require_runnable().constants.STATE_FAILED;
    var cursor = Base.cursor;
    var color = Base.color;
    exports = module.exports = Landing;
    Base.colors.plane = 0;
    Base.colors["plane crash"] = 31;
    Base.colors.runway = 90;
    function Landing(runner, options) {
      Base.call(this, runner, options);
      var self2 = this;
      var width = Base.window.width * 0.75 | 0;
      var stream = import_process.default.stdout;
      var plane = color("plane", "");
      var crashed = -1;
      var n = 0;
      var total = 0;
      function runway() {
        var buf = Array(width).join("-");
        return "  " + color("runway", buf);
      }
      runner.on(EVENT_RUN_BEGIN, function() {
        stream.write("\n\n\n  ");
        cursor.hide();
      });
      runner.on(EVENT_TEST_END, function(test) {
        var col = crashed === -1 ? width * ++n / ++total | 0 : crashed;
        if (test.state === STATE_FAILED) {
          plane = color("plane crash", "");
          crashed = col;
        }
        stream.write("\x1B[" + (width + 1) + "D\x1B[2A");
        stream.write(runway());
        stream.write("\n  ");
        stream.write(color("runway", Array(col).join("")));
        stream.write(plane);
        stream.write(color("runway", Array(width - col).join("") + "\n"));
        stream.write(runway());
        stream.write("\x1B[0m");
      });
      runner.once(EVENT_RUN_END, function() {
        cursor.show();
        import_process.default.stdout.write("\n");
        self2.epilogue();
      });
      import_process.default.once("SIGINT", function() {
        cursor.show();
        import_process.default.nextTick(function() {
          import_process.default.kill(import_process.default.pid, "SIGINT");
        });
      });
    }
    inherits(Landing, Base);
    Landing.description = "Unicode landing strip";
  }
});

// node_modules/mocha/lib/reporters/json-stream.js
var require_json_stream = __commonJS({
  "node_modules/mocha/lib/reporters/json-stream.js"(exports, module) {
    "use strict";
    init_shim();
    var Base = require_base2();
    var constants = require_runner().constants;
    var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
    var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;
    var EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;
    var EVENT_RUN_END = constants.EVENT_RUN_END;
    exports = module.exports = JSONStream;
    function JSONStream(runner, options) {
      Base.call(this, runner, options);
      var self2 = this;
      var total = runner.total;
      runner.once(EVENT_RUN_BEGIN, function() {
        writeEvent(["start", { total }]);
      });
      runner.on(EVENT_TEST_PASS, function(test) {
        writeEvent(["pass", clean(test)]);
      });
      runner.on(EVENT_TEST_FAIL, function(test, err) {
        test = clean(test);
        test.err = err.message;
        test.stack = err.stack || null;
        writeEvent(["fail", test]);
      });
      runner.once(EVENT_RUN_END, function() {
        writeEvent(["end", self2.stats]);
      });
    }
    function writeEvent(event) {
      import_process.default.stdout.write(JSON.stringify(event) + "\n");
    }
    function clean(test) {
      return {
        title: test.title,
        fullTitle: test.fullTitle(),
        file: test.file,
        duration: test.duration,
        currentRetry: test.currentRetry(),
        speed: test.speed
      };
    }
    JSONStream.description = "newline delimited JSON events";
  }
});

// node_modules/mocha/lib/reporters/index.js
var require_reporters = __commonJS({
  "node_modules/mocha/lib/reporters/index.js"(exports) {
    "use strict";
    init_shim();
    exports.Base = exports.base = require_base2();
    exports.Dot = exports.dot = require_dot();
    exports.Doc = exports.doc = require_doc();
    exports.TAP = exports.tap = require_tap();
    exports.JSON = exports.json = require_json2();
    exports.HTML = exports.html = require_html();
    exports.List = exports.list = require_list();
    exports.Min = exports.min = require_min();
    exports.Spec = exports.spec = require_spec();
    exports.Nyan = exports.nyan = require_nyan();
    exports.XUnit = exports.xunit = require_xunit();
    exports.Markdown = exports.markdown = require_markdown();
    exports.Progress = exports.progress = require_progress2();
    exports.Landing = exports.landing = require_landing();
    exports.JSONStream = exports["json-stream"] = require_json_stream();
  }
});

// node_modules/mocha/lib/mocharc.json
var require_mocharc = __commonJS({
  "node_modules/mocha/lib/mocharc.json"(exports, module) {
    module.exports = {
      diff: true,
      extension: ["js", "cjs", "mjs"],
      package: "./package.json",
      reporter: "spec",
      slow: 75,
      timeout: 2e3,
      ui: "bdd",
      "watch-ignore": ["node_modules", ".git"]
    };
  }
});

// (disabled):node_modules/mocha/lib/nodejs/esm-utils
var require_esm_utils = __commonJS({
  "(disabled):node_modules/mocha/lib/nodejs/esm-utils"() {
    init_shim();
  }
});

// node_modules/mocha/lib/stats-collector.js
var require_stats_collector = __commonJS({
  "node_modules/mocha/lib/stats-collector.js"(exports, module) {
    "use strict";
    init_shim();
    var constants = require_runner().constants;
    var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
    var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;
    var EVENT_SUITE_BEGIN = constants.EVENT_SUITE_BEGIN;
    var EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;
    var EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;
    var EVENT_RUN_END = constants.EVENT_RUN_END;
    var EVENT_TEST_END = constants.EVENT_TEST_END;
    var Date2 = _global.Date;
    function createStatsCollector(runner) {
      var stats = {
        suites: 0,
        tests: 0,
        passes: 0,
        pending: 0,
        failures: 0
      };
      if (!runner) {
        throw new TypeError("Missing runner argument");
      }
      runner.stats = stats;
      runner.once(EVENT_RUN_BEGIN, function() {
        stats.start = new Date2();
      });
      runner.on(EVENT_SUITE_BEGIN, function(suite) {
        suite.root || stats.suites++;
      });
      runner.on(EVENT_TEST_PASS, function() {
        stats.passes++;
      });
      runner.on(EVENT_TEST_FAIL, function() {
        stats.failures++;
      });
      runner.on(EVENT_TEST_PENDING, function() {
        stats.pending++;
      });
      runner.on(EVENT_TEST_END, function() {
        stats.tests++;
      });
      runner.once(EVENT_RUN_END, function() {
        stats.end = new Date2();
        stats.duration = stats.end - stats.start;
      });
    }
    module.exports = createStatsCollector;
  }
});

// node_modules/mocha/lib/test.js
var require_test = __commonJS({
  "node_modules/mocha/lib/test.js"(exports, module) {
    "use strict";
    init_shim();
    var Runnable = require_runnable();
    var utils = require_utils();
    var errors = require_errors();
    var createInvalidArgumentTypeError = errors.createInvalidArgumentTypeError;
    var isString = utils.isString;
    var { MOCHA_ID_PROP_NAME } = utils.constants;
    module.exports = Test;
    function Test(title, fn) {
      if (!isString(title)) {
        throw createInvalidArgumentTypeError(
          'Test argument "title" should be a string. Received type "' + typeof title + '"',
          "title",
          "string"
        );
      }
      this.type = "test";
      Runnable.call(this, title, fn);
      this.reset();
    }
    utils.inherits(Test, Runnable);
    Test.prototype.reset = function() {
      Runnable.prototype.reset.call(this);
      this.pending = !this.fn;
      delete this.state;
    };
    Test.prototype.retriedTest = function(n) {
      if (!arguments.length) {
        return this._retriedTest;
      }
      this._retriedTest = n;
    };
    Test.prototype.markOnly = function() {
      this.parent.appendOnlyTest(this);
    };
    Test.prototype.clone = function() {
      var test = new Test(this.title, this.fn);
      test.timeout(this.timeout());
      test.slow(this.slow());
      test.retries(this.retries());
      test.currentRetry(this.currentRetry());
      test.retriedTest(this.retriedTest() || this);
      test.globals(this.globals());
      test.parent = this.parent;
      test.file = this.file;
      test.ctx = this.ctx;
      return test;
    };
    Test.prototype.serialize = function serialize() {
      return {
        $$currentRetry: this._currentRetry,
        $$fullTitle: this.fullTitle(),
        $$isPending: Boolean(this.pending),
        $$retriedTest: this._retriedTest || null,
        $$slow: this._slow,
        $$titlePath: this.titlePath(),
        body: this.body,
        duration: this.duration,
        err: this.err,
        parent: {
          $$fullTitle: this.parent.fullTitle(),
          [MOCHA_ID_PROP_NAME]: this.parent.id
        },
        speed: this.speed,
        state: this.state,
        title: this.title,
        type: this.type,
        file: this.file,
        [MOCHA_ID_PROP_NAME]: this.id
      };
    };
  }
});

// node_modules/mocha/lib/interfaces/common.js
var require_common2 = __commonJS({
  "node_modules/mocha/lib/interfaces/common.js"(exports, module) {
    "use strict";
    init_shim();
    var Suite = require_suite();
    var errors = require_errors();
    var createMissingArgumentError = errors.createMissingArgumentError;
    var createUnsupportedError = errors.createUnsupportedError;
    var createForbiddenExclusivityError = errors.createForbiddenExclusivityError;
    module.exports = function(suites, context, mocha) {
      function shouldBeTested(suite) {
        return !mocha.options.grep || mocha.options.grep && mocha.options.grep.test(suite.fullTitle()) && !mocha.options.invert;
      }
      return {
        /**
         * This is only present if flag --delay is passed into Mocha. It triggers
         * root suite execution.
         *
         * @param {Suite} suite The root suite.
         * @return {Function} A function which runs the root suite
         */
        runWithSuite: function runWithSuite(suite) {
          return function run() {
            suite.run();
          };
        },
        /**
         * Execute before running tests.
         *
         * @param {string} name
         * @param {Function} fn
         */
        before: function(name, fn) {
          suites[0].beforeAll(name, fn);
        },
        /**
         * Execute after running tests.
         *
         * @param {string} name
         * @param {Function} fn
         */
        after: function(name, fn) {
          suites[0].afterAll(name, fn);
        },
        /**
         * Execute before each test case.
         *
         * @param {string} name
         * @param {Function} fn
         */
        beforeEach: function(name, fn) {
          suites[0].beforeEach(name, fn);
        },
        /**
         * Execute after each test case.
         *
         * @param {string} name
         * @param {Function} fn
         */
        afterEach: function(name, fn) {
          suites[0].afterEach(name, fn);
        },
        suite: {
          /**
           * Create an exclusive Suite; convenience function
           * See docstring for create() below.
           *
           * @param {Object} opts
           * @returns {Suite}
           */
          only: function only(opts) {
            if (mocha.options.forbidOnly) {
              throw createForbiddenExclusivityError(mocha);
            }
            opts.isOnly = true;
            return this.create(opts);
          },
          /**
           * Create a Suite, but skip it; convenience function
           * See docstring for create() below.
           *
           * @param {Object} opts
           * @returns {Suite}
           */
          skip: function skip(opts) {
            opts.pending = true;
            return this.create(opts);
          },
          /**
           * Creates a suite.
           *
           * @param {Object} opts Options
           * @param {string} opts.title Title of Suite
           * @param {Function} [opts.fn] Suite Function (not always applicable)
           * @param {boolean} [opts.pending] Is Suite pending?
           * @param {string} [opts.file] Filepath where this Suite resides
           * @param {boolean} [opts.isOnly] Is Suite exclusive?
           * @returns {Suite}
           */
          create: function create(opts) {
            var suite = Suite.create(suites[0], opts.title);
            suite.pending = Boolean(opts.pending);
            suite.file = opts.file;
            suites.unshift(suite);
            if (opts.isOnly) {
              suite.markOnly();
            }
            if (suite.pending && mocha.options.forbidPending && shouldBeTested(suite)) {
              throw createUnsupportedError("Pending test forbidden");
            }
            if (typeof opts.fn === "function") {
              opts.fn.call(suite);
              suites.shift();
            } else if (typeof opts.fn === "undefined" && !suite.pending) {
              throw createMissingArgumentError(
                'Suite "' + suite.fullTitle() + '" was defined but no callback was supplied. Supply a callback or explicitly skip the suite.',
                "callback",
                "function"
              );
            } else if (!opts.fn && suite.pending) {
              suites.shift();
            }
            return suite;
          }
        },
        test: {
          /**
           * Exclusive test-case.
           *
           * @param {Object} mocha
           * @param {Function} test
           * @returns {*}
           */
          only: function(mocha2, test) {
            if (mocha2.options.forbidOnly) {
              throw createForbiddenExclusivityError(mocha2);
            }
            test.markOnly();
            return test;
          },
          /**
           * Pending test case.
           *
           * @param {string} title
           */
          skip: function(title) {
            context.test(title);
          }
        }
      };
    };
  }
});

// node_modules/mocha/lib/interfaces/bdd.js
var require_bdd = __commonJS({
  "node_modules/mocha/lib/interfaces/bdd.js"(exports, module) {
    "use strict";
    init_shim();
    var Test = require_test();
    var EVENT_FILE_PRE_REQUIRE = require_suite().constants.EVENT_FILE_PRE_REQUIRE;
    module.exports = function bddInterface(suite) {
      var suites = [suite];
      suite.on(EVENT_FILE_PRE_REQUIRE, function(context, file, mocha) {
        var common = require_common2()(suites, context, mocha);
        context.before = common.before;
        context.after = common.after;
        context.beforeEach = common.beforeEach;
        context.afterEach = common.afterEach;
        context.run = mocha.options.delay && common.runWithSuite(suite);
        context.describe = context.context = function(title, fn) {
          return common.suite.create({
            title,
            file,
            fn
          });
        };
        context.xdescribe = context.xcontext = context.describe.skip = function(title, fn) {
          return common.suite.skip({
            title,
            file,
            fn
          });
        };
        context.describe.only = function(title, fn) {
          return common.suite.only({
            title,
            file,
            fn
          });
        };
        context.it = context.specify = function(title, fn) {
          var suite2 = suites[0];
          if (suite2.isPending()) {
            fn = null;
          }
          var test = new Test(title, fn);
          test.file = file;
          suite2.addTest(test);
          return test;
        };
        context.it.only = function(title, fn) {
          return common.test.only(mocha, context.it(title, fn));
        };
        context.xit = context.xspecify = context.it.skip = function(title) {
          return context.it(title);
        };
      });
    };
    module.exports.description = "BDD or RSpec style [default]";
  }
});

// node_modules/mocha/lib/interfaces/tdd.js
var require_tdd = __commonJS({
  "node_modules/mocha/lib/interfaces/tdd.js"(exports, module) {
    "use strict";
    init_shim();
    var Test = require_test();
    var EVENT_FILE_PRE_REQUIRE = require_suite().constants.EVENT_FILE_PRE_REQUIRE;
    module.exports = function(suite) {
      var suites = [suite];
      suite.on(EVENT_FILE_PRE_REQUIRE, function(context, file, mocha) {
        var common = require_common2()(suites, context, mocha);
        context.setup = common.beforeEach;
        context.teardown = common.afterEach;
        context.suiteSetup = common.before;
        context.suiteTeardown = common.after;
        context.run = mocha.options.delay && common.runWithSuite(suite);
        context.suite = function(title, fn) {
          return common.suite.create({
            title,
            file,
            fn
          });
        };
        context.suite.skip = function(title, fn) {
          return common.suite.skip({
            title,
            file,
            fn
          });
        };
        context.suite.only = function(title, fn) {
          return common.suite.only({
            title,
            file,
            fn
          });
        };
        context.test = function(title, fn) {
          var suite2 = suites[0];
          if (suite2.isPending()) {
            fn = null;
          }
          var test = new Test(title, fn);
          test.file = file;
          suite2.addTest(test);
          return test;
        };
        context.test.only = function(title, fn) {
          return common.test.only(mocha, context.test(title, fn));
        };
        context.test.skip = common.test.skip;
      });
    };
    module.exports.description = `traditional "suite"/"test" instead of BDD's "describe"/"it"`;
  }
});

// node_modules/mocha/lib/interfaces/qunit.js
var require_qunit = __commonJS({
  "node_modules/mocha/lib/interfaces/qunit.js"(exports, module) {
    "use strict";
    init_shim();
    var Test = require_test();
    var EVENT_FILE_PRE_REQUIRE = require_suite().constants.EVENT_FILE_PRE_REQUIRE;
    module.exports = function qUnitInterface(suite) {
      var suites = [suite];
      suite.on(EVENT_FILE_PRE_REQUIRE, function(context, file, mocha) {
        var common = require_common2()(suites, context, mocha);
        context.before = common.before;
        context.after = common.after;
        context.beforeEach = common.beforeEach;
        context.afterEach = common.afterEach;
        context.run = mocha.options.delay && common.runWithSuite(suite);
        context.suite = function(title) {
          if (suites.length > 1) {
            suites.shift();
          }
          return common.suite.create({
            title,
            file,
            fn: false
          });
        };
        context.suite.only = function(title) {
          if (suites.length > 1) {
            suites.shift();
          }
          return common.suite.only({
            title,
            file,
            fn: false
          });
        };
        context.test = function(title, fn) {
          var test = new Test(title, fn);
          test.file = file;
          suites[0].addTest(test);
          return test;
        };
        context.test.only = function(title, fn) {
          return common.test.only(mocha, context.test(title, fn));
        };
        context.test.skip = common.test.skip;
      });
    };
    module.exports.description = "QUnit style";
  }
});

// node_modules/mocha/lib/interfaces/exports.js
var require_exports = __commonJS({
  "node_modules/mocha/lib/interfaces/exports.js"(exports, module) {
    "use strict";
    init_shim();
    var Suite = require_suite();
    var Test = require_test();
    module.exports = function(suite) {
      var suites = [suite];
      suite.on(Suite.constants.EVENT_FILE_REQUIRE, visit);
      function visit(obj, file) {
        var suite2;
        for (var key in obj) {
          if (typeof obj[key] === "function") {
            var fn = obj[key];
            switch (key) {
              case "before":
                suites[0].beforeAll(fn);
                break;
              case "after":
                suites[0].afterAll(fn);
                break;
              case "beforeEach":
                suites[0].beforeEach(fn);
                break;
              case "afterEach":
                suites[0].afterEach(fn);
                break;
              default:
                var test = new Test(key, fn);
                test.file = file;
                suites[0].addTest(test);
            }
          } else {
            suite2 = Suite.create(suites[0], key);
            suites.unshift(suite2);
            visit(obj[key], file);
            suites.shift();
          }
        }
      }
    };
    module.exports.description = 'Node.js module ("exports") style';
  }
});

// node_modules/mocha/lib/interfaces/index.js
var require_interfaces = __commonJS({
  "node_modules/mocha/lib/interfaces/index.js"(exports) {
    "use strict";
    init_shim();
    exports.bdd = require_bdd();
    exports.tdd = require_tdd();
    exports.qunit = require_qunit();
    exports.exports = require_exports();
  }
});

// node_modules/mocha/lib/context.js
var require_context = __commonJS({
  "node_modules/mocha/lib/context.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = Context;
    function Context() {
    }
    Context.prototype.runnable = function(runnable) {
      if (!arguments.length) {
        return this._runnable;
      }
      this.test = this._runnable = runnable;
      return this;
    };
    Context.prototype.timeout = function(ms) {
      if (!arguments.length) {
        return this.runnable().timeout();
      }
      this.runnable().timeout(ms);
      return this;
    };
    Context.prototype.slow = function(ms) {
      if (!arguments.length) {
        return this.runnable().slow();
      }
      this.runnable().slow(ms);
      return this;
    };
    Context.prototype.skip = function() {
      this.runnable().skip();
    };
    Context.prototype.retries = function(n) {
      if (!arguments.length) {
        return this.runnable().retries();
      }
      this.runnable().retries(n);
      return this;
    };
  }
});

// (disabled):node_modules/mocha/lib/nodejs/file-unloader
var require_file_unloader = __commonJS({
  "(disabled):node_modules/mocha/lib/nodejs/file-unloader"() {
    init_shim();
  }
});

// node_modules/mocha/package.json
var require_package = __commonJS({
  "node_modules/mocha/package.json"(exports, module) {
    module.exports = {
      name: "mocha",
      version: "10.2.0",
      type: "commonjs",
      description: "simple, flexible, fun test framework",
      keywords: [
        "mocha",
        "test",
        "bdd",
        "tdd",
        "tap",
        "testing",
        "chai",
        "assertion",
        "ava",
        "jest",
        "tape",
        "jasmine",
        "karma"
      ],
      author: "TJ Holowaychuk <tj@vision-media.ca>",
      license: "MIT",
      repository: {
        type: "git",
        url: "https://github.com/mochajs/mocha.git"
      },
      bugs: {
        url: "https://github.com/mochajs/mocha/issues/"
      },
      funding: {
        type: "opencollective",
        url: "https://opencollective.com/mochajs"
      },
      gitter: "https://gitter.im/mochajs/mocha",
      homepage: "https://mochajs.org/",
      logo: "https://cldup.com/S9uQ-cOLYz.svg",
      notifyLogo: "https://ibin.co/4QuRuGjXvl36.png",
      bin: {
        mocha: "./bin/mocha.js",
        _mocha: "./bin/_mocha"
      },
      directories: {
        lib: "./lib",
        test: "./test"
      },
      engines: {
        node: ">= 14.0.0"
      },
      scripts: {
        prepublishOnly: "nps test clean build",
        start: "nps",
        test: "nps test",
        version: "nps version",
        "test:smoke": "node ./bin/mocha --no-config test/smoke/smoke.spec.js"
      },
      dependencies: {
        "ansi-colors": "4.1.1",
        "browser-stdout": "1.3.1",
        chokidar: "3.5.3",
        debug: "4.3.4",
        diff: "5.0.0",
        "escape-string-regexp": "4.0.0",
        "find-up": "5.0.0",
        glob: "7.2.0",
        he: "1.2.0",
        "js-yaml": "4.1.0",
        "log-symbols": "4.1.0",
        minimatch: "5.0.1",
        ms: "2.1.3",
        nanoid: "3.3.3",
        "serialize-javascript": "6.0.0",
        "strip-json-comments": "3.1.1",
        "supports-color": "8.1.1",
        workerpool: "6.2.1",
        yargs: "16.2.0",
        "yargs-parser": "20.2.4",
        "yargs-unparser": "2.0.0"
      },
      devDependencies: {
        "@11ty/eleventy": "^1.0.0",
        "@11ty/eleventy-plugin-inclusive-language": "^1.0.3",
        "@babel/eslint-parser": "^7.19.1",
        "@mocha/docdash": "^4.0.1",
        "@rollup/plugin-commonjs": "^21.0.2",
        "@rollup/plugin-json": "^4.1.0",
        "@rollup/plugin-multi-entry": "^4.0.1",
        "@rollup/plugin-node-resolve": "^13.1.3",
        "assetgraph-builder": "^9.0.0",
        autoprefixer: "^9.8.6",
        canvas: "^2.9.0",
        chai: "^4.3.4",
        coffeescript: "^2.6.1",
        coveralls: "^3.1.1",
        "cross-env": "^7.0.2",
        eslint: "^8.24.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-config-semistandard": "^17.0.0",
        "eslint-config-standard": "^17.0.0",
        "eslint-plugin-import": "^2.24.2",
        "eslint-plugin-node": "^11.1.0",
        "eslint-plugin-prettier": "^4.2.1",
        "eslint-plugin-promise": "^6.0.1",
        "fail-on-errors-webpack-plugin": "^3.0.0",
        "fs-extra": "^10.0.0",
        husky: "^4.2.5",
        hyperlink: "^5.0.4",
        jsdoc: "^3.6.7",
        "jsdoc-ts-utils": "^2.0.1",
        karma: "^6.3.11",
        "karma-chrome-launcher": "^3.1.0",
        "karma-mocha": "^2.0.1",
        "karma-mocha-reporter": "^2.2.5",
        "karma-sauce-launcher": "^4.3.6",
        "lint-staged": "^10.2.11",
        "markdown-it": "^12.3.2",
        "markdown-it-anchor": "^8.4.1",
        "markdown-it-attrs": "^4.1.3",
        "markdown-it-emoji": "^2.0.0",
        "markdown-it-prism": "^2.2.2",
        "markdown-toc": "^1.2.0",
        "markdownlint-cli": "^0.30.0",
        needle: "^2.5.0",
        nps: "^5.10.0",
        nyc: "^15.1.0",
        pidtree: "^0.5.0",
        prettier: "^2.4.1",
        remark: "^14.0.2",
        "remark-github": "^11.2.2",
        "remark-inline-links": "^6.0.1",
        rewiremock: "^3.14.3",
        rimraf: "^3.0.2",
        rollup: "^2.70.1",
        "rollup-plugin-node-globals": "^1.4.0",
        "rollup-plugin-polyfill-node": "^0.8.0",
        "rollup-plugin-visualizer": "^5.6.0",
        sinon: "^9.0.3",
        "strip-ansi": "^6.0.0",
        svgo: "^1.3.2",
        touch: "^3.1.0",
        unexpected: "^11.14.0",
        "unexpected-eventemitter": "^2.2.0",
        "unexpected-map": "^2.0.0",
        "unexpected-set": "^3.0.0",
        "unexpected-sinon": "^10.11.2",
        "update-notifier": "^4.1.0",
        uslug: "^1.0.4",
        uuid: "^8.3.0",
        webpack: "^5.67.0",
        "webpack-cli": "^4.9.1"
      },
      files: [
        "bin/*mocha*",
        "lib/**/*.{js,html,json}",
        "index.js",
        "mocha.css",
        "mocha.js",
        "mocha.js.map",
        "browser-entry.js"
      ],
      browser: {
        "./index.js": "./browser-entry.js",
        fs: false,
        path: false,
        "supports-color": false,
        "./lib/nodejs/buffered-worker-pool.js": false,
        "./lib/nodejs/esm-utils.js": false,
        "./lib/nodejs/file-unloader.js": false,
        "./lib/nodejs/parallel-buffered-runner.js": false,
        "./lib/nodejs/serializer.js": false,
        "./lib/nodejs/worker.js": false,
        "./lib/nodejs/reporters/parallel-buffered.js": false,
        "./lib/cli/index.js": false
      },
      prettier: {
        arrowParens: "avoid",
        bracketSpacing: false,
        endOfLine: "auto",
        singleQuote: true,
        trailingComma: "none"
      },
      husky: {
        hooks: {
          "pre-commit": "lint-staged"
        }
      }
    };
  }
});

// (disabled):node_modules/mocha/lib/nodejs/parallel-buffered-runner
var require_parallel_buffered_runner = __commonJS({
  "(disabled):node_modules/mocha/lib/nodejs/parallel-buffered-runner"() {
    init_shim();
  }
});

// node_modules/mocha/lib/mocha.js
var require_mocha = __commonJS({
  "node_modules/mocha/lib/mocha.js"(exports, module) {
    "use strict";
    init_shim();
    var escapeRe = require_escape_string_regexp();
    var path = require_path_browserify();
    var builtinReporters = require_reporters();
    var utils = require_utils();
    var mocharc = require_mocharc();
    var Suite = require_suite();
    var esmUtils = require_esm_utils();
    var createStatsCollector = require_stats_collector();
    var {
      createInvalidReporterError,
      createInvalidInterfaceError,
      createMochaInstanceAlreadyDisposedError,
      createMochaInstanceAlreadyRunningError,
      createUnsupportedError
    } = require_errors();
    var { EVENT_FILE_PRE_REQUIRE, EVENT_FILE_POST_REQUIRE, EVENT_FILE_REQUIRE } = Suite.constants;
    var debug = require_browser3()("mocha:mocha");
    exports = module.exports = Mocha;
    var mochaStates = utils.defineConstants({
      /**
       * Initial state of the mocha instance
       * @private
       */
      INIT: "init",
      /**
       * Mocha instance is running tests
       * @private
       */
      RUNNING: "running",
      /**
       * Mocha instance is done running tests and references to test functions and hooks are cleaned.
       * You can reset this state by unloading the test files.
       * @private
       */
      REFERENCES_CLEANED: "referencesCleaned",
      /**
       * Mocha instance is disposed and can no longer be used.
       * @private
       */
      DISPOSED: "disposed"
    });
    if (!utils.isBrowser() && typeof module.paths !== "undefined") {
      cwd = utils.cwd();
      module.paths.push(cwd, path.join(cwd, "node_modules"));
    }
    var cwd;
    exports.utils = utils;
    exports.interfaces = require_interfaces();
    exports.reporters = builtinReporters;
    exports.Runnable = require_runnable();
    exports.Context = require_context();
    exports.Runner = require_runner();
    exports.Suite = Suite;
    exports.Hook = require_hook();
    exports.Test = require_test();
    var currentContext;
    exports.afterEach = function(...args) {
      return (currentContext.afterEach || currentContext.teardown).apply(
        this,
        args
      );
    };
    exports.after = function(...args) {
      return (currentContext.after || currentContext.suiteTeardown).apply(
        this,
        args
      );
    };
    exports.beforeEach = function(...args) {
      return (currentContext.beforeEach || currentContext.setup).apply(this, args);
    };
    exports.before = function(...args) {
      return (currentContext.before || currentContext.suiteSetup).apply(this, args);
    };
    exports.describe = function(...args) {
      return (currentContext.describe || currentContext.suite).apply(this, args);
    };
    exports.describe.only = function(...args) {
      return (currentContext.describe || currentContext.suite).only.apply(
        this,
        args
      );
    };
    exports.describe.skip = function(...args) {
      return (currentContext.describe || currentContext.suite).skip.apply(
        this,
        args
      );
    };
    exports.it = function(...args) {
      return (currentContext.it || currentContext.test).apply(this, args);
    };
    exports.it.only = function(...args) {
      return (currentContext.it || currentContext.test).only.apply(this, args);
    };
    exports.it.skip = function(...args) {
      return (currentContext.it || currentContext.test).skip.apply(this, args);
    };
    exports.xdescribe = exports.describe.skip;
    exports.xit = exports.it.skip;
    exports.setup = exports.beforeEach;
    exports.suiteSetup = exports.before;
    exports.suiteTeardown = exports.after;
    exports.suite = exports.describe;
    exports.teardown = exports.afterEach;
    exports.test = exports.it;
    exports.run = function(...args) {
      return currentContext.run.apply(this, args);
    };
    function Mocha(options = {}) {
      options = { ...mocharc, ...options };
      this.files = [];
      this.options = options;
      this.suite = new exports.Suite("", new exports.Context(), true);
      this._cleanReferencesAfterRun = true;
      this._state = mochaStates.INIT;
      this.grep(options.grep).fgrep(options.fgrep).ui(options.ui).reporter(
        options.reporter,
        options.reporterOption || options.reporterOptions
        // for backwards compatibility
      ).slow(options.slow).global(options.global);
      if (typeof options.timeout !== "undefined") {
        this.timeout(options.timeout === false ? 0 : options.timeout);
      }
      if ("retries" in options) {
        this.retries(options.retries);
      }
      [
        "allowUncaught",
        "asyncOnly",
        "bail",
        "checkLeaks",
        "color",
        "delay",
        "diff",
        "dryRun",
        "failZero",
        "forbidOnly",
        "forbidPending",
        "fullTrace",
        "inlineDiffs",
        "invert"
      ].forEach(function(opt) {
        if (options[opt]) {
          this[opt]();
        }
      }, this);
      if (options.rootHooks) {
        this.rootHooks(options.rootHooks);
      }
      this._runnerClass = exports.Runner;
      this._lazyLoadFiles = false;
      this.isWorker = Boolean(options.isWorker);
      this.globalSetup(options.globalSetup).globalTeardown(options.globalTeardown).enableGlobalSetup(options.enableGlobalSetup).enableGlobalTeardown(options.enableGlobalTeardown);
      if (options.parallel && (typeof options.jobs === "undefined" || options.jobs > 1)) {
        debug("attempting to enable parallel mode");
        this.parallelMode(true);
      }
    }
    Mocha.prototype.bail = function(bail) {
      this.suite.bail(bail !== false);
      return this;
    };
    Mocha.prototype.addFile = function(file) {
      this.files.push(file);
      return this;
    };
    Mocha.prototype.reporter = function(reporterName, reporterOptions) {
      if (typeof reporterName === "function") {
        this._reporter = reporterName;
      } else {
        reporterName = reporterName || "spec";
        var reporter;
        if (builtinReporters[reporterName]) {
          reporter = builtinReporters[reporterName];
        }
        if (!reporter) {
          let foundReporter;
          try {
            foundReporter = __require.resolve(reporterName);
            reporter = __require(foundReporter);
          } catch (err) {
            if (foundReporter) {
              throw createInvalidReporterError(err.message, foundReporter);
            }
            try {
              reporter = __require(path.resolve(reporterName));
            } catch (e) {
              throw createInvalidReporterError(e.message, reporterName);
            }
          }
        }
        this._reporter = reporter;
      }
      this.options.reporterOption = reporterOptions;
      this.options.reporterOptions = reporterOptions;
      return this;
    };
    Mocha.prototype.ui = function(ui) {
      var bindInterface;
      if (typeof ui === "function") {
        bindInterface = ui;
      } else {
        ui = ui || "bdd";
        bindInterface = exports.interfaces[ui];
        if (!bindInterface) {
          try {
            bindInterface = __require(ui);
          } catch (err) {
            throw createInvalidInterfaceError(`invalid interface '${ui}'`, ui);
          }
        }
      }
      bindInterface(this.suite);
      this.suite.on(EVENT_FILE_PRE_REQUIRE, function(context) {
        currentContext = context;
      });
      return this;
    };
    Mocha.prototype.loadFiles = function(fn) {
      var self2 = this;
      var suite = this.suite;
      this.files.forEach(function(file) {
        file = path.resolve(file);
        suite.emit(EVENT_FILE_PRE_REQUIRE, _global, file, self2);
        suite.emit(EVENT_FILE_REQUIRE, __require(file), file, self2);
        suite.emit(EVENT_FILE_POST_REQUIRE, _global, file, self2);
      });
      fn && fn();
    };
    Mocha.prototype.loadFilesAsync = function({ esmDecorator } = {}) {
      var self2 = this;
      var suite = this.suite;
      this.lazyLoadFiles(true);
      return esmUtils.loadFilesAsync(
        this.files,
        function(file) {
          suite.emit(EVENT_FILE_PRE_REQUIRE, _global, file, self2);
        },
        function(file, resultModule) {
          suite.emit(EVENT_FILE_REQUIRE, resultModule, file, self2);
          suite.emit(EVENT_FILE_POST_REQUIRE, _global, file, self2);
        },
        esmDecorator
      );
    };
    Mocha.unloadFile = function(file) {
      if (utils.isBrowser()) {
        throw createUnsupportedError(
          "unloadFile() is only supported in a Node.js environment"
        );
      }
      return require_file_unloader().unloadFile(file);
    };
    Mocha.prototype.unloadFiles = function() {
      if (this._state === mochaStates.DISPOSED) {
        throw createMochaInstanceAlreadyDisposedError(
          "Mocha instance is already disposed, it cannot be used again.",
          this._cleanReferencesAfterRun,
          this
        );
      }
      this.files.forEach(function(file) {
        Mocha.unloadFile(file);
      });
      this._state = mochaStates.INIT;
      return this;
    };
    Mocha.prototype.fgrep = function(str) {
      if (!str) {
        return this;
      }
      return this.grep(new RegExp(escapeRe(str)));
    };
    Mocha.prototype.grep = function(re) {
      if (utils.isString(re)) {
        var arg = re.match(/^\/(.*)\/([gimy]{0,4})$|.*/);
        this.options.grep = new RegExp(arg[1] || arg[0], arg[2]);
      } else {
        this.options.grep = re;
      }
      return this;
    };
    Mocha.prototype.invert = function() {
      this.options.invert = true;
      return this;
    };
    Mocha.prototype.checkLeaks = function(checkLeaks) {
      this.options.checkLeaks = checkLeaks !== false;
      return this;
    };
    Mocha.prototype.cleanReferencesAfterRun = function(cleanReferencesAfterRun) {
      this._cleanReferencesAfterRun = cleanReferencesAfterRun !== false;
      return this;
    };
    Mocha.prototype.dispose = function() {
      if (this._state === mochaStates.RUNNING) {
        throw createMochaInstanceAlreadyRunningError(
          "Cannot dispose while the mocha instance is still running tests."
        );
      }
      this.unloadFiles();
      this._previousRunner && this._previousRunner.dispose();
      this.suite.dispose();
      this._state = mochaStates.DISPOSED;
    };
    Mocha.prototype.fullTrace = function(fullTrace) {
      this.options.fullTrace = fullTrace !== false;
      return this;
    };
    Mocha.prototype.global = function(global) {
      this.options.global = (this.options.global || []).concat(global).filter(Boolean).filter(function(elt, idx, arr) {
        return arr.indexOf(elt) === idx;
      });
      return this;
    };
    Mocha.prototype.globals = Mocha.prototype.global;
    Mocha.prototype.color = function(color) {
      this.options.color = color !== false;
      return this;
    };
    Mocha.prototype.inlineDiffs = function(inlineDiffs) {
      this.options.inlineDiffs = inlineDiffs !== false;
      return this;
    };
    Mocha.prototype.diff = function(diff) {
      this.options.diff = diff !== false;
      return this;
    };
    Mocha.prototype.timeout = function(msecs) {
      this.suite.timeout(msecs);
      return this;
    };
    Mocha.prototype.retries = function(retry) {
      this.suite.retries(retry);
      return this;
    };
    Mocha.prototype.slow = function(msecs) {
      this.suite.slow(msecs);
      return this;
    };
    Mocha.prototype.asyncOnly = function(asyncOnly) {
      this.options.asyncOnly = asyncOnly !== false;
      return this;
    };
    Mocha.prototype.noHighlighting = function() {
      this.options.noHighlighting = true;
      return this;
    };
    Mocha.prototype.allowUncaught = function(allowUncaught) {
      this.options.allowUncaught = allowUncaught !== false;
      return this;
    };
    Mocha.prototype.delay = function delay() {
      this.options.delay = true;
      return this;
    };
    Mocha.prototype.dryRun = function(dryRun) {
      this.options.dryRun = dryRun !== false;
      return this;
    };
    Mocha.prototype.failZero = function(failZero) {
      this.options.failZero = failZero !== false;
      return this;
    };
    Mocha.prototype.forbidOnly = function(forbidOnly) {
      this.options.forbidOnly = forbidOnly !== false;
      return this;
    };
    Mocha.prototype.forbidPending = function(forbidPending) {
      this.options.forbidPending = forbidPending !== false;
      return this;
    };
    Mocha.prototype._guardRunningStateTransition = function() {
      if (this._state === mochaStates.RUNNING) {
        throw createMochaInstanceAlreadyRunningError(
          "Mocha instance is currently running tests, cannot start a next test run until this one is done",
          this
        );
      }
      if (this._state === mochaStates.DISPOSED || this._state === mochaStates.REFERENCES_CLEANED) {
        throw createMochaInstanceAlreadyDisposedError(
          "Mocha instance is already disposed, cannot start a new test run. Please create a new mocha instance. Be sure to set disable `cleanReferencesAfterRun` when you want to reuse the same mocha instance for multiple test runs.",
          this._cleanReferencesAfterRun,
          this
        );
      }
    };
    Object.defineProperty(Mocha.prototype, "version", {
      value: require_package().version,
      configurable: false,
      enumerable: true,
      writable: false
    });
    Mocha.prototype.run = function(fn) {
      this._guardRunningStateTransition();
      this._state = mochaStates.RUNNING;
      if (this._previousRunner) {
        this._previousRunner.dispose();
        this.suite.reset();
      }
      if (this.files.length && !this._lazyLoadFiles) {
        this.loadFiles();
      }
      var suite = this.suite;
      var options = this.options;
      options.files = this.files;
      const runner = new this._runnerClass(suite, {
        cleanReferencesAfterRun: this._cleanReferencesAfterRun,
        delay: options.delay,
        dryRun: options.dryRun,
        failZero: options.failZero
      });
      createStatsCollector(runner);
      var reporter = new this._reporter(runner, options);
      runner.checkLeaks = options.checkLeaks === true;
      runner.fullStackTrace = options.fullTrace;
      runner.asyncOnly = options.asyncOnly;
      runner.allowUncaught = options.allowUncaught;
      runner.forbidOnly = options.forbidOnly;
      runner.forbidPending = options.forbidPending;
      if (options.grep) {
        runner.grep(options.grep, options.invert);
      }
      if (options.global) {
        runner.globals(options.global);
      }
      if (options.color !== void 0) {
        exports.reporters.Base.useColors = options.color;
      }
      exports.reporters.Base.inlineDiffs = options.inlineDiffs;
      exports.reporters.Base.hideDiff = !options.diff;
      const done = (failures) => {
        this._previousRunner = runner;
        this._state = this._cleanReferencesAfterRun ? mochaStates.REFERENCES_CLEANED : mochaStates.INIT;
        fn = fn || utils.noop;
        if (typeof reporter.done === "function") {
          reporter.done(failures, fn);
        } else {
          fn(failures);
        }
      };
      const runAsync = async (runner2) => {
        const context = this.options.enableGlobalSetup && this.hasGlobalSetupFixtures() ? await this.runGlobalSetup(runner2) : {};
        const failureCount = await runner2.runAsync({
          files: this.files,
          options
        });
        if (this.options.enableGlobalTeardown && this.hasGlobalTeardownFixtures()) {
          await this.runGlobalTeardown(runner2, { context });
        }
        return failureCount;
      };
      runAsync(runner).then(done);
      return runner;
    };
    Mocha.prototype.rootHooks = function rootHooks({
      beforeAll = [],
      beforeEach = [],
      afterAll = [],
      afterEach = []
    } = {}) {
      beforeAll = utils.castArray(beforeAll);
      beforeEach = utils.castArray(beforeEach);
      afterAll = utils.castArray(afterAll);
      afterEach = utils.castArray(afterEach);
      beforeAll.forEach((hook) => {
        this.suite.beforeAll(hook);
      });
      beforeEach.forEach((hook) => {
        this.suite.beforeEach(hook);
      });
      afterAll.forEach((hook) => {
        this.suite.afterAll(hook);
      });
      afterEach.forEach((hook) => {
        this.suite.afterEach(hook);
      });
      return this;
    };
    Mocha.prototype.parallelMode = function parallelMode(enable = true) {
      if (utils.isBrowser()) {
        throw createUnsupportedError("parallel mode is only supported in Node.js");
      }
      const parallel = Boolean(enable);
      if (parallel === this.options.parallel && this._lazyLoadFiles && this._runnerClass !== exports.Runner) {
        return this;
      }
      if (this._state !== mochaStates.INIT) {
        throw createUnsupportedError(
          "cannot change parallel mode after having called run()"
        );
      }
      this.options.parallel = parallel;
      this._runnerClass = parallel ? require_parallel_buffered_runner() : exports.Runner;
      return this.lazyLoadFiles(this._lazyLoadFiles || parallel);
    };
    Mocha.prototype.lazyLoadFiles = function lazyLoadFiles(enable) {
      this._lazyLoadFiles = enable === true;
      debug("set lazy load to %s", enable);
      return this;
    };
    Mocha.prototype.globalSetup = function globalSetup(setupFns = []) {
      setupFns = utils.castArray(setupFns);
      this.options.globalSetup = setupFns;
      debug("configured %d global setup functions", setupFns.length);
      return this;
    };
    Mocha.prototype.globalTeardown = function globalTeardown(teardownFns = []) {
      teardownFns = utils.castArray(teardownFns);
      this.options.globalTeardown = teardownFns;
      debug("configured %d global teardown functions", teardownFns.length);
      return this;
    };
    Mocha.prototype.runGlobalSetup = async function runGlobalSetup(context = {}) {
      const { globalSetup } = this.options;
      if (globalSetup && globalSetup.length) {
        debug("run(): global setup starting");
        await this._runGlobalFixtures(globalSetup, context);
        debug("run(): global setup complete");
      }
      return context;
    };
    Mocha.prototype.runGlobalTeardown = async function runGlobalTeardown(context = {}) {
      const { globalTeardown } = this.options;
      if (globalTeardown && globalTeardown.length) {
        debug("run(): global teardown starting");
        await this._runGlobalFixtures(globalTeardown, context);
      }
      debug("run(): global teardown complete");
      return context;
    };
    Mocha.prototype._runGlobalFixtures = async function _runGlobalFixtures(fixtureFns = [], context = {}) {
      for await (const fixtureFn of fixtureFns) {
        await fixtureFn.call(context);
      }
      return context;
    };
    Mocha.prototype.enableGlobalSetup = function enableGlobalSetup(enabled = true) {
      this.options.enableGlobalSetup = Boolean(enabled);
      return this;
    };
    Mocha.prototype.enableGlobalTeardown = function enableGlobalTeardown(enabled = true) {
      this.options.enableGlobalTeardown = Boolean(enabled);
      return this;
    };
    Mocha.prototype.hasGlobalSetupFixtures = function hasGlobalSetupFixtures() {
      return Boolean(this.options.globalSetup.length);
    };
    Mocha.prototype.hasGlobalTeardownFixtures = function hasGlobalTeardownFixtures() {
      return Boolean(this.options.globalTeardown.length);
    };
  }
});

// node_modules/mocha/browser-entry.js
var require_browser_entry = __commonJS({
  "node_modules/mocha/browser-entry.js"(exports, module) {
    init_shim();
    import_process.default.stdout = require_browser_stdout()({ label: false });
    var parseQuery = require_parse_query();
    var highlightTags = require_highlight_tags();
    var Mocha = require_mocha();
    var mocha = new Mocha({ reporter: "html" });
    var Date2 = _global.Date;
    var setTimeout2 = _global.setTimeout;
    var setInterval = _global.setInterval;
    var clearTimeout = _global.clearTimeout;
    var clearInterval = _global.clearInterval;
    var uncaughtExceptionHandlers = [];
    var originalOnerrorHandler = _global.onerror;
    import_process.default.removeListener = function(e, fn) {
      if (e === "uncaughtException") {
        if (originalOnerrorHandler) {
          _global.onerror = originalOnerrorHandler;
        } else {
          _global.onerror = function() {
          };
        }
        var i = uncaughtExceptionHandlers.indexOf(fn);
        if (i !== -1) {
          uncaughtExceptionHandlers.splice(i, 1);
        }
      }
    };
    import_process.default.listenerCount = function(name) {
      if (name === "uncaughtException") {
        return uncaughtExceptionHandlers.length;
      }
      return 0;
    };
    import_process.default.on = function(e, fn) {
      if (e === "uncaughtException") {
        _global.onerror = function(err, url, line) {
          fn(new Error(err + " (" + url + ":" + line + ")"));
          return !mocha.options.allowUncaught;
        };
        uncaughtExceptionHandlers.push(fn);
      }
    };
    import_process.default.listeners = function(e) {
      if (e === "uncaughtException") {
        return uncaughtExceptionHandlers;
      }
      return [];
    };
    mocha.suite.removeAllListeners("pre-require");
    var immediateQueue = [];
    var immediateTimeout;
    function timeslice() {
      var immediateStart = new Date2().getTime();
      while (immediateQueue.length && new Date2().getTime() - immediateStart < 100) {
        immediateQueue.shift()();
      }
      if (immediateQueue.length) {
        immediateTimeout = setTimeout2(timeslice, 0);
      } else {
        immediateTimeout = null;
      }
    }
    Mocha.Runner.immediately = function(callback) {
      immediateQueue.push(callback);
      if (!immediateTimeout) {
        immediateTimeout = setTimeout2(timeslice, 0);
      }
    };
    mocha.throwError = function(err) {
      uncaughtExceptionHandlers.forEach(function(fn) {
        fn(err);
      });
      throw err;
    };
    mocha.ui = function(ui) {
      Mocha.prototype.ui.call(this, ui);
      this.suite.emit("pre-require", _global, null, this);
      return this;
    };
    mocha.setup = function(opts) {
      if (typeof opts === "string") {
        opts = { ui: opts };
      }
      if (opts.delay === true) {
        this.delay();
      }
      var self2 = this;
      Object.keys(opts).filter(function(opt) {
        return opt !== "delay";
      }).forEach(function(opt) {
        if (Object.prototype.hasOwnProperty.call(opts, opt)) {
          self2[opt](opts[opt]);
        }
      });
      return this;
    };
    mocha.run = function(fn) {
      var options = mocha.options;
      mocha.globals("location");
      var query = parseQuery(_global.location.search || "");
      if (query.grep) {
        mocha.grep(query.grep);
      }
      if (query.fgrep) {
        mocha.fgrep(query.fgrep);
      }
      if (query.invert) {
        mocha.invert();
      }
      return Mocha.prototype.run.call(mocha, function(err) {
        var document2 = _global.document;
        if (document2 && document2.getElementById("mocha") && options.noHighlighting !== true) {
          highlightTags("code");
        }
        if (fn) {
          fn(err);
        }
      });
    };
    Mocha.process = import_process.default;
    _global.Mocha = Mocha;
    _global.mocha = mocha;
    [
      "describe",
      "context",
      "it",
      "specify",
      "xdescribe",
      "xcontext",
      "xit",
      "xspecify",
      "before",
      "beforeEach",
      "afterEach",
      "after"
    ].forEach(function(key) {
      mocha[key] = _global[key];
    });
    module.exports = mocha;
  }
});
export default require_browser_entry();
/*! Bundled license information:

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

he/he.js:
  (*! https://mths.be/he v1.2.0 by @mathias | MIT license *)

mocha/lib/mocha.js:
  (*!
   * mocha
   * Copyright(c) 2011 TJ Holowaychuk <tj@vision-media.ca>
   * MIT Licensed
   *)
*/
//# sourceMappingURL=mocha.js.map
